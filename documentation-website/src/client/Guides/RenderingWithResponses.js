import React from "react";
import { Link } from "@curi/react";

import BaseGuide from "./base/BaseGuide";
import {
  PrismBlock,
  InlineJS as IJS,
  InlineComponent as Cmp
} from "../components/PrismBlocks";
import { Note } from "../components/Messages";
import { Section, Subsection } from "../components/Sections";

export default ({ name }) => (
  <BaseGuide>
    <h1>{name}</h1>
    <p>
      Response objects are what you use to help render your application. They
      are essentially just a collection of properties related to which route
      matched the current location. You can pick and choose which ones you need
      to use when you are rendering. There is no one "correct" way render with a
      response, but in this guide we will use the response's body property and a
      render function.
    </p>

    <Section title="The Properties of a Response Object" id="properties">
      <PrismBlock lang="javascript">
        {`{
  // The location key
  key: '1.0',

  // The location object used to generate the response.
  location: { pathname: '/photos/6789/12345', ... },

  // The status code for the response.
  // This defaults to 200, but can be changed
  // if no routes match or a route issues a redirect.
  status: 200,

  // If the route had a match.response function and called
  // set.data, that value will be set here. If not,
  // this will be undefined.
  data: {...},

  // The title string generated by the route
  // or an empty string if the route has no title property
  title: 'Photo 12345',

  // The value returned by the route's body function
  body: Photo,

  // The name of the best matching route
  name: 'Photo',

  // The name of ancestor routes that matched
  // part of the location's pathname
  partials: ['Album'],

  // An object containing the values parsed
  // from the pathname by path-to-regexp.
  params: { photoID: 12345, albumID: 6789 },

  // If an error occurs while generating the
  // response, it will be set here
  error: undefined
}`}
      </PrismBlock>

      <Subsection title="Redirect Response" id="redirect-properties">
        <p>
          When you redirect, a slightly different response object will be
          created. You are in charge of actually redirecting, Curi just
          generates a response that lets you know that you should redirect. You
          can redirect by using your history object's replace (or push) methods,
          or if you are using one of the library specific Curi packages, there
          might be a built-in way for you to redirect (e.g. curi-react provides
          the <Cmp>Redirect</Cmp> component).
        </p>
        <PrismBlock lang="javascript">
          {`{
  // These properties also exist on the redirect response
  key: '1.0',
  location: { pathname: '/photos/6789/12345', ... },
  status: 301,
  data: {...},
  title: 'Photo 12345',

  // The redirectTo property provides information on
  // where you should redirect to
  redirectTo: { pathname: '/login' }
}`}
        </PrismBlock>
      </Subsection>
    </Section>

    <Section title="The Body Property" id="body-property">
      <p>
        The body property of a response is the value set by the matched route's{" "}
        <IJS>match.response</IJS> function, using <IJS>set.body()</IJS>. This
        value can be anything you want it to be, but it should usually be a
        function/component. Here, we will assume that each of your routes have{" "}
        <IJS>body</IJS> properties that return a function.
      </p>
      <PrismBlock lang="javascript">
        {`// we are assuming all routes are setup like this
{
  ...,
  match: {
    response: ({ set }) => {
      set.body(function() { ... });
    }
  }
}`}
      </PrismBlock>
      <p>
        The response's <IJS>body</IJS> function should take other response
        properties as its arguments. Which ones will vary based on your
        application, but if you are using path parameters, then the{" "}
        <IJS>params</IJS> object should be one of these. If you are doing data
        loading in your routes (using the
        <IJS>match.every</IJS> property), then you will probably also want to
        pass the data property (which is attached to the response in the{" "}
        <IJS>match.response</IJS> function) to your body function.
      </p>
      <Note>
        It is important that each body function has the same argument signature.
        If you want to play it safe, you can just have each function expect to
        receive the full response object as an argument.
      </Note>
      <p>
        As stated above, the body property does not have to be a function. You
        may want to pass extra data for each route, in which case it might be
        convenient for the route's <IJS>set.body</IJS> call to set the{" "}
        <IJS>body</IJS> as an object. This can be useful if you want to have
        multiple render functions (where each one would manipulate a different
        part of your application).
      </p>
      <PrismBlock lang="javascript">
        {`{
  name: 'User',
  match: {
    response: ({ set }) => {
      set.body({
        main: function User() {...},
        menu: function UserMenu() {...}
      });
    }
  }
}`}
      </PrismBlock>
    </Section>

    <Section title="The Render Function" id="render-function">
      <p>
        A render function is simply a function that receives a response object
        as its argument and manipulates the DOM (or its equivalent for
        non-browser environments) using the response. In React or Vue, a render
        function would trigger a re-rendering of your application. In vanilla
        JavaScript, a render function would manually update the DOM.
      </p>

      <Subsection title="Rendering HTML" id="rendering-HTML">
        <p>
          We are now ready to render the content of our application using the{" "}
          <IJS>response</IJS>. There is still one thing to verify: that our{" "}
          <IJS>response</IJS> actually has a <IJS>body</IJS> property. If none
          of your routes match, then the response will not have a{" "}
          <IJS>body</IJS> property. You can provide a function that will be used
          when there is no <IJS>body</IJS> property, but a better remedy is to
          add a wildcard route to the end of your routes array
        </p>
        <PrismBlock lang="javascript">
          {`// a "not found" body function
function render({ response }) {
  //...
  const body = response.body || function notFound() {...}
  body(response.params);
}

// use a wildcard route
const routes = [
  // ...,
  {
    name: 'Not Found',
    path: '(.*)',
    match: {
      response({ set }) {
        set.body(NotFound);
      }
    }
  }
];`}
        </PrismBlock>

        <p>
          Now that we have our body function, we just need to call it. The exact
          behavior will vary based on how you are rendering your application.
        </p>
        <p>
          For a React application, we would just return JSX (or use React's{" "}
          <IJS>createElement</IJS> function).
        </p>

        <PrismBlock lang="javascript">
          {`function render({ response }) {
  const Body = response.body;
  return <Body response={response} />
  // return React.createElement(Body, { response });
}`}
        </PrismBlock>

        <p>
          For vanilla JavaScript, our body function probably returns an HTML
          string, so we would assign the returned value to the DOM node that
          holds our application.
        </p>

        <PrismBlock lang="javascript">
          {`// vanilla JavaScript
const root = document.getElementById('root');

function render({ response }) {
  // call the body function to return content
  root.innerHTML = response.body(response);
}`}
        </PrismBlock>
      </Subsection>
    </Section>

    <div>
      <h2>Next</h2>
      <p>
        Let's take a moment to go back to our router and look at what Curi's
        add-ons are for in the{" "}
        <Link to="Guide" params={{ slug: "addons" }}>
          Using Add-ons
        </Link>{" "}
        guide.
      </p>
    </div>
  </BaseGuide>
);
