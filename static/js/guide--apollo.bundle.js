(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{117:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=function(){return l.default.createElement(l.default.Fragment,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,l.default.createElement("a",{href:"https://apollographql.com"},"Apollo")," is a great solution for managing an application's data using"," ",l.default.createElement("a",{href:"http://graphql.org"},"GraphQL"),"."),l.default.createElement("p",null,"There are a few different implementation strategies for integrating Apollo and Curi based on how tightly you want them to be paired."),l.default.createElement(r.Note,null,l.default.createElement("p",null,"This guide only covers integration between Curi and Apollo. If you are not already familiar with how to use Apollo, you will want to learn that first."),l.default.createElement("p",null,"Also, this guide will only be referencing Apollo's React implementation, but the principles are the same no matter how you render your application."))),l.default.createElement(u.Section,{title:"Setup",id:"setup"},l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Your application's Apollo client instance should be defined in its own module so that it can be imported throughout the application.")),l.default.createElement(i.CodeBlock,null,'// apollo.js\nimport ApolloClient from "apollo-boost";\n\nexport default ApolloClient({\n  uri: "https://example.com/graphql"\n});'),l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Apollo's React package provides an ",l.default.createElement(o.InlineComponent,null,"ApolloProvider")," ","component for accessing your Apollo client throughout the application. The ",l.default.createElement(o.InlineComponent,null,"Router")," (or whatever you name the root Curi component) should be a descendant of the"," ",l.default.createElement(o.InlineComponent,null,"ApolloProvider")," because we don't need to re-render the"," ",l.default.createElement(o.InlineComponent,null,"ApolloProvider")," for every new response.")),l.default.createElement(i.CodeBlock,{lang:"jsx"},'import { ApolloProvider } from "react-apollo";\nimport { curiProvider } from "@curi/react-dom";\n\nconst Router = curiProvider(router);\n\nReactDOM.render((\n  <ApolloProvider client={client}>\n    <Router>\n      {() => {...}}\n    </Router>\n  </ApolloProvider>\n), holder);')),l.default.createElement(u.Section,{title:"Loose Pairing",id:"loose-pairing"},l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Apollo and Curi don't actually have to know about each other. Curi can create a response without doing any data fetching and let Apollo handle that with its ",l.default.createElement(o.InlineComponent,null,"Query")," component.")),l.default.createElement(i.CodeBlock,null,"// routes.js\nimport Noun from \"./pages/Noun\";\n\n// nothing Apollo related in here\nconst routes = [\n  {\n    name: 'Noun',\n    path: 'noun/:word',\n    response: () => {\n      return {\n        body: Noun\n      };\n    }\n  }\n];"),l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Any location data that a query needs can be taken from the response object. The best way to access this from your components would be to pass the ",l.default.createElement(o.InlineJS,null,"response")," to the components rendered in the"," ",l.default.createElement(o.InlineComponent,null,"Router"),"'s ",l.default.createElement(o.InlineJS,null,"children")," prop, which is a render-invoked function.")),l.default.createElement(i.CodeBlock,{lang:"jsx"},"// index.js\nReactDOM.render((\n  <ApolloProvider client={client}>\n    <Router>\n      {({ response }) => {\n        const { body:Body } = response;\n        return <Body response={response} />;\n      }}\n    </Router>\n  </ApolloProvider>\n), holder);"),l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Because we pass the ",l.default.createElement(o.InlineJS,null,"response")," to the route's"," ",l.default.createElement(o.InlineJS,null,"body")," component, we can pass a ",l.default.createElement(o.InlineComponent,null,"Query")," the response's location params using ",l.default.createElement(o.InlineJS,null,"props.response.params"),".")),l.default.createElement(i.CodeBlock,{lang:"jsx"},'// pages/Nouns.js\nimport { Query } from "react-apollo";\n\nconst GET_NOUN = gql`\n  query noun($word: String!) {\n    noun(word: $word) {\n      word,\n      type,\n      definition\n    }\n  }\n`;\n\n// use the "word" param from the response props\n// to query the correct data\nconst Noun = ({ response }) => (\n  <Query\n    query={GET_NOUN}\n    variables={{ word: response.params.word }}\n  >\n    {({ loading, error, data }) => {\n      if (loading) {\n        return <Loading />;\n      }\n      // ...\n\n      return (\n        <div>\n          <h1>{data.noun.word}</h1>\n          <p>{data.noun.definition}</p>\n        </div>\n      )\n    }}\n  </Query>\n);')),l.default.createElement(u.Section,{title:"Tight Pairing",id:"tight-pairing"},l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"You can use your Apollo client instance to call queries in a route's"," ",l.default.createElement(o.InlineJS,null,"resolve")," functions. ",l.default.createElement(o.InlineJS,null,"resolve")," functions are expected to return a Promise, which is exactly what"," ",l.default.createElement(o.InlineJS,null,"client.query()")," returns, so tightly pairing Curi and Apollo is mostly center around using a ",l.default.createElement(o.InlineJS,null,"resolve")," function to return a ",l.default.createElement(o.InlineJS,null,"client.query()")," call. This will delay navigation until after a route's GraphQL data has been loaded by Apollo.")),l.default.createElement(i.CodeBlock,null,'import client from "./apollo";\nimport { EXAMPLE_QUERY } from "./queries";\n\nconst routes = [\n  {\n    name: "Example",\n    path: "example/:id",\n    resolve: {\n      data({ params }) {\n        return client.query({\n          query: EXAMPLE_QUERY,\n          variables: { id: params.id }\n        });\n      }\n    }\n  }\n];'),l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"There are two strategies for doing this. Both approaches require you to be able to import your Apollo client in the module where you define your routes, which is why we created client in its own module in the ",l.default.createElement(a.Link,{hash:"setup"},"setup")," section.")),l.default.createElement(i.CodeBlock,null,'// index.js\nimport client from "./apollo";\n\nReactDOM.render((\n  <ApolloProvider client={client}>\n    /*...*/\n  </ApolloProvider>\n), holder);\n\n// routes.js\nimport client from "./apollo";\n\n// ...'),l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"The first approach is to avoid the ",l.default.createElement(o.InlineComponent,null,"Query")," altogether. Instead, you can use a route's ",l.default.createElement(o.InlineJS,null,"response()")," property to attach the data fetched by Apollo directly to a response through its"," ",l.default.createElement(o.InlineJS,null,"data")," property."),l.default.createElement("p",null,"While we know at this point that the query has executed, we should also check ",l.default.createElement(o.InlineJS,null,"resolved.error")," in the ",l.default.createElement(o.InlineJS,null,"response()")," ","function to ensure that the query was executed successfully.")),l.default.createElement(i.CodeBlock,null,'// routes.js\nimport client from "./apollo";\nimport GET_VERB from "./queries";\n\nimport Verb from "./pages/Verb";\n\nexport default [\n  {\n    name: "Verb",\n    path: "verb/:word",\n    resolve: {\n      verb({ params }) {\n        return client.query({\n          query: GET_VERB,\n          variables: { word: params.word }\n        })\n      }\n    },\n    response({ error, resolved }) {\n      if (error) {\n        // handle failed queries\n      }\n      return {\n        body: Verb,\n        data: resolved.verb.data\n      }\n    }\n  }\n];'),l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"In the response's ",l.default.createElement(o.InlineJS,null,"body")," component, you would access the query data through the ",l.default.createElement(o.InlineJS,null,"response"),"'s ",l.default.createElement(o.InlineJS,null,"data")," ","property.")),l.default.createElement(i.CodeBlock,{lang:"jsx"},"// pages/Verb.js\nconst Verb = ({ response }) => (\n  <div>\n    <h1>{response.data.verb.word}</h1>\n    <p>\n      {response.data.verb.definition}\n    </p>\n  </div>\n)"),l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"The second approach is to use a ",l.default.createElement(o.InlineJS,null,"resolve")," function as a way to cache the data, but also use ",l.default.createElement(o.InlineComponent,null,"Query"),". With this approach, we do not have to attach the query data to the response; we are just relying on the fact that Apollo will execute and cache the results prior to navigation.")),l.default.createElement(i.CodeBlock,null,'// routes.js\nimport client from "./apollo";\nimport { GET_VERB } from "./queries";\n\nexport default [\n  {\n    name: "Verb",\n    path: "verb/:word",\n    resolve: {\n      data({ params }) {\n        // load the data so it is cached by\n        // your Apollo client\n        return client.query({\n          query: GET_VERB,\n          variables: { word: params.word }\n        })\n      }\n    }\n  }\n];'),l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"The route's component will render a ",l.default.createElement(o.InlineComponent,null,"Query")," to also call the query. Because the query has already been executed, Apollo will grab the data from its cache instead of re-sending a request to your server.")),l.default.createElement(i.CodeBlock,{lang:"jsx"},'// pages/Verb.js\nimport { GET_VERB } from "../queries";\n\nconst Verb = ({ response }) => (\n  <Query\n    query={GET_VERB}\n    variables={{ word: response.params.word }}\n  >\n    {({ loading, error, data }) => {\n      // ...\n      return (\n        <div>\n          <h1>{data.verb.word}</h1>\n          <p>\n            {data.verb.definition}\n          </p>\n        </div>\n      );\n    }}\n  </Query>\n)'),l.default.createElement(u.Subsection,{title:"Prefetching",id:"prefetch"},l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"One additional benefit of adding queries to routes using"," ",l.default.createElement(o.InlineJS,null,"resolve")," functions is that you can prefetch data for a route."),l.default.createElement("p",null,"The"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"route-prefetch"}},l.default.createElement(o.InlineJS,null,"@curi/route-prefetch"))," ","interaction lets you programmatically fetch the data for a route prior to navigating to a location.")),l.default.createElement(i.CodeBlock,null,'// index.js\nimport prefetch from "@curi/route-prefetch";\n\nconst routes = [\n  {\n    name: "Example",\n    path: "example/:id",\n    resolve: {\n      examples({ params }) {\n        client.query({\n          query: GET_EXAMPLES,\n          variables: { id: params.id }\n        })\n      }\n    }\n  }\n]\n\nconst router = curi(history, routes, {\n  route: [prefetch()]\n});\n\n// this will call the GET_EXAMPLES query\n// and Apollo will cache the results\nrouter.route.prefetch(\n  "Example",\n  { params: { id: 2 }}\n);'))))};var l=function(e){return e&&e.__esModule?e:{default:e}}(t(0)),a=t(1),o=t(6),r=t(11),u=t(10),i=t(7)}}]);