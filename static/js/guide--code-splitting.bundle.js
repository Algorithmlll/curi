(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{114:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return l.default.createElement(l.default.Fragment,null,l.default.createElement(u.Explanation,null,l.default.createElement("p",null,"If you are bundling an application with a lot of routes, users of your application may be downloading a lot of unnecessary content for the initial page render. Using code splitting, you can reduce the initial download size for your application by splitting code that is conditionally loaded into a separate bundle that is only downloaded when it is needed."),l.default.createElement(a.Note,null,"This guide assumes that you are using Webpack 2+ to bundle your application.")),l.default.createElement(r.Section,{title:"An app without code splitting",id:"no-split"},l.default.createElement(u.Explanation,null,l.default.createElement("p",null,"Let's start out by describing our application's routes without code splitting. We will import each route's component from the files where they are defined.")),l.default.createElement(u.CodeBlock,null,"import Home from './components/Home';\nimport Contact from './components/Contact';\nimport ContactMethod from './components/ContactMethod';\n\nconst routes = [\n  {\n    name: 'Home',\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    name: 'Contact',\n    path: 'contact',\n    response: () => {\n      return {\n        body: Contact\n      };\n    },\n    children: [\n      {\n        name: 'Contact Method',\n        path: ':method',\n        response: () => {\n          return {\n            body: ContactMethod\n          };\n        }\n      }\n    ]\n  }\n];")),l.default.createElement(r.Section,{title:"import() in resolve",id:"import"},l.default.createElement(u.Explanation,null,l.default.createElement("p",null,"Instead of having static imports, we will use the"," ",l.default.createElement(o.InlineJS,null,"import()")," function to import our modules. We will import our components by adding a property to a route's ",l.default.createElement(o.InlineJS,null,"resolve")," ","object. The property name for the function is how we will access the resolved data in the route's ",l.default.createElement(o.InlineJS,null,"response()")," function."),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"resolve")," functions are called every time a route matches. However, ",l.default.createElement(o.InlineJS,null,"import()")," calls automatically re-use the results of a previous call, so we do not have to worry about extra network requests."),l.default.createElement("p",null,"Here we will name the ",l.default.createElement(o.InlineJS,null,"resolve")," function for importing a component ",l.default.createElement(o.InlineJS,null,"body"),", since it will be set as the response's"," ",l.default.createElement(o.InlineJS,null,"body")," property."),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"resolve.body()")," should return a Promise;"," ",l.default.createElement(o.InlineJS,null,"import()"),", conveniently, returns a Promise. In our"," ",l.default.createElement(o.InlineJS,null,"response()")," function, instead of referencing values imported at the top of the file, we can reference the result of the"," ",l.default.createElement(o.InlineJS,null,"resolve.body()")," function using ",l.default.createElement(o.InlineJS,null,"resolved.body"),"."),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"import()")," resolves with a module object. If the component is a default export (",l.default.createElement(o.InlineJS,null,"export default MyComponent"),"), we can access the component through the imported module object's"," ",l.default.createElement(o.InlineJS,null,"default")," property.")),l.default.createElement(u.CodeBlock,null,"const routes = [\n  {\n    name: 'Home',\n    path: '',\n    resolve: {\n      body: () => (\n        import('./components/Home')\n          .then(module => module.default)\n      ),\n    },\n    response: ({ resolved }) => {\n      return {\n        body: resolved.body\n      };\n    }\n  },\n  {\n    name: 'Contact',\n    path: 'contact',\n    resolve: {\n      body: () => (\n        import('./components/Contact')\n          .then(module => module.default)\n      ),\n    },\n    response: ({ resolved }) => {\n      return {\n        body: resolved.body\n      };\n    },\n    children: [\n      {\n        name: 'Contact Method',\n        path: ':method',\n        resolve: {\n          body: () => (\n            import('./components/ContactMethod')\n              .then(module => module.default)\n          )\n        },\n        response: ({ resolved }) => {\n          return {\n            body: resolved.body\n          };\n        }\n      }\n    ]\n  }\n];")),l.default.createElement(r.Section,{title:"Other Approaches",id:"other"},l.default.createElement("p",null,"The approaches taken here are not the only way to do code splitting. Another approach is to skip the ",l.default.createElement(o.InlineJS,null,"resolve")," method and do code splitting at other points in your application (e.g."," ",l.default.createElement("a",{href:"https://github.com/jamiebuilds/react-loadable"},l.default.createElement(o.InlineJS,null,"react-loadable")),")."),l.default.createElement("p",null,"Whatever path you decide to go, hopefully this has shown you that setting up code splitting with a ",l.default.createElement(o.InlineJS,null,"resolve")," function is fairly simple to do. If you are using Webpack and want to reduce your initial bundle size, ",l.default.createElement(o.InlineJS,null,"resolve")," functions are a good way to accomplish this.")))};var l=function(e){return e&&e.__esModule?e:{default:e}}(n(0)),o=(n(1),n(6)),a=n(11),r=n(10),u=n(7)}}]);