(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{63:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return u});var a=n(0),r=n.n(a),o=n(2),l=n(9),i=n(17),s=n(10),c=n(6);function u(){return r.a.createElement(r.a.Fragment,null,r.a.createElement(c.b,null,r.a.createElement("p",null,"Navigation and observation are closely linked. Navigation is used to change locations, while observation is used to detect navigation changes and react (e.g. re-render the application).")),r.a.createElement(s.a,{title:"Navigation",id:"navigation"},r.a.createElement(c.b,null,r.a.createElement("p",null,"When you create a router, you pass it a history object. That history object is responsible for tracking all navigation within your application. Navigation can be triggered a variety of ways."),r.a.createElement("p",null,'The first type is "external" navigation, meaning it comes from outside of the application. For a website, this would be navigating by entering a URL in the address bar or by pressing the browser\'s forward/back buttons.'),r.a.createElement("p",null,'The second type of navigation is "internal", where you use code to navigate to a new location. This is predominantly done by clicking links.'),r.a.createElement("p",null,"This guide is only going to discuss how to perform internal navigation, since that is the only type that you need to perform with code.")),r.a.createElement(c.a,null,'import Browser from "@hickory/browser";\nimport { curi } from "@curi/router";\n\nimport routes from "./routes";\n\n// this history object is responsible for\n// tracking navigation\nconst history = Browser();\n\nconst router = curi(history, routes);'),r.a.createElement(s.b,{title:"Navigation With History",id:"with-history"},r.a.createElement(c.b,null,r.a.createElement("p",null,"Locations are stored in what is essentially an array (this varies by history type). An index is used to keep track of which location in the array is the current location."),r.a.createElement(i.a,null,"With the browser and hash histories, you cannot actually access the array of locations/index. Browsers do not expose this because accessing this data could cause security issues.")),r.a.createElement(c.a,null,'// array of locations\n[\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/three" }\n]\n// index = 2, current location = { pathname: "/three" }'),r.a.createElement(c.b,null,r.a.createElement("p",null,"There are three ways to change locations: popping, pushing, and replacing and two methods for making these changes:"," ",r.a.createElement(l.b,null,"history.go()")," and ",r.a.createElement(l.b,null,"history.navigate()"),".")),r.a.createElement(s.b,{tag:"h4",title:"Pop",id:"navigation-pop"},r.a.createElement(c.b,null,r.a.createElement("p",null,"Popping means that you change the index to another (valid) index in the array. Popping is performed by specifying how many locations forward (positive numbers) or backward (negative numbers) you want to go. When you click a browser's back button, that is essentially popping by negative one."),r.a.createElement("p",null,"The history object's ",r.a.createElement(l.b,null,"go()")," function is used for popping between locations.")),r.a.createElement(c.a,{"data-line":"9,16"},'locations = [\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/three" }\n]\nindex = 2\n// current location = { pathname: "/three" }\n\nhistory.go(-2)\n\nlocations = [\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/three" }\n]\nindex = 0\n// current location = { pathname: "/one" }')),r.a.createElement(s.b,{tag:"h4",title:"Push",id:"navigation-push"},r.a.createElement(c.b,null,r.a.createElement("p",null,"Pushing adds a new location after the current location in the array. Pushing is destructive because if there were any locations after the current location, they are lost when you push a new location."),r.a.createElement("p",null,"The history object's ",r.a.createElement(l.b,null,"navigate()")," method is used for pushing new locations. In order to ensure that a location is pushed, the ",r.a.createElement(l.b,null,'"PUSH"')," argument should be passed to the method call.")),r.a.createElement(c.a,{"data-line":"9,13,15"},'locations = [\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/three" }\n]\nindex = 0\n// current location = { pathname: "/one" }\n\nhistory.navigate("/four", "PUSH")\n\nlocations = [\n  { pathname: "/one" },\n  { pathname: "/four" }\n]\nindex = 1\n// current location = { pathname: "/four" }')),r.a.createElement(s.b,{tag:"h4",title:"Replace",id:"navigation-replace"},r.a.createElement(c.b,null,r.a.createElement("p",null,"Replacing replaces the location at the current index with a new location. When you replace the current location, it has no effect on locations after the current one."),r.a.createElement("p",null,"The history object's ",r.a.createElement(l.b,null,"navigate()")," method is used for replacing locations. In order to ensure that a location is replaced, the ",r.a.createElement(l.b,null,'"REPLACE"')," argument should be passed to the method call.")),r.a.createElement(c.a,{"data-line":"9,14"},'locations = [\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/three" }\n]\nindex = 2\n// current location = { pathname: "/three" }\n\nhistory.navigate("/four", "REPLACE")\n\nlocations = [\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/four" }\n]\nindex = 2\n// current location = { pathname: "/four" }')),r.a.createElement(s.b,{tag:"h4",title:"Anchor",id:"navigation-anchor"},r.a.createElement(c.b,null,r.a.createElement("p",null,"The ",r.a.createElement(l.b,null,"history.navigate()")," method has one other way of navigating, which is also its default method. This method is called ",r.a.createElement(l.b,null,'"ANCHOR"')," because it simulates how clicking an anchor in a non-single-page application works."),r.a.createElement("p",null,"Anchor navigation is a hybrid of pushing and replacing. If you attempt to navigate to the same location as the current location (same ",r.a.createElement(l.b,null,"pathname"),", ",r.a.createElement(l.b,null,"query"),", and ",r.a.createElement(l.b,null,"hash"),"), then the current location will be replaced. If you attempt to navigate to a new location, it will be pushed."),r.a.createElement("p",null,"Unless you have a reason to explicitly push/replace, anchor navigation is what you should use for navigation.")),r.a.createElement(c.a,{"data-line":"8,18,25,27"},'locations = [\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/three" }\n]\nindex = 2\n\nhistory.navigate("/three")\n\n// same location, so nothing changes\nlocations = [\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/three" }\n]\nindex = 2\n\nhistory.navigate("/four")\n\n// new location is pushed\nlocations = [\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/three" },\n  { pathname: "/four" }\n]\nindex = 3'))),r.a.createElement(s.b,{title:"Navigation with the Router",id:"with-router"},r.a.createElement(c.b,null,r.a.createElement("p",null,"In the above examples, navigation is done using URL pathnames, but one of the principles of Curi is that you shouldn't have to write URLs yourself. To help with this, the router has its own"," ",r.a.createElement(l.b,null,"navigate()")," method."),r.a.createElement("p",null,r.a.createElement(l.b,null,"router.navigate()")," takes an object with the"," ",r.a.createElement(l.b,null,"name")," of the route to navigate to. If the route (or any of its ancestors) requires ",r.a.createElement(l.b,null,"params"),", they should also be provided through the object."),r.a.createElement("p",null,r.a.createElement(l.b,null,"query"),", ",r.a.createElement(l.b,null,"hash"),", and ",r.a.createElement(l.b,null,"state")," properties can also be provided to pass any of those location details."),r.a.createElement("p",null,r.a.createElement(l.b,null,"router.navigate()")," does anchor style (",r.a.createElement(l.b,null,'"ANCHOR"'),") navigation by default, but if you want to do"," ",r.a.createElement(l.b,null,'"PUSH"'),"/",r.a.createElement(l.b,null,'"REPLACE"')," navigation, you can provide the type with the ",r.a.createElement(l.b,null,"method")," property.")),r.a.createElement(c.a,null,'router.navigate({\n  name: "User",\n  params: { id: 1423 }\n});\n\n// replace the current location with the Login route\nrouter.navigte({\n  name: "Login",\n  state: { next: "/profile" }\n  method: "REPLACE"\n});'))),r.a.createElement(s.a,{title:"Detecting Navigation",id:"detecting-navigation"},r.a.createElement(c.b,null,r.a.createElement("p",null,"The Curi router uses an observer pattern to call registered functions (called response handlers) when there is a new response. The main function for response handlers is to use the new response to render the application, but any other functionality (like logging) can also be performed.")),r.a.createElement(s.b,{title:"Response Handlers",id:"response-handlers"},r.a.createElement(c.b,null,r.a.createElement("p",null,"When response handlers are called, they are passed an object with three properties:"," ",r.a.createElement(o.c,{to:"Package",params:{package:"router"},hash:"properties"},r.a.createElement(l.b,null,"router")),","," ",r.a.createElement(o.c,{to:"Guide",params:{slug:"routes-and-responses"},hash:"responses"},r.a.createElement(l.b,null,"response")),", and"," ",r.a.createElement(o.c,{to:"Guide",params:{slug:"navigation-objects"}},r.a.createElement(l.b,null,"navigation")),". Which objects/properties you use depends on what the response handler is doing.")),r.a.createElement(c.a,null,"function responseHandler({\n  router,\n  response,\n  navigation\n}) {\n  // ...\n}")),r.a.createElement(s.b,{title:"Registering Response Handlers",id:"registering"},r.a.createElement(c.b,null,r.a.createElement("p",null,"There are two ways to attach response handlers to the router:"," ",r.a.createElement(l.b,null,"router.once()")," and ",r.a.createElement(l.b,null,"router.observe()"),". Response handlers registered with ",r.a.createElement(l.b,null,"router.once()")," will only be called one time, while those registered with"," ",r.a.createElement(l.b,null,"router.observe()")," will be called for every new response."),r.a.createElement("p",null,"When you register a response handler using"," ",r.a.createElement(l.b,null,"router.observer()"),", it will return a function that you can use to stop calling the response handler for new responses. You should rarely need to do this, but it can be useful for memory management if you are adding and removing lots of observers.")),r.a.createElement(c.a,null,"// fn will only be called one time\nrouter.once(fn);\n\n// obs will be called for every new response\nconst stop = router.observer(fn);")),r.a.createElement(s.b,{title:"Use Cases",id:"use-cases"},r.a.createElement("p",null,"What should you use response handlers for?"),r.a.createElement(s.b,{title:"Setup",id:"setup"},r.a.createElement(c.b,null,r.a.createElement("p",null,"If any of the routes in an application have ",r.a.createElement(l.b,null,"resolve")," ","functions, when they match their responses are created asynchronously. When the application first renders, if the router matches an async route, the response isn't immediately ready to use. To deal with this, you can use an observer to render once the initial response is ready."),r.a.createElement("p",null,"A setup function only needs to be called one time, so you can register it with ",r.a.createElement(l.b,null,"router.once()"),"."),r.a.createElement(i.a,null,"In most applications, waiting for the initial response is the only time you may need to write response handlers yourself.")),r.a.createElement(c.a,{lang:"jsx"},"const Router = curiProvider(router);\n              \nfunction setup() {\n  ReactDOM.render((\n    <Router>\n      {({ response }) => <response.body />}\n    </Router>\n  ), document.getElementById('root'));\n}\n\nrouter.once(setup);")),r.a.createElement(s.b,{title:"Rendering",id:"rendering"},r.a.createElement(c.b,null,r.a.createElement("p",null,"Rendering libraries need to know when there is a new response so that they can re-render the application."),r.a.createElement("p",null,"The Curi rendering packages (",r.a.createElement(o.c,{to:"Package",params:{package:"react-dom"}},r.a.createElement(l.b,null,"@curi/react-dom")),","," ",r.a.createElement(o.c,{to:"Package",params:{package:"react-native"}},r.a.createElement(l.b,null,"@curi/react-native")),","," ",r.a.createElement(o.c,{to:"Package",params:{package:"vue"}},r.a.createElement(l.b,null,"@curi/vue")),", and"," ",r.a.createElement(o.c,{to:"Package",params:{package:"svelte"}},r.a.createElement(l.b,null,"@curi/svelte")),") setup an observer internally so that they can automatically re-render."),r.a.createElement("p",null,"If you are using vanilla JavaScript to render your application or you are writing your own framework implementation, you would use ",r.a.createElement(l.b,null,"router.observer()")," to re-render new responses.")),r.a.createElement(c.a,null,"function observer({ response }) {\n  // let the app know there is a new response\n}\n\nrouter.observer(observer);")),r.a.createElement(s.b,{title:"Side Effects",id:"side-effects"},r.a.createElement(c.b,null,r.a.createElement("p",null,"Side effects are observers that are provided to the router at creation instead of by calling ",r.a.createElement(l.b,null,"router.observe()"),". These can be useful for tasks that are not rendering related as well as for tasks that need to be performed after a render has completed."),r.a.createElement("p",null,"The"," ",r.a.createElement(o.c,{to:"Package",params:{package:"side-effect-title"}},r.a.createElement(l.b,null,"@curi/side-effect-title"))," ","package provides a side effect that will use"," ",r.a.createElement(l.b,null,"response.title")," to set the page's"," ",r.a.createElement(l.b,null,"document.title"),"."),r.a.createElement("p",null,"With single-page applications, clicking on links wish hashes won't always scroll to the matching element in the page. The"," ",r.a.createElement(o.c,{to:"Package",params:{package:"side-effect-scroll"}},r.a.createElement(l.b,null,"@curi/side-effect-scroll"))," ","package adds this behavior by scrolling the page to the element that matches the new response's hash (",r.a.createElement(l.b,null,"response.location.hash"),") after the new response has rendered."),r.a.createElement("p",null,"If you need to add logging to your application, you could write your own observer to do this. Your observer can either be added as a side effect when the router is constructed or later using"," ",r.a.createElement(l.b,null,"router.observe()"),".")),r.a.createElement(c.a,null,"function logger({ response }) {\n  loggingAPI.add(response.location);\n}\n\n// as a side-effect\nconst router = curi(history, routes, {\n  sideEffects: [{ fn: logger }]\n});\n\n// as an observer\nrouter.observe(logger);")))))}}}]);