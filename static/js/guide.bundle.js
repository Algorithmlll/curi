(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{108:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=c(n(0)),a=n(1),r=c(n(60)),o=n(2),u=n(57),i=(n(10),n(4));function c(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Curi can have synchronous and asynchronous routes."),l.default.createElement("p",null,"When a navigation event is triggered (e.g. clicking a link or button), the router will match a route. If the route is synchronous, the response will be emitted immediately. If the route is asynchronous, the response will not be emitted until the route's async functions have finished. This is useful for code splitting and preloading data for a route."),l.default.createElement("p",null,"By default, routes are synchronous. If a route has an"," ",l.default.createElement(o.InlineJS,null,"on.initial")," or ",l.default.createElement(o.InlineJS,null,"on.every()")," function, it becomes async.")),l.default.createElement(i.CodeBlock,null,'// sync\n{ name: "Home", path: "" },\n\n// async\n{\n  name: "User",\n  path: "user/:id,\n  on: {\n    // either of these makes the route async\n    initial: () => import("./components/User"),\n    every: ({ params }) => fetch(`/api/user/${params.id}`)\n  }\n}')),l.default.createElement(u.Section,{title:"Async Things to Think About",id:"think"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"For the most part, it shouldn't matter to you (or your users) whether Curi is sync or async, but there are a couple of things that you should be aware of when it comes to async matching."))),l.default.createElement("ol",null,l.default.createElement("li",null,l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"If the initial route that matches is async and you try to render immediately, the ",l.default.createElement(o.InlineJS,null,"response")," will be ",l.default.createElement(o.InlineJS,null,"null"),". You can wait to render until the initial response is ready with"," ",l.default.createElement(o.InlineJS,null,"router.respond()"),". The function you pass to that will be called one time, once the initial response is ready.")),l.default.createElement(i.CodeBlock,null,"const router = curi(history, routes);\nrouter.respond(() => {\n  // the initial response is ready,\n  // so it is safe to render\n  ReactDOM.render(...);\n});"))),l.default.createElement("li",null,l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"With async routes, there is a delay between when the user clicks a link and when the new response is emitted. During this time, the navigation can be interrupted with a new navigation. Curi handles this internally, but you might want to update your UI after a link/button is clicked to indicate that the next page is loading."),l.default.createElement("p",null,"You can see an example of this in the"," ",l.default.createElement(a.Link,{to:"Example",params:{category:"react",slug:"data-loading"}},"Data Loading Example"),".")),l.default.createElement(i.CodeBlock,{lang:"jsx"},'<Link\n  to="User"\n  params={{ id: 1 }}\n  onClick={() => {\n    // display a loading bar when\n    // the user clicks a link.\n    nprogress.start();\n  }}\n>User 1</Link>\n\n// use a side effect to finish\n// loading bar when the new response\n// is ready\nconst finishLoading = () => {\n  nprogress.done();\n};\n\nconst router = curi(history, routes, {\n  sideEffects: [{ effect: finishLoading }]\n});'))))),l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Get to know about route objects with the"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"routes"}},"All About Routes")," ","guide."))}},109:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=d(n(0)),a=n(1),r=d(n(60)),o=n(2),u=n(10),i=n(57),c=n(4);function d(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"React Router v4 isn't like most other routers because it lacks a centralized configuration. Migrating to Curi mostly involves re-centralizing your routes to simplify route management."))),l.default.createElement(i.Section,{title:"Routes",id:"routes"},l.default.createElement("p",null,"Letâ€™s get started with setting up our routes."),l.default.createElement(i.Subsection,{title:"With React Router",id:"routes-with-react-router"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"With React Router v4, ",l.default.createElement(o.InlineComponent,null,"Route"),"s are defined in components. They are usually grouped together under a ",l.default.createElement(o.InlineComponent,null,"Switch")," so that only a single route from a group renders. Nested routes are rendered inside of the compnent rendered by the parent"," ",l.default.createElement(o.InlineComponent,null,"Route"))),l.default.createElement(c.CodeBlock,{lang:"jsx"},'import { Route, Switch } from "react-router-dom";\n            \nconst App = () => (\n  <Switch>\n    <Route exact path="/" component={Home} />\n    <Route path="/inbox" component={Inbox} />\n  </Switch>                 \n);\n\n// the <Inbox> matches nested routes (and includes\n// a <Route> for "exact" /inbox matches)\nconst Inbox = ({ match }) => (\n  <Switch>\n    <Route\n      exact\n      path={match.path}\n      component={Messages}\n    />\n    <Route\n      exact\n      path={`${match.path}/:message`}\n      component={Message}\n    />\n  </Switch>\n);'))),l.default.createElement(i.Subsection,{title:"With Curi",id:"routes-with-curi"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,'Routes in Curi are JavaScript objects. They are grouped together in an array of "top-level" routes. Nested routes are grouped under their parent route\'s ',l.default.createElement(o.InlineJS,null,"children")," property."),l.default.createElement("p",null,"First, we will define the names and paths for our routes."),l.default.createElement("p",null,"Each route must have a unique name. A route's name will be used for interacting with it. For example, to navigate to a route, you only have to know its name, not its URL."),l.default.createElement("p",null,"The biggest difference between the Curi paths and the React Router paths is that with Curi, you never include a forward slash at the beginning of the path. This means that while the root path for React Router is ",l.default.createElement(o.InlineJS,null,"'/'"),", the root path for Curi is"," ",l.default.createElement(o.InlineJS,null,"''"),".")),l.default.createElement(c.CodeBlock,null,"const routes = [\n  {\n    name: 'Home',\n    path: ''\n  },\n  {\n    name: 'Inbox',\n    path: 'inbox',\n    children: [\n      {\n        name: 'Message',\n        path: ':message'\n      }\n    ]\n  }\n];")),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Next, we should add our components to each route."),l.default.createElement("p",null,"Curi routes can have a ",l.default.createElement(o.InlineJS,null,"response()")," property, which is a function that returns an object of properties to merge onto the response that we will be using to render. For this React application, we want a response's ",l.default.createElement(o.InlineJS,null,"body")," property to be the React component associated with each route.")),l.default.createElement(c.CodeBlock,null,"import Home from './pages/Home';\nimport Inbox from './pages/Inbox';\nimport Mesage from './pages/Message';\n\nconst routes = [\n  {\n    name: 'Home',\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    name: 'Inbox',\n    path: 'inbox',\n    response: () => {\n      return {\n        body: Inbox\n      };\n    },\n    children: [\n      {\n        name: 'Message',\n        path: ':message',\n        response: () => {\n          return {\n            body: Message\n          };\n        }\n      }\n    ]\n  }\n];")),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"With React Router v4, a component's lifecycle methods are used for loading data, code splitting, and other non-rendering tasks. WIth Curi, the same thing can be done ",l.default.createElement("em",null,"or")," you can use a route's"," ",l.default.createElement(o.InlineJS,null,"on")," methods to perform these tasks ",l.default.createElement("em",null,"before")," the response is emitted."),l.default.createElement("p",null,"These methods are ",l.default.createElement(o.InlineJS,null,"on.initial()")," and"," ",l.default.createElement(o.InlineJS,null,"on.every()"),". ",l.default.createElement(o.InlineJS,null,"on.initial()")," is useful for tasks that only need to be run once per route, like the code splitting mentioned above. ",l.default.createElement(o.InlineJS,null,"on.every()")," will be called every time that a route matches, so it is ideal for data loading."),l.default.createElement("p",null,"The"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"routes"},hash:"match"},"routes guide")," ","covers the details of these methods as well as all of the other route properties.")),l.default.createElement(c.CodeBlock,null,"const routes = [\n  {\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    path: 'inbox',\n    response: () => {\n      return {\n        body: Inbox\n      };\n    },\n    children: [\n      {\n        path: ':message',\n        response: () => {\n          return {\n            body: Message\n          };\n        },\n        on: {\n          every: (route) => { return ... },\n        }\n      }\n    ]\n  }\n];"))),l.default.createElement("p",null,"Once your routes have been defined, you can move on to creating your Curi router.")),l.default.createElement(i.Section,{title:"Creating the router",id:"creating-the-router"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"With React Router, you create your router by rendering a"," ",l.default.createElement(o.InlineComponent,null,"Router")," component. This may be a ",l.default.createElement(o.InlineComponent,null,"BrowserRouter"),", a ",l.default.createElement(o.InlineComponent,null,"HashRouter"),", a ",l.default.createElement(o.InlineComponent,null,"MemoryRouter"),", or a plain"," ",l.default.createElement(o.InlineComponent,null,"Router")," that you pass your own ",l.default.createElement(o.InlineJS,null,"history")," instance to. The ",l.default.createElement(o.InlineComponent,null,"___Router")," components create a ",l.default.createElement(o.InlineJS,null,"history")," ","instance for you using props passed to the component.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"import { BrowserRouter } from 'react-router-dom';\n\nReactDOM.render((\n  <BrowserRouter>\n    <App />\n  </BrowserRouter>\n), holder);")),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"With Curi, the router is created prior to rendering. It takes a Hickory history object, your routes array, and possibly an options object.Â ",l.default.createElement("a",{href:"https://github.com/pshrmn/hickory"},"Hickory")," is similar to the ",l.default.createElement(o.InlineJS,null,"history")," package used by React Router, but has a slight modified API (easier navigation blocking and navigation that imitates how anchors work) and more convenient location objects (you can use a ",l.default.createElement(o.InlineJS,null,"query")," object instead of having to manually create a ",l.default.createElement(o.InlineJS,null,"search")," string).")),l.default.createElement(c.CodeBlock,null,"import curi from '@curi/core';\nimport Browser from '@hickory/browser';\nconst history = Browser();\nconst routes = [...];\nconst router = curi(history, routes);"))),l.default.createElement(i.Section,{title:"Rendering",id:"rendering"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"We will walk through the rendering differences between React Router and Curi by looking at what happens in each when we navigate to the URL with the pathname ",l.default.createElement(o.InlineJS,null,"/inbox/test-message-please-ignore"),"."))),l.default.createElement(i.Subsection,{title:"React Router",id:"rendering-react-router"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"React Router matches routes while it renders. It uses the"," ",l.default.createElement(o.InlineComponent,null,"Router")," component to listen for location changes. Each time that the location changes, the application re-renders."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineComponent,null,"Switch")," will iterate over its children"," ",l.default.createElement(o.InlineComponent,null,"Route"),"s. The first route, ",l.default.createElement(o.InlineJS,null,'"/"')," has an"," ",l.default.createElement(o.InlineJS,null,"exact")," prop, so it only matches when the pathname is"," ",l.default.createElement(o.InlineJS,null,'"/"'),". Since it is not, the next ",l.default.createElement(o.InlineComponent,null,"Route")," will be checked. The next route, ",l.default.createElement(o.InlineJS,null,'"/inbox"')," matches the beginning of the pathname ",l.default.createElement(o.InlineJS,null,'"/inbox/test-message-please-ignore"'),". It is not an exact match, but that route does not do exact matching, so React Router will render its component, ",l.default.createElement(o.InlineComponent,null,"Inbox"),"."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineComponent,null,"Inbox")," has its own ",l.default.createElement(o.InlineComponent,null,"Switch")," to iterate over. Its first route only matches ",l.default.createElement(o.InlineJS,null,'"/inbox"')," exactly, so it moves on to the next route, which has a ",l.default.createElement(o.InlineJS,null,"message")," ","route param. This route matches and stores"," ",l.default.createElement(o.InlineJS,null,'"test-message-please-ignore"')," as"," ",l.default.createElement(o.InlineJS,null,"match.params.message"),". The ",l.default.createElement(o.InlineComponent,null,"Message")," component will then be rendered, which has acccess to the ",l.default.createElement(o.InlineJS,null,"message")," ","param.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},'ReactDOM.render((\n  <BrowserRouter>\n    <App />\n  </BrowserRouter>\n), holder);\n\nconst App = () => (\n  <Switch>\n    <Route exact path="/" component={Home} />\n    <Route path="/inbox" component={Inbox} />\n  </Switch>                 \n);\n\nconst Inbox = ({ match }) => (\n  <Switch>\n    <Route\n      exact\n      path={match.path}\n      component={Messages}\n    />\n    <Route\n      exact\n      path={`${match.path}/:message`}\n      component={Message}\n    />\n  </Switch>\n);\n\n/*\n<BrowserRouter>\n  <App>\n    <Inbox>\n      <Message>\n    </Inbox>\n  </App>\n</BrowserRouter>\n*/'))),l.default.createElement(i.Subsection,{title:"Curi",id:"rendering-with-curi"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"With Curi, we also need to re-render our application every time that the location changes. We will do this using the"," ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," component, which comes from the"," ",l.default.createElement(o.InlineJS,null,"@curi/react")," package."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," takes a ",l.default.createElement(o.InlineJS,null,"router")," prop, which it will use know when a new responses are emitted."," ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," also expects a function as its"," ",l.default.createElement(o.InlineJS,null,"children")," prop (a render-invoked prop). This function renders the application using the ",l.default.createElement(o.InlineJS,null,"response"),"."),l.default.createElement("p",null,"When the ",l.default.createElement(o.InlineComponent,null,"CuriProvider"),"'s ",l.default.createElement(o.InlineJS,null,"children()")," function is called, it will receive an object with three properties:"),l.default.createElement("ol",null,l.default.createElement("li",null,l.default.createElement(o.InlineJS,null,"response")," is the new response object"),l.default.createElement("li",null,l.default.createElement(o.InlineJS,null,"navigation")," is an object with additional information about the navigation"),l.default.createElement("li",null,l.default.createElement(o.InlineJS,null,"router")," is your Curi router (mostly useful if the function is defined in a separate file)")),l.default.createElement("p",null,"Above, we added ",l.default.createElement(o.InlineJS,null,"response()")," functions to each route. The functions set React components as the ",l.default.createElement(o.InlineJS,null,"body")," property of responses. We can now use ",l.default.createElement(o.InlineJS,null,"response.body")," to render those components."),l.default.createElement("p",null,"In the React Router section, we had three components that were rendered: ",l.default.createElement(o.InlineComponent,null,"App"),",",l.default.createElement(o.InlineComponent,null,"Inbox"),", and ",l.default.createElement(o.InlineComponent,null,"Message"),". With Curi, only the most accurately matched route actually matches. That means that for the URL ",l.default.createElement(o.InlineJS,null,"/inbox/test-message-please-ignore"),", the"," ",l.default.createElement(o.InlineJS,null,'"Message"')," route will match, but its parent route,"," ",l.default.createElement(o.InlineJS,null,'"Inbox"')," will not, so ",l.default.createElement(o.InlineJS,null,"response.body")," will be the ",l.default.createElement(o.InlineComponent,null,"Message")," component. Unlike React Router, we donâ€™t render ",l.default.createElement(o.InlineComponent,null,"Inbox")," because we did not match the"," ",l.default.createElement(o.InlineJS,null,"inbox")," route.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"ReactDOM.render((\n  <CuriProvider router={router}>\n    {({ response }) => {\n      const { body:Body } = response;\n      return <Body />;\n    }}\n  </CuriProvider>\n), holder);\n\n/*\n  <CuriProvider>\n    <Message />\n  </CuriProvider>\n*/")),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement(u.Note,null,"Wildcard routes (",l.default.createElement(o.InlineJS,null,"{ path: '(.*)' }"),") can be used to easily display a not found page for any location not matched by other routes.")),l.default.createElement(c.CodeBlock,null,'const routes = [\n  // ...,\n  {\n    name: "Not Found",\n    path: "(.*)",\n    response() {\n      return { body: NotFound };\n    }\n  }\n];')),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"It was mentioned above that there is no need for the"," ",l.default.createElement(o.InlineComponent,null,"App")," component with Curi. If you want to have an"," ",l.default.createElement(o.InlineComponent,null,"App")," component, you can render it either inside of the"," ",l.default.createElement(o.InlineJS,null,"render")," function or as a parent of your"," ",l.default.createElement(o.InlineComponent,null,"CuriProvider"),". This can be useful for rendering content that is unrelated to specific routes, like a page header or menu."),l.default.createElement("p",null,"Rendering the ",l.default.createElement(o.InlineComponent,null,"App")," inside of the ",l.default.createElement(o.InlineJS,null,"children")," ","function is necessary if any of the components rendered by the"," ",l.default.createElement(o.InlineComponent,null,"App")," are location aware components, since they need to access the Curi router (through Reactâ€™s context, which the"," ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," provides)")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"function render({ response }) {\n  const { body:Body } = response;\n  return (\n    <App>\n      <Body />\n    </App>\n  );\n}\n// or\nfunction render({ response }) {\n  const { body:Body } = response;\n  return (\n    <div>\n      <Header />\n      <Body />\n      <Footer />\n    </div>\n  );\n}")),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"What about props that you want to send to your route components? Pass them to the ",l.default.createElement(o.InlineComponent,null,"Body")," component that you render. Props can be passed individually, but passing the whole"," ",l.default.createElement(o.InlineJS,null,"response")," object is recommended.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"function render({ response }) {\n  const { body:Body } = response;\n  return <Body response={response} />;\n}")))),l.default.createElement(i.Section,{title:"Links",id:"links"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"You will want to be able to navigate between routes in your application. React Router provides a ",l.default.createElement(o.InlineComponent,null,"Link")," component to do this, and so does Curi (through the ",l.default.createElement(o.InlineJS,null,"@curi/react")," package). There are a few differences to note between these two components:"))),l.default.createElement("ul",null,l.default.createElement("li",null,l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"React Router expects you to generate the pathname yourself, while Curi expects you to pass the name of the route that you want to navigate to. Any path parameters are passed to Curiâ€™s"," ",l.default.createElement(o.InlineComponent,null,"Link")," using the ",l.default.createElement(o.InlineJS,null,"params")," prop.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"// React Router\n<Link to='/'>Home</Link>\n<Link to={`/inbox/${message}`}>Hello</Link>\n\n// Curi\n<Link to='Home'>Home</Link>\n<Link to='Message' params={{ message }}>Hello</Link>"))),l.default.createElement("li",null,l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"With React Router, any additional location properties are passed to the ",l.default.createElement(o.InlineComponent,null,"Link")," using the ",l.default.createElement(o.InlineJS,null,"to")," object. With Curi, these properties are passed using the prop name (",l.default.createElement(o.InlineJS,null,"hash"),", ",l.default.createElement(o.InlineJS,null,"query")," &",l.default.createElement(o.InlineJS,null,"state"),").")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"// React Router\n<Link to={{ pathname: '/inbox', hash: '#test' }}>\n  Inbox\n</Link>\n\n// Curi\n<Link to='Inbox' hash='test'>Inbox</Link>"))),l.default.createElement("li",null,l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Active detection with Curi uses an ",l.default.createElement(o.InlineComponent,null,"Active")," component."," ",l.default.createElement(o.InlineComponent,null,"Active"),"'s ",l.default.createElement(o.InlineJS,null,"children")," prop is a render-invoked function that receives a boolean ",l.default.createElement(o.InlineJS,null,"true")," when the named route is active and ",l.default.createElement(o.InlineJS,null,"false")," when it is not. You can also pass ",l.default.createElement(o.InlineJS,null,"partial={true}")," to allow for partial matches to be considered active (the opposite of React Router's"," ",l.default.createElement(o.InlineJS,null,"onlyActiveOnIndex"),").")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"// React Router\n<Link\n  to='/'\n  onlyActiveOnIndex\n  activeClassName='active'\n>\n  Home\n</Link>\n\n// Curi\n// You need to add @curi/route-active\n// to your router object\nimport active from '@curi/route-active';\nconst router = curi(history, routes, {\n  route: [active()]\n});\n\n// The <Active> component determines if a route is active\n// and passes true/false to the render-invoked children\n// prop\n<Active name=\"Home\">\n  {active => (\n    <Link\n      to='Home'\n      className={active ? \"active\" : \"\"}\n    >Home</Link>\n  )}\n</Active>"))))),l.default.createElement(i.Section,{title:"Accessing router props from nested components",id:"router-props"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"React Router provides a ",l.default.createElement(o.InlineJS,null,"withRouter")," higher-order component that will inject router props into the wrapped component."),l.default.createElement("p",null,"Curi provides similar functionality with the ",l.default.createElement(o.InlineJS,null,"Curious")," ","component."),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"Curious")," has a render-invoked ",l.default.createElement(o.InlineJS,null,"children")," prop, which you can use to inject the Curi ",l.default.createElement(o.InlineJS,null,"router"),", the current"," ",l.default.createElement(o.InlineJS,null,"response"),", and the current ",l.default.createElement(o.InlineJS,null,"navigation")," object into components.")),l.default.createElement(c.CodeBlock,null,"// React Router\nexport default withRouter(SomeComponent);\n\n// Curi\nexport default () => (\n  <Curious>\n    {({ response }) => (\n      <SomeComponent response={response} />\n    )}\n  </Curious>\n);"))),l.default.createElement("p",null,"At this point, hopefully you are comfortable with migrating from React Router v2/3 to Curi. If there are any concepts not covered here that you think should be, please feel free to open up an issue"," ",l.default.createElement("a",{href:"https://github.com/pshrmn/curi/issues"},"on GitHub"),"."))}},110:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=d(n(0)),a=n(1),r=d(n(60)),o=n(2),u=n(10),i=n(57),c=n(4);function d(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Curi is mostly conceptually similar to React Router versions 2 and 3."),l.default.createElement("ol",null,l.default.createElement("li",null,"Both use a centralized router."),l.default.createElement("li",null,"Both routers are made up of route objects (although with React Router some of these are disguised as JSX with ",l.default.createElement(o.InlineComponent,null,"Route")," ","components)."),l.default.createElement("li",null,"With both, routes can be nested, allowing child routes to build off of the paths from their parent routes.")),l.default.createElement("p",null,"Migration from React Router v2/3 to Curi should not require a complete reworking of your application, but there are some key differences."),l.default.createElement("ol",null,l.default.createElement("li",null,"Curi's routing is handled entirely outside of React; there are no"," ",l.default.createElement(o.InlineComponent,null,"Route")," components."),l.default.createElement("li",null,"With Curi, when a nested route matches, only that route renders. Any ancestor routes that also (partially) match are not rendered. This is different from React Router, where ancestors of the best matched route also render.")))),l.default.createElement(i.Section,{title:"Routes",id:"routes"},l.default.createElement("p",null,"Letâ€™s get started with setting up our routes."),l.default.createElement(i.Subsection,{title:"With React Router",id:"routes-with-react-router"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"In React Router v2/3, there are two ways to define routes. You can either use JavaScript objects or JSX ",l.default.createElement(o.InlineComponent,null,"Route"),"s (which React Router converts to JavaScript objects)."),l.default.createElement("p",null,"Both styles described above define the same route structure for three routes: ",l.default.createElement(o.InlineJS,null,"/"),", ",l.default.createElement(o.InlineJS,null,"/inbox"),", and"," ",l.default.createElement(o.InlineJS,null,"/inbox/:message"),". Each one of these has a component that will be rendered when it matches. The ",l.default.createElement(o.InlineJS,null,"/inbox/:message")," ","route has some methods defined to describe its behavior when the route enters, updates, and leaves.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"// JavaScript objects\n{\n  path: '/',\n  component: App,\n  indexRoute: Home,\n  childRoutes: [\n    {\n      path: 'inbox',\n      component: Inbox,\n      childRoutes: [\n        {\n          path: ':message',\n          component: Message,\n          onEnter: (next) => {...},\n          onChange: (prev, next) => {...},\n          onLeave: (prev) => {...}\n        }\n      ]\n    }\n  ]\n// JSX\n<Route path='/' component={App}>\n  <IndexRoute component={Home} />\n  <Route path='inbox' component={Inbox}>\n    <Route\n      path=':message'\n      component={Message}\n      onEnter={next => {...}}\n      onChange={(prev, next) => {...}}\n      onLeave={prev => {...}}\n    />\n  </Route>\n</Route>"))),l.default.createElement(i.Subsection,{title:"With Curi",id:"routes-with-curi"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Routes in Curi are always JavaScript objects. Like React Router, each route object has a path property that describes the path segments that the route matches. React Router v2/3 uses a custom path matcher, but Curi uses ",l.default.createElement(o.InlineJS,null,"path-to-regexp"),". You can read learn how to format paths from the"," ",l.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp"},l.default.createElement(o.InlineJS,null,"path-to-regexp")," repo"),"."),l.default.createElement("p",null,"First, we will define the names and paths for our routes."),l.default.createElement("p",null,"Each route must also have a unique name. A route's name will be used for interacting with it. For example, to navigate to a route, you only have to know its name, not its URL."),l.default.createElement("p",null,"The biggest difference between the Curi paths and the React Router paths is that with Curi, you never include a forward slash at the beginning of the path. This means that while the root path for React Router is ",l.default.createElement(o.InlineJS,null,"'/'"),", the root path for Curi is"," ",l.default.createElement(o.InlineJS,null,"''"),".")),l.default.createElement(c.CodeBlock,null,"const routes = [\n  {\n    name: 'Home',\n    path: ''\n  },\n  {\n    name: 'Inbox',\n    path: 'inbox',\n    children: [\n      {\n        name: 'Message',\n        path: ':message'\n      }\n    ]\n  }\n];")),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Next, we should add our components to each route. We will ignore the ",l.default.createElement(o.InlineComponent,null,"App")," component that is used in the React Router routes. That is not route specific and will be rendered by our application (assuming we actually need it)."),l.default.createElement("p",null,'With Curi, the router creates a "response" object when it matches locations. Some of the properties of the response are automatically set based on the location and the matching route. Others can be set by a route. This is done using the'," ",l.default.createElement(o.InlineJS,null,"response()")," property, which is a function that returns an object whose properties will be added to the response. For this React application, we want a response's ",l.default.createElement(o.InlineJS,null,"body")," property to be the React component associated with each route."),l.default.createElement(u.Note,null,"Only known properties will be merged onto the response.")),l.default.createElement(c.CodeBlock,null,"import Home from './pages/Home';\nimport Inbox from './pages/Inbox';\nimport Mesage from './pages/Message';\n\nconst routes = [\n  {\n    name: 'Home',\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    name: 'Inbox',\n    path: 'inbox',\n    response: () => {\n      return {\n        body: Inbox\n      };\n    },\n    children: [\n      {\n        name: 'Message',\n        path: ':message',\n        response: () => {\n          return {\n            body: Message\n          };\n        }\n      }\n    ]\n  }\n];")),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"We are close to replicating our React Router routes, but we still need to implement the ",l.default.createElement(o.InlineJS,null,"on___")," methods for ourÂ ",l.default.createElement(o.InlineJS,null,":message")," ","route. With Curi, routes can have functions that are called when they match the new loaction. These are ",l.default.createElement(o.InlineJS,null,"on.initial()")," and"," ",l.default.createElement(o.InlineJS,null,"on.every()"),". ",l.default.createElement(o.InlineJS,null,"on.initial()")," is useful for tasks that only need to be run once per route, like the code splitting mentioned above. ",l.default.createElement(o.InlineJS,null,"on.every()")," will be called every time that a route matches, so it is ideal for data loading."),l.default.createElement("p",null,"With React Router, ",l.default.createElement(o.InlineJS,null,"onEnter")," is called when the route first matches, while ",l.default.createElement(o.InlineJS,null,"onChange")," is called when the same route matches a new location (e.g. with new path parameters)."," ",l.default.createElement(o.InlineJS,null,"onEnter")," and ",l.default.createElement(o.InlineJS,null,"onChange")," are nearly the same; the big difference between the two is that ",l.default.createElement(o.InlineJS,null,"onChange")," ","will receive the previous props, which could be used to determine which props changed. When converting these to Curi, we will use"," ",l.default.createElement(o.InlineJS,null,"on.every()")," for both."),l.default.createElement("p",null,"There currently is no equivalent to ",l.default.createElement(o.InlineJS,null,"onLeave")," with Curi. This is mostly because I havenâ€™t seen a compelling need for it. It certainly could be implemented, but so far I have not found a reason to use that. If you have something you need this functionality for, please open up an issue in the GitHub repo."),l.default.createElement("p",null,"The"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"routes"},hash:"match"},"routes guide")," ","covers all of the route properties.")),l.default.createElement(c.CodeBlock,null,"const routes = [\n  {\n    name: 'Home',\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    name: 'Inbox',\n    path: 'inbox',\n    response: () => {\n      return {\n        body: Inbox\n      };\n    },\n    children: [\n      {\n        name: 'Message',\n        path: ':message',\n        response: () => {\n          return {\n            body: Message\n          };\n        },\n        on: {\n          every: (route) => { return ... },\n        }\n      }\n    ]\n  }\n];"))),l.default.createElement("p",null,"Once your routes have been defined, you can move on to creating your Curi router.")),l.default.createElement(i.Section,{title:"Creating the router",id:"creating-the-router"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"With React Router, you create your router by rendering a"," ",l.default.createElement(o.InlineComponent,null,"Router"),". That either takes the ",l.default.createElement(o.InlineComponent,null,"Route")," components as props or the route objects through its ",l.default.createElement(o.InlineJS,null,"routes")," prop. The ",l.default.createElement(o.InlineComponent,null,"Router")," also takes a ",l.default.createElement(o.InlineJS,null,"history")," prop, which is either one of the pre-routerured objects (",l.default.createElement(o.InlineJS,null,"browserHistory")," ","or ",l.default.createElement(o.InlineJS,null,"hashHistory"),") or one that you create yourself.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"import { Router, browserHistory } from 'react-router';\nconst routes = [...];\nReactDOM.render((\n  <Router history={browserHistory} routes={routes} />\n), holder);")),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"With Curi, the router is created prior to rendering. It takes a Hickory history object, your routes array, and possibly an options object.Â ",l.default.createElement("a",{href:"https://github.com/pshrmn/hickory"},"Hickory")," is similar to the ",l.default.createElement(o.InlineJS,null,"history")," package used by React Router, but has a slight modified API (easier navigation blocking and navigation that imitates how anchors work) and more convenient location objects (you can use a ",l.default.createElement(o.InlineJS,null,"query")," object instead of having to manually create a ",l.default.createElement(o.InlineJS,null,"search")," string).")),l.default.createElement(c.CodeBlock,null,"import curi from '@curi/core';\nimport Browser from '@hickory/browser';\nconst history = Browser();\nconst routes = [...];\nconst router = curi(history, routes);"))),l.default.createElement(i.Section,{title:"Rendering",id:"rendering"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"We will walk through the rendering differences between React Router and Curi by looking at what happens in each when we navigate to the URI ",l.default.createElement(o.InlineJS,null,"/inbox/test-message-please-ignore"),"."))),l.default.createElement(i.Subsection,{title:"React Router v2/3",id:"rendering-react-router"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"React Router uses the ",l.default.createElement(o.InlineComponent,null,"Router")," component to subscribe to location changes. Each time that the location changes, it walks over its routes and determines which route(s!) match."),l.default.createElement("p",null,"React Router starts by rendering the root component. In the above router, that is the ",l.default.createElement(o.InlineComponent,null,"App"),". Next, our ",l.default.createElement(o.InlineJS,null,"inbox")," ","route also matches, so React Router also renders our"," ",l.default.createElement(o.InlineComponent,null,"Inbox")," component. Finally, the URI"," ",l.default.createElement(o.InlineJS,null,"/inbox/test-message-please-ignore")," also matches ourÂ ",l.default.createElement(o.InlineJS,null,":message")," ","route (which is concatenated with its parents to form the path"," ",l.default.createElement(o.InlineJS,null,"/inbox/:message"),"), so ",l.default.createElement(o.InlineComponent,null,"Message")," is rendered as well. Each child component is rendered by its parent, so we end up with a component tree that looks something like this:"),l.default.createElement("p",null,"With this structure, any routes with children will be rendered when one of the children matches. That means that those routes need to know how to render based on what type of match they have. For example, ",l.default.createElement(o.InlineComponent,null,"Inbox")," needs to know how to render for an exact match (the URI is ",l.default.createElement(o.InlineJS,null,"/inbox"),") and for a partial match (",l.default.createElement(o.InlineJS,null,"/inbox/test-message-please-ignore"),"). Also, if the"," ",l.default.createElement(o.InlineComponent,null,"Inbox")," needs to pass any props to ",l.default.createElement(o.InlineComponent,null,"Message"),", it has to use ",l.default.createElement(o.InlineJS,null,"React.cloneElement"),", which works but is not the cleanest looking code.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"<App>\n  <Inbox>\n    <Message>\n  </Inbox>\n</App>"))),l.default.createElement(i.Subsection,{title:"Curi",id:"rendering-with-curi"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"With Curi, we also need to re-render our application every time that the location changes. We will do this using the"," ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," component, which comes from the"," ",l.default.createElement(o.InlineJS,null,"@curi/react")," package."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," takes a ",l.default.createElement(o.InlineJS,null,"router")," prop, which it will use know when a new responses are emitted."," ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," also expects a function as its"," ",l.default.createElement(o.InlineJS,null,"children")," prop (a render-invoked prop). This function renders the application using the ",l.default.createElement(o.InlineJS,null,"response"),"."),l.default.createElement("p",null,"When the ",l.default.createElement(o.InlineComponent,null,"CuriProvider"),"'s ",l.default.createElement(o.InlineJS,null,"children()")," function is called, it will receive an object with three properties:"),l.default.createElement("ol",null,l.default.createElement("li",null,l.default.createElement(o.InlineJS,null,"response")," is the new response object"),l.default.createElement("li",null,l.default.createElement(o.InlineJS,null,"navigation")," is an object with additional information about the navigation"),l.default.createElement("li",null,l.default.createElement(o.InlineJS,null,"router")," is your Curi router (mostly useful if the function is defined in a separate file)")),l.default.createElement("p",null,"Above, we added ",l.default.createElement(o.InlineJS,null,"response()")," functions to each route. The functions set React components as the ",l.default.createElement(o.InlineJS,null,"body")," property of responses. We can now use ",l.default.createElement(o.InlineJS,null,"response.body")," to render those components."),l.default.createElement("p",null,"In the React Router section, we had three components that were rendered: ",l.default.createElement(o.InlineComponent,null,"App"),",",l.default.createElement(o.InlineComponent,null,"Inbox"),", and ",l.default.createElement(o.InlineComponent,null,"Message"),". With Curi, only the most accurately matched route actually matches. That means that for the URL ",l.default.createElement(o.InlineJS,null,"/inbox/test-message-please-ignore"),", the"," ",l.default.createElement(o.InlineJS,null,'"Message"')," route will match, but its parent route,"," ",l.default.createElement(o.InlineJS,null,'"Inbox"')," will not, so ",l.default.createElement(o.InlineJS,null,"response.body")," will be the ",l.default.createElement(o.InlineComponent,null,"Message")," component. Unlike React Router, we donâ€™t render ",l.default.createElement(o.InlineComponent,null,"Inbox")," because we did not match the"," ",l.default.createElement(o.InlineJS,null,"inbox")," route.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"ReactDOM.render((\n  <CuriProvider router={router}>\n    {({ response }) => {\n      const { body:Body } = response;\n      return <Body />;\n    }}\n  </CuriProvider>\n), holder);\n\n/*\n  <CuriProvider>\n    <Message />\n  </CuriProvider>\n*/")),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement(u.Note,null,"Wildcard routes (",l.default.createElement(o.InlineJS,null,"{ path: '(.*)' }"),") can be used to easily display a not found page for any location not matched by other routes.")),l.default.createElement(c.CodeBlock,null,'const routes = [\n  // ...,\n  {\n    name: "Not Found",\n    path: "(.*)",\n    response() {\n      return { body: NotFound };\n    }\n  }\n];')),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"It was mentioned above that there is no need for the"," ",l.default.createElement(o.InlineComponent,null,"App")," component with Curi. If you want to have an"," ",l.default.createElement(o.InlineComponent,null,"App")," component, you can render it either inside of the"," ",l.default.createElement(o.InlineJS,null,"render")," function or as a parent of your"," ",l.default.createElement(o.InlineComponent,null,"CuriProvider"),". This can be useful for rendering content that is unrelated to specific routes, like a page header or menu."),l.default.createElement("p",null,"Rendering the ",l.default.createElement(o.InlineComponent,null,"App")," inside of the ",l.default.createElement(o.InlineJS,null,"children")," ","function is necessary if any of the components rendered by the"," ",l.default.createElement(o.InlineComponent,null,"App")," are location aware components, since they need to access the Curi router (through Reactâ€™s context, which the"," ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," provides)")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"function render({ response }) {\n  const { body:Body } = response;\n  return (\n    <App>\n      <Body />\n    </App>\n  );\n}\n// or\nfunction render({ response }) {\n  const { body:Body } = response;\n  return (\n    <div>\n      <Header />\n      <Body />\n      <Footer />\n    </div>\n  );\n}")),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"What about props that you want to send to your route components? Pass them to the ",l.default.createElement(o.InlineComponent,null,"Body")," component that you render. Props can be passed individually, but passing the whole"," ",l.default.createElement(o.InlineJS,null,"response")," object is recommended.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"function render({ response }) {\n  const { body:Body } = response;\n  return <Body response={response} />;\n}")))),l.default.createElement(i.Section,{title:"Links",id:"links"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"You will want to be able to navigate between routes in your application. React Router provides a ",l.default.createElement(o.InlineComponent,null,"Link")," component to do this, and so does Curi (through the ",l.default.createElement(o.InlineJS,null,"@curi/react")," package). There are a few differences to note between these two components:"))),l.default.createElement("ul",null,l.default.createElement("li",null,l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"React Router expects you to generate the pathname yourself, while Curi expects you to pass the name of the route that you want to navigate to. Any path parameters are passed to Curiâ€™s"," ",l.default.createElement(o.InlineComponent,null,"Link")," using the ",l.default.createElement(o.InlineJS,null,"params")," prop.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"// React Router\n<Link to='/'>Home</Link>\n<Link to={`/inbox/${message}`}>Hello</Link>\n\n// Curi\n<Link to='Home'>Home</Link>\n<Link to='Message' params={{ message }}>Hello</Link>"))),l.default.createElement("li",null,l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"With React Router, any additional location properties are passed to the ",l.default.createElement(o.InlineComponent,null,"Link")," using the ",l.default.createElement(o.InlineJS,null,"to")," object. With Curi, these properties are passed using the prop name (",l.default.createElement(o.InlineJS,null,"hash"),", ",l.default.createElement(o.InlineJS,null,"query")," &",l.default.createElement(o.InlineJS,null,"state"),").")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"// React Router\n<Link to={{ pathname: '/inbox', hash: '#test' }}>\n  Inbox\n</Link>\n\n// Curi\n<Link to='Inbox' hash='test'>Inbox</Link>"))),l.default.createElement("li",null,l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Active detection with Curi uses an ",l.default.createElement(o.InlineComponent,null,"Active")," component."," ",l.default.createElement(o.InlineComponent,null,"Active"),"'s ",l.default.createElement(o.InlineJS,null,"children")," prop is a render-invoked function that receives a boolean ",l.default.createElement(o.InlineJS,null,"true")," when the named route is active and ",l.default.createElement(o.InlineJS,null,"false")," when it is not. You can also pass ",l.default.createElement(o.InlineJS,null,"partial={true}")," to allow for partial matches to be considered active (the opposite of React Router's"," ",l.default.createElement(o.InlineJS,null,"onlyActiveOnIndex"),").")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"// React Router\n<Link\n  to='/'\n  onlyActiveOnIndex\n  activeClassName='active'\n>\n  Home\n</Link>\n\n// Curi\n// You need to add @curi/route-active\n// to your router object\nimport active from '@curi/route-active';\nconst router = curi(history, routes, {\n  route: [active()]\n});\n\n// The <Active> component determines if a route is active\n// and passes true/false to the render-invoked children\n// prop\n<Active name=\"Home\">\n  {active => (\n    <Link\n      to='Home'\n      className={active ? \"active\" : \"\"}\n    >Home</Link>\n  )}\n</Active>"))))),l.default.createElement(i.Section,{title:"Accessing router props from nested components",id:"router-props"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"React Router provides a ",l.default.createElement(o.InlineJS,null,"withRouter")," higher-order component that will inject router props into the wrapped component."),l.default.createElement("p",null,"Curi provides similar functionality with the ",l.default.createElement(o.InlineJS,null,"Curious")," ","component."),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"Curious")," has a render-invoked ",l.default.createElement(o.InlineJS,null,"children")," prop, which you can use to inject the Curi ",l.default.createElement(o.InlineJS,null,"router"),", the current"," ",l.default.createElement(o.InlineJS,null,"response"),", and the current ",l.default.createElement(o.InlineJS,null,"navigation")," object into components.")),l.default.createElement(c.CodeBlock,null,"// React Router\nexport default withRouter(SomeComponent);\n\n// Curi\nexport default () => (\n  <Curious>\n    {({ response }) => (\n      <SomeComponent response={response} />\n    )}\n  </Curious>\n);"))),l.default.createElement("p",null,"At this point, hopefully you are comfortable with migrating from React Router v2/3 to Curi. If there are any concepts not covered here that you think should be, please feel free to open up an issue"," ",l.default.createElement("a",{href:"https://github.com/pshrmn/curi/issues"},"on GitHub"),"."))}},111:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=d(n(0)),a=n(1),r=d(n(60)),o=n(2),u=n(10),i=n(57),c=n(4);function d(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,l.default.createElement("a",{href:"https://apollographql.com"},"Apollo")," is a great solution for managing an application's data using"," ",l.default.createElement("a",{href:"http://graphql.org"},"GraphQL"),"."),l.default.createElement("p",null,'Using Apollo with Curi doesn\'t require any "special" integration, but there are a few different implementation strategies you may choose based on how tightly you want them to be paired.'),l.default.createElement(u.Note,null,l.default.createElement("p",null,"This guide only covers integration between Curi and Apollo. If you are not already familiar with how to use Apollo, you will want to learn that first."),l.default.createElement("p",null,"Also, this guide will only be referencing Apollo's React implementation, but the principles are the same no matter how you render your application.")))),l.default.createElement(i.Section,{title:"Setup",id:"setup"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Apollo's React components include an ",l.default.createElement(o.InlineComponent,null,"ApolloProvider")," ","component for accessing your Apollo client throughout the application. The ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," should be a descendant of the ",l.default.createElement(o.InlineComponent,null,"ApolloProvider")," because we don't need to re-render the"," ",l.default.createElement(o.InlineComponent,null,"ApolloProvider")," for every new response.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},'import { ApolloProvider } from "react-apollo";\nimport { CuriProvider } from "@curi/react";\n\nReactDOM.render((\n  <ApolloProvider client={client}>\n    <CuriProvider router={router}>\n      {() => {...}}\n    </CuriProvider>\n  </ApolloProvider>\n), holder);'))),l.default.createElement(i.Section,{title:"Loose Pairing",id:"loose-pairing"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Apollo and Curi don't actually have to know about each other. Curi can create a response without doing any data fetching and let Apollo handle that with its ",l.default.createElement(o.InlineComponent,null,"Query")," component.")),l.default.createElement(c.CodeBlock,null,"// routes.js\nimport Noun from \"./pages/Noun\";\n\n// nothing Apollo related in here\nconst routes = [\n  {\n    name: 'Noun',\n    path: 'noun/:word',\n    response: () => {\n      return {\n        body: Noun\n      };\n    }\n  }\n];")),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Any location data that a query needs can be taken from the response object. The best way to access this from your components would be to pass the ",l.default.createElement(o.InlineJS,null,"response")," as a prop to the components rendered in the ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," component's render-invoked"," ",l.default.createElement(o.InlineJS,null,"children")," prop.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},'// index.js\nReactDOM.render((\n  <ApolloProvider client={client}>\n    <CuriProvider router={router}>\n      {({ response }) => {\n        const { body:Body } = response;\n        return <Body response={response} />;\n      }}\n    </CuriProvider>\n  </ApolloProvider>\n), holder);          \n          \n// pages/Nouns.js\nimport { Query } from "react-apollo";\n\nconst GET_NOUN = gql`\n  query noun($word: String!) {\n    noun(word: $word) {\n      word,\n      type,\n      definition\n    }\n  }\n`;\n\n// use the "word" param from the response\n// to query the correct data\nconst Noun = ({ response }) => (\n  <Query\n    query={GET_NOUN}\n    variables={{ word: response.params.word }}\n  >\n    {({ loading, error, data }) => {\n      if (loading) {\n        return <Loading />;\n      }\n      // ...\n\n      return (\n        <div>\n          <h1>{data.noun.word}</h1>\n          <p>{data.noun.definition}</p>\n        </div>\n      )\n    }}\n  </Query>\n);'))),l.default.createElement(i.Section,{title:"Tight Pairing",id:"tight-pairing"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"You can use your Apollo client to call queries in a route's"," ",l.default.createElement(o.InlineJS,null,"on.every()")," function to tightly pair Curi and Apollo."," ",l.default.createElement(o.InlineJS,null,"client.query()")," returns a Promise, just like"," ",l.default.createElement(o.InlineJS,null,"on.every()")," should, so ",l.default.createElement(o.InlineJS,null,"on.every()")," can return a"," ",l.default.createElement(o.InlineJS,null,"client.query()")," call. This allows you to delay navigation until after a route's GraphQL data has been loaded by Apollo."),l.default.createElement("p",null,"There are two strategies for doing this. Both approaches require you to be able to import your Apollo client in the module where you define your routes. If you create and export your Apollo Client in its own module, you can import it throughout your application.")),l.default.createElement(c.CodeBlock,null,'// apollo.js\nimport ApolloClient from "apollo-boost";\n\nexport default ApolloClient({\n  uri: "https://example.com/graphql"\n});\n\n// index.js\nimport client from "./apollo";\n\nReactDOM.render((\n  <ApolloProvider client={client}>\n    /*...*/\n  </ApolloProvider>\n), holder);\n\n// routes.js\nimport client from "./apollo";\n\n// ...')),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"The first approach is to avoid the ",l.default.createElement(o.InlineComponent,null,"Query")," altogether. Instead, you can use a route's ",l.default.createElement(o.InlineJS,null,"response()")," property to attach the data fetched by Apollo directly to a response.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},'// routes.js\nimport client from "./apollo";\nimport GET_VERB from "./queries";\n\nimport Verb from "./pages/Verb";\n\nexport default [\n  {\n    name: "Verb",\n    path: "verb/:word",\n    on: {\n      every({ params }) {\n        // load the data\n        return client.query({\n          query: GET_VERB,\n          variables: { word: params.word }\n        })\n      }\n    },\n    response({ resolved }) {\n      // attach the resolved data to the response.\n      // in the real world, you would also check for errors\n      // here in case something goes wrong with the query\n      return {\n        body: Verb,\n        data: resolved.every.data\n      }\n    }\n  }\n];\n\n// pages/Verb.js\nconst Verb = ({ response }) => (\n  <div>\n    <h1>{response.data.verb.word}</h1>\n    <p>\n      {response.data.verb.definition}\n    </p>\n  </div>\n)')),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"The second approach is to use ",l.default.createElement(o.InlineJS,null,"on.every()")," as a way to cache the data, but also use ",l.default.createElement(o.InlineComponent,null,"Query"),". When the"," ",l.default.createElement(o.InlineComponent,null,"Query")," calls the query, Apollo will grab the data from its cache instead of re-sending a request to your server.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},'// routes.js\nimport client from "./apollo";\nimport { GET_VERB } from "./queries";\n\nexport default [\n  {\n    name: "Verb",\n    path: "verb/:word",\n    on: {\n      every({ params }) {\n        // load the data so it is cached by\n        // your Apollo client\n        return client.query({\n          query: GET_VERB,\n          variables: { word: params.word }\n        })\n      }\n    }\n  }\n];\n\n// pages/Verb.js\nimport { GET_VERB } from "../queries";\n\nconst Verb = ({ response }) => (\n  <Query\n    query={GET_VERB}\n    variables={{ word: response.params.word }}\n  >\n    {({ loading, error, data }) => {\n      // ...\n      return (\n        <div>\n          <h1>{data.verb.word}</h1>\n          <p>\n            {data.verb.definition}\n          </p>\n        </div>\n      );\n    }}\n  </Query>\n)')),l.default.createElement(i.Subsection,{title:"Prefetching",id:"prefetch"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"One additional benefit of adding queries to routes using"," ",l.default.createElement(o.InlineJS,null,"on.every()")," functions is that you can prefetch data for a route."),l.default.createElement("p",null,"The"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"route-prefetch"}},l.default.createElement(o.InlineJS,null,"@curi/route-prefetch"))," ","interaction lets you programmatically fetch the data for a route prior to navigating to a location.")),l.default.createElement(c.CodeBlock,null,'// index.js\nimport prefetch from "@curi/route-prefetch";\n\nconst routes = [\n  {\n    name: "Example",\n    path: "example/:id",\n    on: {\n      every({ params }) {\n        client.query({\n          query: GET_EXAMPLES,\n          variables: { id: params.id }\n        })\n      }\n    }\n  }\n]\n\nconst router = curi(history, routes, {\n  route: [prefetch()]\n});\n\n// this will call the GET_EXAMPLES query\n// and Apollo will cache the results\nroute.prefetch("Example", {\n  params: { id: 2 }\n});')),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,l.default.createElement(a.Link,{to:"Package",params:{package:"react "}},l.default.createElement(o.InlineJS,null,"@curi/react"))," ","provides a ",l.default.createElement(o.InlineComponent,null,"Prefetch")," component that will automatically prefetch the data for a route once an element becomes visible in the page."),l.default.createElement("p",null,l.default.createElement(o.InlineComponent,null,"Prefetch")," relies on you attaching a ",l.default.createElement(o.InlineJS,null,"ref")," to the element that should trigger prefetching.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},'import { Prefetch, Link } from "@curi/react";\n            \n// don\'t forget to attach the ref to a component!\nconst PrefetchLink = ({ to, params, ...rest }) => (\n  <Prefetch match={{ name: to, params }}>\n    {ref => (\n      <Link to={to} params={params} ref={ref} {...rest} />\n    )}\n  </Prefetch>\n);\n\n// usage\n<PrefetchLink to="Example" params={{ id: 3 }}>\n  Example 3\n</Prefetch>')),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"If you want to get really fancy, ",l.default.createElement(o.InlineComponent,null,"Prefetch")," also lets you access the prefetched data with the second argument to its render-invoked ",l.default.createElement(o.InlineJS,null,"children")," prop. You can do this to update your UI to indicate that the data has loaded or even use the loaded data with some filler content.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"const PrefetchLink = ({ to, params, children, ...rest }) => (\n  <Prefetch match={{ name: to, params }}>\n    {(ref, resolved) => (\n      <Link to={to} params={params} ref={ref} {...rest}>\n        {children}\n        {resolved ? <Loading /> : <Loaded />}\n      </Link>\n    )}\n  </Prefetch>\n);")))))}},112:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=d(n(0)),a=n(1),r=d(n(60)),o=n(2),u=n(10),i=n(57),c=n(4);function d(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement(u.Note,null,"This guide assumes that you are already familiar with React Native."))),l.default.createElement(i.Section,{title:"Back Button",id:"back-button"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"To add back button support, you need to use your ",l.default.createElement(o.InlineJS,null,"history")," ","object (which you can use directly or access through your router)."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"history.go()")," method is used for jumping between locations, so passing it ",l.default.createElement(o.InlineJS,null,"-1")," will jump back to the previous location."),l.default.createElement("p",null,"When the app is at the initial location, you may want to return"," ",l.default.createElement(o.InlineJS,null,"false")," to close the app when the user presses the back button.")),l.default.createElement(c.CodeBlock,null,"import { BackHandler } from 'react-native';\n\n// create your router\nconst router = curi(history, routes);\n\nBackHandler.addEventListener(\n  \"hardwareBackPress\",\n  () => {\n    // close the app when pressing back button\n    // while on the initial screen\n    if (router.history.index === 0) {\n      return false;\n    }\n    router.history.go(-1);\n    return true;\n  }\n);"))),l.default.createElement(i.Section,{title:"Components",id:"components"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"The"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"react-native"}},l.default.createElement(o.InlineJS,null,"@curi/react-native"))," ","package is quite similar to the"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"react"}},l.default.createElement(o.InlineJS,null,"@curi/react"))," ","package. In fact, Curi's React Native package re-exports most of the components from the React package."))),l.default.createElement(i.Subsection,{title:l.default.createElement(o.InlineComponent,null,"Link"),id:"components-link"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"The main difference is that they have different ",l.default.createElement(o.InlineComponent,null,"Link")," ","components. While the React package's ",l.default.createElement(o.InlineComponent,null,"Link")," renders an anchor by default, the React Native ",l.default.createElement(o.InlineComponent,null,"Link")," renders a"," ",l.default.createElement(o.InlineComponent,null,"TouchableHighlight")," by default."),l.default.createElement(u.Note,null,"Don't forget to wrap the ",l.default.createElement(o.InlineComponent,null,"Link"),"'s text in a"," ",l.default.createElement(o.InlineComponent,null,"Text"),"!")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"import { Link } from '@curi/react-native';\n\n<Link to='Home'>\n  <Text>Home</Text>\n</Link>"))),l.default.createElement(i.Subsection,{title:l.default.createElement(o.InlineComponent,null,"CuriProvider"),id:"componentsCuriProvider"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"@curi/react")," provides a ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," ","component that will listen for new responses and re-render your application.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"import { CuriProvider } from '@curi/react-native';\n\nimport router from './router';\n\nconst App = () => (\n  <CuriProvider router={router}>\n    {({ response }) => {\n      const { body:Body } = response;\n      return <Body response={response} />;\n    }}\n  </CuriProvider>\n);")))))}},113:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=c(n(0)),a=n(1),r=c(n(60)),o=n(2),u=(n(10),n(57)),i=n(4);function c(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"In the code splitting guide, we used the ",l.default.createElement(o.InlineJS,null,"on.initial()")," ","property of routes. Routes also have ",l.default.createElement(o.InlineJS,null,"on.every()")," and"," ",l.default.createElement(o.InlineJS,null,"response()")," properties. While ",l.default.createElement(o.InlineJS,null,"initial"),"is only called the first time a route matches, ",l.default.createElement(o.InlineJS,null,"on.every()")," and"," ",l.default.createElement(o.InlineJS,null,"response()")," are called every time a route matches."))),l.default.createElement(u.Section,{title:"every",id:"every"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"on.every()")," is where you should perform any data loading for the matched route."),l.default.createElement("p",null,"When the ",l.default.createElement(o.InlineJS,null,"Recipe")," route matches, we want to fetch data for that specific recipe (using the ",l.default.createElement(o.InlineJS,null,"id")," param from the path).")),l.default.createElement(i.CodeBlock,null,"const routes = [\n  {\n    name: 'Recipe',\n    path: 'recipe/:id'\n  }\n];")),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"every"),' function will be passed a "route" object that contains the matched route response properties, including the route'," ",l.default.createElement(o.InlineJS,null,"params"),"."),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"on.every()")," is expected to return a Promise."),l.default.createElement("p",null,"Now, when we navigate to ",l.default.createElement(o.InlineJS,null,"/recipe/chocolate-chip-cookies"),", the ",l.default.createElement(o.InlineJS,null,"every")," function will call the fake API function to load the ",l.default.createElement(o.InlineJS,null,'"chocolate-chip-cookies"')," recipe. The function will resolve with the loaded data.")),l.default.createElement(i.CodeBlock,null,"{\n  name: 'Recipe',\n  path: 'recipe/:id',\n  on: {\n    every: ({ params }) => fakeAPI.getRecipe(params.id)\n  }\n}"))),l.default.createElement(u.Section,{title:"response",id:"response"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"While ",l.default.createElement(o.InlineJS,null,"on.every()")," starts our data loading, it doesn't actually do anything. Instead, we should handle any loaded data with the ",l.default.createElement(o.InlineJS,null,"response()")," function."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"response()")," and ",l.default.createElement(o.InlineJS,null,"on.every()")," are separate because while a route is resolving, the user may navigate again, which overrides the current navigation. We cannot cancel the"," ",l.default.createElement(o.InlineJS,null,"on.every()")," function for the current navigation, so if it performs any side effects, our application is stuck with them. To avoid this, the ",l.default.createElement(o.InlineJS,null,"response()")," function is not called until we know that the current navigation will complete."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"response()")," function will receive an object with a number of properties. These are covered in detail in the"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"routes"},hash:"response"},"All About Routes")," ","guide. The function returns an object with values that will modify the response."),l.default.createElement("p",null,"Here, we will be using the ",l.default.createElement(o.InlineJS,null,"resolved")," object to modify the response's ",l.default.createElement(o.InlineJS,null,"data"))),l.default.createElement(i.CodeBlock,null,"{\n  name: 'Recipe',\n  path: 'recipe/:id',\n  response({ resolved }) {\n    return {\n      body: Recipe,\n      data: resolved.every\n    }\n  },\n  on: {\n    every: ({ params }) => fakeAPI.getRecipe(params.id),\n  }\n}")),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"If at some point in time we decide that we want to change our URI pathname structure, we can also use the ",l.default.createElement(o.InlineJS,null,"response()")," ","function to redirect."),l.default.createElement("p",null,"You can specify the route to redirect to with ",l.default.createElement(o.InlineJS,null,"redirectTo"),". This takes the ",l.default.createElement(o.InlineJS,null,"name")," of the route to redirect to,"," ",l.default.createElement(o.InlineJS,null,"params")," if the route (or ancestor routes) have route params. ",l.default.createElement(o.InlineJS,null,"hash"),", ",l.default.createElement(o.InlineJS,null,"query"),", and ",l.default.createElement(o.InlineJS,null,"state")," can also be provided."),l.default.createElement("p",null,"After Curi emits the response, it will also automatically redirect to the new location!")),l.default.createElement(i.CodeBlock,null,"{\n  name: 'Old Recipe',\n  path: 'r/:id',\n  response: ({ params }) => {\n    // destructure the current location to preserve\n    // query/hash values\n    return {\n      redirectTo: {\n        name: 'Recipe',\n        params: params,\n        hash: location.hash\n      }\n    };\n  }\n}"))),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"every")," and ",l.default.createElement(o.InlineJS,null,"response")," offer a convenient way to do data loading prior to actually rendering the route, but please remember that your application will not be re-rendering until ",l.default.createElement("em",null,"after")," the fetching has resolved. If you have a long running load function, you may wish to implement some sort of loading display. The"," ",l.default.createElement(a.Link,{to:"Example",params:{category:"react",slug:"data-loading"}},"data loading example")," ","shows one approach to how to do this."))}},114:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=d(n(0)),a=n(1),r=d(n(60)),o=n(2),u=n(10),i=n(57),c=n(4);function d(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"If you are bundling an application with a lot of routes, users of your application may be downloading a lot of unnecessary content for the initial page render. Using code splitting, you can reduce the initial download size for your application by splitting code that is conditionally loaded into a separate bundle that is only downloaded when it is needed."),l.default.createElement(u.Note,null,"This guide assumes that you are using Webpack 2+ to bundle your application."))),l.default.createElement(i.Section,{title:"An app without code splitting",id:"no-split"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Let's start out by describing our application's routes without code splitting. We will import each route's component from the files where they are defined.")),l.default.createElement(c.CodeBlock,null,"import Home from './components/Home';\nimport Contact from './components/Contact';\nimport ContactMethod from './components/ContactMethod';\n\nconst routes = [\n  {\n    name: 'Home',\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    name: 'Contact',\n    path: 'contact',\n    response: () => {\n      return {\n        body: Contact\n      };\n    },\n    children: [\n      {\n        name: 'Contact Method',\n        path: ':method',\n        response: () => {\n          return {\n            body: ContactMethod\n          };\n        }\n      }\n    ]\n  }\n];"))),l.default.createElement(i.Section,{title:"import() in on.initial()",id:"initial"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Instead of having static imports, we will use the"," ",l.default.createElement(o.InlineJS,null,"import()")," function to import our modules. We will import our components using the ",l.default.createElement(o.InlineJS,null,"on.initial()")," property of routes. This function will only be called the first time that its route matches, so we don't have to worry about making extra requests to our server."),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"on.initial()")," should be a function that returns a Promise;"," ",l.default.createElement(o.InlineJS,null,"import()"),", conveniently, returns a Promise. Then, in our"," ",l.default.createElement(o.InlineJS,null,"response()")," function, instead of referencing values imported at the top of the file, we can reference the result of the"," ",l.default.createElement(o.InlineJS,null,"initial")," function using ",l.default.createElement(o.InlineJS,null,"resolved.initial"),"."),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"import()")," resolves with a module object. If the component is a default export (",l.default.createElement(o.InlineJS,null,"export default MyComponent"),"), we can access the component through the imported module object's"," ",l.default.createElement(o.InlineJS,null,"default")," property.")),l.default.createElement(c.CodeBlock,null,"const routes = [\n  {\n    name: 'Home',\n    path: '',\n    response: ({ resolved }) => {\n      return {\n        body: resolved.initial\n      };\n    },\n    on: {\n      initial: () => (\n        import('./components/Home')\n          .then(module => module.default)\n      ),\n    }\n  },\n  {\n    name: 'Contact',\n    path: 'contact',\n    response: ({ resolved }) => {\n      return {\n        body: resolved.initial\n      };\n    },\n    on: {\n      initial: () => (\n        import('./components/Contact')\n          .then(module => module.default)\n      ),\n    },\n    children: [\n      {\n        name: 'Contact Method',\n        path: ':method',\n        response: ({ resolved }) => {\n          return {\n            body: resolved.initial\n          };\n        },\n        on: {\n          initial: () => (\n            import('./components/ContactMethod')\n              .then(module => module.default)\n          )\n        }\n      }\n    ]\n  }\n];"))),l.default.createElement(i.Section,{title:"Next",id:"next"},l.default.createElement("p",null,"The approaches taken here are not the only way to do code splitting. You may choose to skip the ",l.default.createElement(o.InlineJS,null,"on.initial()")," method and do code splitting at other points in your application."),l.default.createElement("p",null,"Whatever path you decide to go, hopefully this has shown you that setting up code splitting with the ",l.default.createElement(o.InlineJS,null,"on.initial()")," property is fairly simple to do. If you are using Webpack and want to reduce your initial bundle size, ",l.default.createElement(o.InlineJS,null,"on.initial()")," is a good way to accomplish this."),l.default.createElement("p",null,"Next, we will take a look at some related route properties in"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"loading"}},"the loading guide"),".")))}},115:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=c(n(0)),a=n(1),r=c(n(60)),o=n(2),u=n(57),i=n(4);function c(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Curi side effects are permament observers of your router, but you can specify whether they should be run before or after observers that were setup using ",l.default.createElement(o.InlineJS,null,"router.respond()"),"."),l.default.createElement("p",null,"Whenever a new response is generated, all of the side effect functions will be called. They will be given two arguments: the new response object and an object with navigation information (the navigation action the previous response).")),l.default.createElement(i.CodeBlock,null,"function logResponse({ response }) {\n  // call your logging API to record the response\n}")),l.default.createElement(u.Section,{title:"Adding Side Effects",id:"adding"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Side effects are provided to your router with the"," ",l.default.createElement(o.InlineJS,null,"sideEffects")," property of the options object. This is an array of objects with an ",l.default.createElement(o.InlineJS,null,"effect")," observer function.")),l.default.createElement(i.CodeBlock,null,"const router = curi(history, routes, {\n  sideEffects: [{ effect: logResponse }]\n});")),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Side effects can also have an ",l.default.createElement(o.InlineJS,null,"after")," property. By default, side effect functions will be called before any regular observer functions (the ones added with ",l.default.createElement(o.InlineJS,null,"router.respond()"),"). Some side effects make more sense to run after those observers, especially if they rely on the application's content to be updated. To do that, you need to include ",l.default.createElement(o.InlineJS,null,"after: true")," in your side effect object. If you do no provide this property, this will default to ",l.default.createElement(o.InlineJS,null,"false"),".")),l.default.createElement(i.CodeBlock,null,"const router = curi(history, routes, {\n  sideEffects: [{ effect: logResponse, after: true }]\n});")),l.default.createElement(u.Subsection,{title:"Official Side Effects",id:"official"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,'Curi has two "official" side effect packages:'),l.default.createElement("ul",null,l.default.createElement("li",null,l.default.createElement(a.Link,{to:"Package",params:{package:"side-effect-title"}},"@curi/side-effect-title")),l.default.createElement("li",null,l.default.createElement(a.Link,{to:"Package",params:{package:"side-effect-scroll"}},"@curi/side-effect-scroll")))),l.default.createElement(i.CodeBlock,null,'import titleEffect from "@curi/side-effect-title";\nimport scrollEffect from "@curi/side-effect-scroll";\n\nconst router = curi(history, routes, {\n  sideEffect: [\n    { effect: titleEffect() },\n    { effect: scrollEffect(), after: true }\n  ]\n});')))),l.default.createElement(u.Section,{title:"Creating Side Effects",id:"creating"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Side effects are functions that receive a response object and a navigation object and do something with them.")),l.default.createElement(i.CodeBlock,null,"function mySideEffect({ response, navigation }) {\n  console.log('Navigating to', response.location);\n  console.log('Navigation action:', navigation.action);\n}\n\nconst router = curi(history, routes, {\n  sideEffects: [{ effect: mySideEffect }]\n});")),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"You can write a side effect factory if you need to create a more customizable side effect.")),l.default.createElement(i.CodeBlock,null,"function AnalyticsLogger(options) {\n  // do some setup with the provided options\n  const logger = setupMyLogger(options);\n\n  // and return the actual side effect function\n  return sideEffect({ response }) {\n    logger(response);\n  }\n}")),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"That really is all there is required to know in order to write your own side effects. You may want to review the"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"responses"},hash:"response-properties"},"response properties")," ","to know which properties you should expect a response to have, but other than that they are pretty simple.")))),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Next we will take a closer look at how to add"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"code-splitting"}},"code splitting")," ","to routes.")))}},116:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=c(n(0)),a=n(1),r=c(n(60)),o=n(2),u=n(57),i=n(4);function c(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Route interactions let you interact with a registered route using its name."),l.default.createElement("p",null,"A registered route is generally any route that is in the array of routes that you used to create your router. However, some interactions only register routes that meet some criteria. For example, the"," ",l.default.createElement(o.InlineJS,null,"prefetch")," interaction only registers routes with asynchronous methods."),l.default.createElement("p",null,"Route interactions are defined using objects with four properties: name, register, get, and reset.")),l.default.createElement(i.CodeBlock,null,"{\n  // The string you will use to call the interaction.\n  name: 'my',\n\n  // A function used internally to register routes\n  // with the interaction. You only need to use this when\n  // writing your own interactions.\n  register: function(route, parentData) {...},\n\n  // This is the function that you will call. For example,\n  // with this interaction, the get function will be\n  // called when you call router.route.my('...')\n  get: function(route) {...},\n  reset: function() {...}\n}")),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Instead of importing the actual route interaction object, you typically import a factory function to create the object. This isn't absolutely necessary, but is useful for server-side rendering.")),l.default.createElement(i.CodeBlock,null,'// interactions/my.js\nexport default function createMyInteraction() {\n  return {\n    name: "my",\n    register() {...},\n    get() {...},\n    reset() {...}\n  };\n}\n\n// index.js\nimport createMyInteraction from "./interactions/my";\n\nconst interaction = createMyInteraction();')),l.default.createElement(u.Section,{title:"Adding Interactions",id:"adding"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Route interactions are provided to the router call as an array using the ",l.default.createElement(o.InlineJS,null,"route")," property of the options object (the third argument).")),l.default.createElement(i.CodeBlock,null,"const router = curi(history, routes, {\n  route: [createMyInteraction()]\n});")),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"The route interaction will be added to the router's ",l.default.createElement(o.InlineJS,null,"route")," ","property. When you call an interaction, you pass the name of the route that you want to interact with.")),l.default.createElement(i.CodeBlock,null,"const myValue = router.route.my('Some Route', ...);"))),l.default.createElement(u.Section,{title:"Creating Route Interactions",id:"creating"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"There are a few steps to creating your own route interactions."),l.default.createElement("p",null,"Remember to export a function that will create the interaction object, not the actual interaction object.")),l.default.createElement(i.CodeBlock,null,"// we'll create an interaction that confirms\n// a route is registered\nexport default function confirmInteraction() {\n  ...\n}")),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"The function should return an object with four properties:"," ",l.default.createElement(o.InlineJS,null,"name"),", ",l.default.createElement(o.InlineJS,null,"register"),", ",l.default.createElement(o.InlineJS,null,"get"),", and"," ",l.default.createElement(o.InlineJS,null,"reset"),"."),l.default.createElement("table",null,l.default.createElement("thead",null,l.default.createElement("tr",null,l.default.createElement("th",null,"property"),l.default.createElement("th",null,"description"))),l.default.createElement("tbody",null,l.default.createElement("tr",null,l.default.createElement("td",null,"name"),l.default.createElement("td",null,"a unique identifier for the route interaction")),l.default.createElement("tr",null,l.default.createElement("td",null,"register"),l.default.createElement("td",null,"a function to internally store information about routes")),l.default.createElement("tr",null,l.default.createElement("td",null,"get"),l.default.createElement("td",null,"a function that will receive a route's name (and possibly other arguments) and perform some task using the related route")),l.default.createElement("tr",null,l.default.createElement("td",null,"reset"),l.default.createElement("td",null,"a function that will reset the interaction's internal state (this is used if you call ",l.default.createElement(o.InlineJS,null,"router.replaceRoutes()"),")"))))),l.default.createElement(i.CodeBlock,null,"export default function confirmInteraction() {\n  // maintain an object of known routes\n  let knownRoutes = {};\n  return {\n    name: 'confirm',\n    // when a route is registered,\n    // we store it using its name\n    register: route => {\n      knownRoutes[route.name] = true;\n    },\n    // get checks the known routes to see if one exists\n    // with the requested name\n    get: (name) => {\n      return knownRoutes[name] != null\n    },\n    // reset the known routes\n    reset: () => {\n      knownRoutes = {};\n    }\n  };\n}")),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"In your application, you can import it, call the factory to create the interaction, and register the interaction when you create the router.")),l.default.createElement(i.CodeBlock,null,"import curi from '@curi/core';\nimport confirmFactory from './interactions/confirm'\n\nconst routes = [{ name: 'Home', path: '' }];\n\nconst router = curi(history, routes, {\n  route: [confirmFactory()]\n});\n\nrouter.route.confirm('Home'); // true\nrouter.route.confirm('Elsewhere'); // false")),l.default.createElement(u.Subsection,{title:"Slightly more advanced",id:"Slightly-more-advanced"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"You might want to write an interaction that uses data from parent routes when registering a route. For example, the built-in pathname interaction joins a route's path with it parent path(s)."),l.default.createElement("p",null,"The second argument passed to a router interaction's"," ",l.default.createElement(o.InlineJS,null,"register()")," function is a parent data object. For root routes, this will be ",l.default.createElement(o.InlineJS,null,"undefined"),". For nested routes, this is the value returned by the parent route's ",l.default.createElement(o.InlineJS,null,"register()")," ","function.")),l.default.createElement(i.CodeBlock,null,"function ParentFactory() {\n  let routeTree = {};\n  return {\n    name: 'routeParent',\n    register: (route, parent) => {\n      routeTree[route.name] = parent;\n      // we return route.name and any child routes will\n      // receive that as their parent value\n      return route.name;\n    },\n    get: (name) => {\n      return routeTree[name];\n    },\n    reset: () => {\n      routeTree = {};\n    }\n  }\n}")))),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Next on the list are side effects, which you can learn more about in the"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"side-effects"}},"Using Side Effects")," ","guide.")))}},117:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=c(n(0)),a=n(1),r=c(n(60)),o=n(2),u=(n(10),n(57)),i=n(4);function c(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement(u.Section,{title:"The Properties of a Navigation Object",id:"navigation-properties"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"navigation")," object contains information about the previous navigation. It has two properties: ",l.default.createElement(o.InlineJS,null,"action")," and"," ",l.default.createElement(o.InlineJS,null,"previous"),".")),l.default.createElement(i.CodeBlock,null,"{\n  // the type of navigation,\n  // either PUSH, REPLACE, or POP\n  action: 'PUSH',\n\n  // the previous response object\n  // or null for the initial response\n  previous: {\n    name: 'Home',\n    ...\n  }\n}"))),l.default.createElement(u.Section,{title:"Usage",id:"usage"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"What is the point of the ",l.default.createElement(o.InlineJS,null,"navigation")," object? It is there to provide you information about a navigation that doesn't make sense to attach to a ",l.default.createElement(o.InlineJS,null,"response")," object."),l.default.createElement("p",null,"One usage of it would be to display a Pinterest/Twitter style modal. You could render the background using the previous response while rendering the modal using the new response."),l.default.createElement("p",null,"Another use case may be to determine how to transition between two locations, either using the ",l.default.createElement(o.InlineJS,null,"action")," to determine"," ",l.default.createElement("em",null,"how")," the application navigated or the ",l.default.createElement(o.InlineJS,null,"previous")," ","response to map between two routes.")))),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Let's take a moment to go back to our router and look at what Curi's route interactions are for in the"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"route-interactions"}},"Route Interactions")," ","guide.")))}},118:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=d(n(0)),a=n(1),r=d(n(60)),o=n(2),u=n(10),i=n(57),c=n(4);function d(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Response objects are created by the router to descibe the route that matches a location. Some of these properties are set automatically, while others can be modified using the object returned a route's"," ",l.default.createElement(o.InlineJS,null,"response()")," function."),l.default.createElement(u.Note,null,"You can review the response properties that can be modified in the"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"routes"},hash:"response"},"routes guide"),"."))),l.default.createElement(i.Section,{title:"The Properties of a Response Object",id:"response-properties"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"There are two types of response properties."))),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,'The "match" properties are set based on the route that matches a location. A response always has these proeprties.')),l.default.createElement(c.CodeBlock,null,"// match properties\n{\n  // The location object used to generate the response.\n  location: { pathname: '/photos/6789/12345', ... },\n\n  // The name of the best matching route\n  name: 'Photo',\n\n  // The name of ancestor routes that matched\n  // part of the location's pathname\n  partials: ['Album'],\n\n  // An object containing the values parsed\n  // from the pathname by path-to-regexp.\n  // This includes params from ancestor routes.\n  params: { photoID: 12345, albumID: 6789 },\n}")),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,'The "settable" properties are ones that are added by a matched route\'s ',l.default.createElement(o.InlineJS,null,"response()")," function. These only exist on the response when they are returned by ",l.default.createElement(o.InlineJS,null,"route.response()"),".")),l.default.createElement(c.CodeBlock,null,"// settable properties\n{\n  // The body value is set using a route's response()\n  // return object. This is where you can attach\n  // component(s) to a route. The structure here\n  // is up to you, but each of your routes should have\n  // the same structure.\n  body: Photo,\n  // or maybe\n  body: {\n    menu: PhotoMenu,\n    main: Photo\n  },\n  // Please see below for more information\n  // about this property\n\n  // The status code for the response.\n  // This is mostly useful for server-side rendering\n  status: 200,\n\n  // This can be anything you want. It is set using\n  // a route's response() return object.\n  data: {...},\n\n  // The title string is set using a route's response()\n  // return object\n  title: 'Photo 12345',\n\n  // A value set by the route's response() return object.\n  error: undefined,\n\n  // A location to redirect to\n  redirectTo: {...}\n}")),l.default.createElement(i.Subsection,{title:"Redirect Response",id:"redirect-properties"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"When ",l.default.createElement(o.InlineJS,null,"route.response()")," returns an object with a"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"routes"},hash:"response"},l.default.createElement(o.InlineJS,null,"redirectTo")," property")," ","the router will turn this into a location object. Curi will automatically redirect to this location.")),l.default.createElement(c.CodeBlock,null,"{\n  // The redirectTo property provides information on\n  // where you should redirect to\n  redirectTo: { pathname: '/login' }\n}")),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"You can choose whether or not you want responses with a"," ",l.default.createElement(o.InlineJS,null,"redirectTo")," property to be emitted. The default behavior is to emit them, but this also means that you have to render using the redirect response. The ",l.default.createElement(o.InlineJS,null,"{ emitRedirects: false }")," ","option prevents this.")),l.default.createElement(c.CodeBlock,null,"const router = curi(history, routes, {\n  emitRedirects: false\n});")))),l.default.createElement(i.Section,{title:"The Body Property",id:"body-property"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"body")," property of a response is likely the most important property of a ",l.default.createElement(o.InlineJS,null,"response")," because it is what you will actually render. This value can be anything you want it to be, but it should usually be a function/component or an object containing functions/components."),l.default.createElement(u.Note,null,"It is important that each route uses the same structure for setting the body. Mixing structures will make rendering more difficult.")),l.default.createElement(c.CodeBlock,null,'{\n  name: "Home",\n  path: "",\n  response: () => {\n    // a function/component\n    return {\n      body: Home\n    };\n    // an object containing\n    // functions/componnets\n    return {\n      body: {\n        menu: HomeMenu,\n        main: Home\n      }\n    };\n  }\n}'))),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Next, we'll take a look at"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"observers"}},"observers"),".")))}},119:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=d(n(0)),a=n(1),r=d(n(60)),o=n(2),u=n(10),i=n(57),c=n(4);function d(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"The Curi router uses an observer pattern. You give it an observer function and when a response is created, that function will be called."))),l.default.createElement(i.Section,{title:"Observer Argument",id:"argument"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Observers are passed an object with three properties:"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"core"},hash:"properties"},l.default.createElement(o.InlineJS,null,"router")),","," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"responses"}},l.default.createElement(o.InlineJS,null,"response")),", and"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"navigation-objects"}},l.default.createElement(o.InlineJS,null,"navigation")),". Which ones you use vary based on what the response handler is doing.")),l.default.createElement(c.CodeBlock,null,"function responseHandler({\n  router,\n  response,\n  navigation\n}) {\n  // ...\n}"))),l.default.createElement(i.Section,{title:"Use Cases",id:"use-cases"},l.default.createElement("p",null,"When should you use observers?"),l.default.createElement(i.Subsection,{title:"Setup",id:"setup"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"If any of the routes in an application have"," ",l.default.createElement(o.InlineJS,null,"on.initial()")," or ",l.default.createElement(o.InlineJS,null,"on.every()")," functions, when those routes match the response will be emitted asynchronously. When the application first renders, if the router matches an async route, the response isn't immediately ready to use. To deal with this, you can use an observer to render once the initial response is ready.")),l.default.createElement(c.CodeBlock,{lang:"jsx"},"function setup({ router }) {\n  ReactDOM.render((\n    <CuriProvider router={router}>\n      {({ response }) => <response.body />}\n    </CuriProvider>\n  ), document.getElementById('root'));\n}")),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"A setup function only needs to be called once, so you can call"," ",l.default.createElement(o.InlineJS,null,"router.respond()")," without any options."),l.default.createElement(u.Note,null,"Setup is the only thing your application ",l.default.createElement("em",null,"should")," need to write an observer for.")),l.default.createElement(c.CodeBlock,null,"router.respond(setup);"))),l.default.createElement(i.Subsection,{title:"Rendering",id:"rendering"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"If your application is using one of the provided Curi rendering packages (",l.default.createElement(a.Link,{to:"Package",params:{package:"react"}},l.default.createElement(o.InlineJS,null,"@curi/react")),","," ",l.default.createElement(a.Link,{to:"Package",params:{package:"react-native"}},l.default.createElement(o.InlineJS,null,"@curi/react-native")),","," ",l.default.createElement(a.Link,{to:"Package",params:{package:"vue"}},l.default.createElement(o.InlineJS,null,"@curi/vue")),", and"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"svelte"}},l.default.createElement(o.InlineJS,null,"@curi/svelte")),") you won't actually have to manually observe the router because those packages do that internally for you."),l.default.createElement("p",null,"If you are using vanilla JavaScript to render your application or you are writing your own framework implementation,"," ",l.default.createElement(o.InlineJS,null,"router.respond()")," with the"," ",l.default.createElement(o.InlineJS,null,"{ observe: true }")," option is what you would use to re-render new responses.")),l.default.createElement(c.CodeBlock,null,"function observer({ response }) {\n  // let the app know there is a new response\n}\n\nrouter.respond(observer, { observe: true });"))),l.default.createElement(i.Subsection,{title:"Side Effects",id:"side-effects"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Side effects are observers that are provided to the router at creation instead of by calling ",l.default.createElement(o.InlineJS,null,"router.respond()"),". These can be useful for tasks that are not rendering related as well as for tasks that need to be performed after a render has completed."),l.default.createElement("p",null,"The"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"side-effect-title"}},l.default.createElement(o.InlineJS,null,"@curi/side-effect-title"))," ","package provides a side effect that will use"," ",l.default.createElement(o.InlineJS,null,"response.title")," to set the page's"," ",l.default.createElement(o.InlineJS,null,"document.title"),"."),l.default.createElement("p",null,"With single-page applications, clicking on links wish hashes won't always scroll to the matching element in the page. The"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"side-effect-scroll"}},l.default.createElement(o.InlineJS,null,"@curi/side-effect-scroll"))," ","package adds this behavior by scrolling the page to the element that matches the new response's hash (",l.default.createElement(o.InlineJS,null,"response.location.hash"),") after the new response has rendered."),l.default.createElement("p",null,"If you need to add logging to your application, you could write your own observer to do this. Your observer can either be added as a side effect when the router is constructed or later using"," ",l.default.createElement(o.InlineJS,null,"router.respond()"),".")),l.default.createElement(c.CodeBlock,null,"function logger({ response }) {\n  loggingAPI.add(response.location);\n}\n\n// as a side-effect\nconst router = curi(history, routes, {\n  sideEffects: [{ fn: logger }]\n});\n\n// with respond\nrouter.respond(logger, { observe: true });")))),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Next, we will cover"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"navigation-objects"}},"navigation objects"),".")))}},120:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=d(n(0)),a=n(1),r=d(n(60)),o=n(2),u=n(10),i=n(57),c=n(4);function d(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Routes are JavaScript objects with two required propsâ€”",l.default.createElement(o.InlineJS,null,"name")," ","and ",l.default.createElement(o.InlineJS,null,"path"),"â€”and a number of optional properties.")),l.default.createElement(c.CodeBlock,null,"{\n  name: 'Home',\n  path: ''\n};")),l.default.createElement(i.Section,{title:"Route properties",id:"route-properties"},l.default.createElement(i.Subsection,{title:"route.name",id:"name"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"A string, this must be unique for every route.")),l.default.createElement(c.CodeBlock,null,"[\n  { name: 'Home' },\n  { name: 'Album' },\n  { name: 'Not Found' }\n];"))),l.default.createElement(i.Subsection,{title:"route.path",id:"path"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"A string to describe what the route matches. Curi uses"," ",l.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp#parameters"},l.default.createElement(o.InlineJS,null,"path-to-regexp"))," ","for matching the route to a location's ",l.default.createElement(o.InlineJS,null,"pathname"),"."," ",l.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp#parameters"},"Path parameters")," ","will be captured so that they can be parsed from a location's"," ",l.default.createElement(o.InlineJS,null,"pathname")," when the route matches."),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"path")," strings should ",l.default.createElement("strong",null,"not")," have a leading slash"),l.default.createElement(u.Warning,null,l.default.createElement(o.InlineJS,null,"path-to-regexp")," supports arrays and RegExps, but Curi only supports string paths. This is because Curi needs to generate pathnames given a route name and ",l.default.createElement(o.InlineJS,null,"path-to-regexp")," can only do that from strings.")),l.default.createElement(c.CodeBlock,null,"[\n  { name: 'Home', path: '' },\n  { name: 'Album', path: 'a/:albumID' },\n  { name: 'Not Found', path: '(.*)' }\n];\n// don't include a leading forward slash\n// { name: 'Home', path: '/' }"))),l.default.createElement(i.Subsection,{title:"route.on",id:"on"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"on")," object groups functions that will be called when the route matches. A route with an ",l.default.createElement(o.InlineJS,null,"on.initial()")," or"," ",l.default.createElement(o.InlineJS,null,"on.every()")," function is async."))),l.default.createElement(i.Subsection,{tag:"h5",title:"on.initial()",id:"initial"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"on.initial()")," is called the first time that a route matches. Its return value will be re-used on subsequent matches. It should return a Promise."),l.default.createElement("p",null,"This can be used for loading resources that don't change based on ",l.default.createElement(o.InlineJS,null,"params"),". For example, if you are doing code splitting with Webpack using ",l.default.createElement(o.InlineJS,null,"import()"),", you can load the modules in ",l.default.createElement(o.InlineJS,null,"on.initial()"),"."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"initial")," function will be passed an object with the matched route properties: ",l.default.createElement(o.InlineJS,null,"name"),", ",l.default.createElement(o.InlineJS,null,"params"),","," ",l.default.createElement(o.InlineJS,null,"partials"),", ",l.default.createElement(o.InlineJS,null,"location"),", and ",l.default.createElement(o.InlineJS,null,"key"),".")),l.default.createElement(c.CodeBlock,null,"const about = {\n  name: 'About',\n  path: 'about',\n  on: {\n    initial: () => import('./components/About')\n  }\n};"))),l.default.createElement(i.Subsection,{tag:"h5",title:"on.every()",id:"every"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"on.every()")," will be called every time a route matches. This can be useful for data fetching. Like"," ",l.default.createElement(o.InlineJS,null,"on.initial()"),", ",l.default.createElement(o.InlineJS,null,"on.every()")," should return a Promise."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"every")," function will be passed an object with the matched route properties: ",l.default.createElement(o.InlineJS,null,"name"),", ",l.default.createElement(o.InlineJS,null,"params"),","," ",l.default.createElement(o.InlineJS,null,"partials"),", ",l.default.createElement(o.InlineJS,null,"location"),", and ",l.default.createElement(o.InlineJS,null,"key"),"."),l.default.createElement(u.Note,null,"You should not perform side effects (e.g. passing the loaded data to a Redux store) in ",l.default.createElement(o.InlineJS,null,"on.every()")," because it is possible that navigating to the route might be cancelled. If you must perform side effects, you should do so in"," ",l.default.createElement(o.InlineJS,null,"response()"),".")),l.default.createElement(c.CodeBlock,null,"// fetch user data\nconst user = {\n  name: 'User',\n  path: ':id',\n  on: {\n    every: ({ params, location }) =>\n      fetch(`/api/users/${params.id}`)\n        .then(resp => JSON.parse(resp))\n  }\n}")))),l.default.createElement(i.Subsection,{title:"route.response()",id:"response"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,'A function for modifying the response object. This returns an object whose properties will be merged with the matched route properties to create the "final" response.'),l.default.createElement("p",null,"Only valid properties will be merged onto the response; everything else will be ignored. The valid properties are:"))),l.default.createElement("ol",null,l.default.createElement("li",null,l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"body")," - This is usually what you will render.")),l.default.createElement(c.CodeBlock,null,'import Home from "./components/Home";\nconst routes = [\n  {\n    name: "Home",\n    path: "",\n    response() {\n      return { body: Home };\n    }\n  },\n  // ...\n];\n// response = { body: Home, ... }'))),l.default.createElement("li",null,l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"status")," - A number. This is useful for redirects or locations caught by your catch-all route while using server-side rendering. The default status value is"," ",l.default.createElement(o.InlineJS,null,"200"),".")),l.default.createElement(c.CodeBlock,null,"{\n  response(){\n    return {\n      status: 301,\n      redirectTo: {...}\n    };\n  }\n}\n// response = { status: 301, ... }"))),l.default.createElement("li",null,l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"error")," - If an error occurs with the route's"," ",l.default.createElement(o.InlineJS,null,"on")," methods, you might want to attach an error message to the response.")),l.default.createElement(c.CodeBlock,null,'{\n  on: {\n    initial: () => Promise.reject("woops!")\n  },\n  response({ error }) {\n    return { error };\n  }\n}\n// response = { error: "woops!", ... }'))),l.default.createElement("li",null,l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"data")," - Anything you want it to be.")),l.default.createElement(c.CodeBlock,null,"{\n  response() {\n    return { data: Math.random() };\n  }\n}\n// response = { data: 0.8651606708109429, ... }"))),l.default.createElement("li",null,l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"title")," - This can be used with"," ",l.default.createElement(o.InlineJS,null,"@curi/side-effect-title")," to update the page's"," ",l.default.createElement(o.InlineJS,null,"document.title"),".")),l.default.createElement(c.CodeBlock,null,'{\n  response({ params }) {\n    return { title: `User ${params.id}` };\n  }\n}\n// when visting /user/2\n// response = { title: "User 2", ... }'))),l.default.createElement("li",null,l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"redirectTo")," - An object with the ",l.default.createElement(o.InlineJS,null,"name")," of the route to redirect to, ",l.default.createElement(o.InlineJS,null,"params")," (if required), and optional ",l.default.createElement(o.InlineJS,null,"hash"),", ",l.default.createElement(o.InlineJS,null,"query"),", and"," ",l.default.createElement(o.InlineJS,null,"state")," properties."),l.default.createElement("p",null,"The other values are copied directly, but"," ",l.default.createElement(o.InlineJS,null,"redirectTo")," will be turned into a location object using the object's ",l.default.createElement(o.InlineJS,null,"name")," (and ",l.default.createElement(o.InlineJS,null,"params")," if required).")),l.default.createElement(c.CodeBlock,null,'[\n  {\n    name: "Old Photo",\n    path: "photo/:id",\n    response({ params }) {\n      return {\n        redirectTo: { name: "Photo", params }\n      };\n    }\n  },\n  {\n    name: "New Photo",\n    path: "p/:id"\n  }\n]\n// when the user navigates to /photo/1:\n// response = { redirectTo: { pathname: "/p/1", ... } }')))),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"This function is passed an object with a number of properties that can be useful for modifying the response.")),l.default.createElement(c.CodeBlock,null,"{\n  response: ({ match, resolved }) => {\n    // ...\n  }\n}")),l.default.createElement("ul",null,l.default.createElement(i.Subsection,{tag:"li",title:"match",id:"response-match"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"An object with the matched route properties of a response."),l.default.createElement("table",null,l.default.createElement("thead",null,l.default.createElement("tr",null,l.default.createElement("th",null,"property"),l.default.createElement("th",null,"description"))),l.default.createElement("tbody",null,l.default.createElement("tr",null,l.default.createElement("td",null,"name"),l.default.createElement("td",null,"the name of the matched route")),l.default.createElement("tr",null,l.default.createElement("td",null,"params"),l.default.createElement("td",null,"route parameters parsed from the location")),l.default.createElement("tr",null,l.default.createElement("td",null,"partials"),l.default.createElement("td",null,"the names of any ancestor routes of the matched route")),l.default.createElement("tr",null,l.default.createElement("td",null,"location"),l.default.createElement("td",null,"the location that was used to match the route")),l.default.createElement("tr",null,l.default.createElement("td",null,"key"),l.default.createElement("td",null,"the location's ",l.default.createElement(o.InlineJS,null,"key"),", which is a unique identifier"))))))),l.default.createElement(i.Subsection,{tag:"li",title:"resolved",id:"response-resolved"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"resolved")," is an object with the values resolved by the ",l.default.createElement(o.InlineJS,null,"on.initial()")," and ",l.default.createElement(o.InlineJS,null,"on.every()")," ","functions."),l.default.createElement("table",null,l.default.createElement("thead",null,l.default.createElement("tr",null,l.default.createElement("th",null,"property"),l.default.createElement("th",null,"description"))),l.default.createElement("tbody",null,l.default.createElement("tr",null,l.default.createElement("td",null,"error"),l.default.createElement("td",null,"if either ",l.default.createElement(o.InlineJS,null,"on.initial()")," or"," ",l.default.createElement(o.InlineJS,null,"on.every()")," throw and the error is not caught, it will be available here")),l.default.createElement("tr",null,l.default.createElement("td",null,"initial"),l.default.createElement("td",null,"the value resolved by ",l.default.createElement(o.InlineJS,null,"on.initial()"))),l.default.createElement("tr",null,l.default.createElement("td",null,"every"),l.default.createElement("td",null,"the value resolved by ",l.default.createElement(o.InlineJS,null,"on.every()"))))),l.default.createElement("p",null,"If a route isn't async, ",l.default.createElement(o.InlineJS,null,"resolved")," will be"," ",l.default.createElement(o.InlineJS,null,"null"),".")),l.default.createElement(c.CodeBlock,null,"// attach resolved data to the response\nconst user = {\n  name: 'User',\n  path: ':id',\n  response: ({ resolved }) => {\n    const modifiers = {};\n    if (resolved.error) {\n      modifiers.error = resolved.error;\n    } else {\n      modifiers.data = resolved.every;\n    }\n    return modifiers;\n  },\n  on: {\n    every: ({ params, location }) => (\n      fetch(`/api/users/${params.id}`)\n        .then(resp => JSON.parse(resp))\n    ),\n  }\n}"))))),l.default.createElement(i.Subsection,{title:"children",id:"children"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"An optional array of route objects for creating nested routes. Any child routes will be matched relative to their parent route's"," ",l.default.createElement(o.InlineJS,null,"path"),". This means that if a parent route's"," ",l.default.createElement(o.InlineJS,null,"path")," string is ",l.default.createElement(o.InlineJS,null,"'one'")," and a child route's"," ",l.default.createElement(o.InlineJS,null,"path")," string is ",l.default.createElement(o.InlineJS,null,"'two'"),", the child will match when the pathname is ",l.default.createElement(o.InlineJS,null,"'one/two'"),".")),l.default.createElement(c.CodeBlock,null,"// '/a/Coloring+Book/All+Night' will be matched\n// by the \"Song\" route, with the params\n// { album: 'Coloring+Book', title: 'All+Night' }\n{\n  name: 'Album',\n  path: 'a/:album',\n  children: [\n    {\n      name: 'Song',\n      path: ':title'\n    }\n  ]\n}"))),l.default.createElement(i.Subsection,{title:"params",id:"params"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"When ",l.default.createElement(o.InlineJS,null,"path-to-regexp")," matches your paths, all parameters are extracted as strings. If you prefer for some route params to be other types, you can provide functions to transform params using the ",l.default.createElement(o.InlineJS,null,"route.params")," object."),l.default.createElement("p",null,"Properties of the ",l.default.createElement(o.InlineJS,null,"route.params")," object are the names of params to be parsed. The paired value should be a function that takes a string (the value from the ",l.default.createElement(o.InlineJS,null,"pathname"),") and returns a new value (transformed using the function you provide).")),l.default.createElement(c.CodeBlock,null,"const routes = [\n  {\n    name: 'Number',\n    path: 'number/:num',\n    params: {\n      num: n => parseInt(n, 10)\n    }\n  }\n]\n// when the user visits /number/1,\n// response.params will be { num: 1 }\n// instead of { num: \"1\" }"))),l.default.createElement(i.Subsection,{title:"pathOptions",id:"pathOptions"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"If you need to provide different path options than"," ",l.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp#usage"},"the defaults")," ","used by ",l.default.createElement(o.InlineJS,null,"path-to-regexp"),", you can provide them with a"," ",l.default.createElement(o.InlineJS,null,"pathOptions")," object."),l.default.createElement(u.Note,null,"If a route has a children array property, it will"," ",l.default.createElement("strong",null,"always")," have the ",l.default.createElement(o.InlineJS,null,"end")," path option set to false.")))),l.default.createElement(i.Subsection,{title:"extra",id:"extra"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"If you have any additional properties that you want attached to a route, use the ",l.default.createElement(o.InlineJS,null,"extra")," property. You will be able to use"," ",l.default.createElement(o.InlineJS,null,"route.extra")," in any custom route interactions.")),l.default.createElement(c.CodeBlock,null,"const routes = [\n  {\n    name: 'A Route',\n    path: 'a-route',\n    extra: {\n      transition: 'fade'\n    }\n  },\n  {\n    name: 'B Route',\n    path: 'b-route',\n    extra: {\n      enter: 'slide-right'\n    }\n  }\n];")))),l.default.createElement(i.Section,{title:"Matching Routes",id:"matching-routes"},l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Whenever Curi receives a new location, it will determine which route has a ",l.default.createElement(o.InlineJS,null,"path")," that matches the new location's"," ",l.default.createElement(o.InlineJS,null,"pathname")," by walking over the route objects in the order that they are defined in the array. If a route has"," ",l.default.createElement(o.InlineJS,null,"children"),", those will be checked before moving to the route's nest sibling."),l.default.createElement("p",null,"We'll use this simple route setup to demonstrate how this works.")),l.default.createElement(c.CodeBlock,null,"const routes = [\n  {\n    name: 'Home',\n    path: '',\n  },\n  {\n    name: 'Album',\n    path: 'a/:album'\n  },\n  {\n    name: 'Not Found',\n    path: '(.*)' // this matches EVERY pathname\n  }\n];")),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"Curi's default matching behavior looks for exact matches. This means that when the route only matches part of the pathname, it does not count as a match. If the user navigates to a location with the pathname ",l.default.createElement(o.InlineJS,null,'"/a/red/yellow"'),", the ",l.default.createElement(o.InlineJS,null,"Album")," route will only partially match, so Curi will move on to the next route,"," ",l.default.createElement(o.InlineJS,null,"Not Found"),", which has a catch all ",l.default.createElement(o.InlineJS,null,"path")," that matches every pathname."),l.default.createElement("p",null,"If a route has children, Curi will check if any of those routes form a complete match before moving on to the next route in the routes array.")),l.default.createElement(c.CodeBlock,null,"// when the pathname is '/a/Coloring+Book/All+Night',\n// the Album route will partially match the pathname.\n// Then, its child route Song will be tested and fully\n// match the pathname.\n{\n  name: 'Album',\n  path: 'a/:album',\n  children: [\n    {\n      name: 'Song',\n      path: ':title'\n    }\n  ]\n}")),l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"You can control whether a route does exact or partial matching with"," ",l.default.createElement(a.Link,{hash:"pathOptions"},l.default.createElement(o.InlineJS,null,"pathOptions"))," ","property. If you set ",l.default.createElement(o.InlineJS,null,"{ end: false }"),", a route that partially matches will consider itself matched.")),l.default.createElement(c.CodeBlock,null,"// when the pathname is\n// '/a/Good+Kid,+M.A.A.D+City/Poetic+Justice',\n// the Album route will partially match, but because\n// it sets \"end\" to false, the partial match will still be used.\n{\n  name: 'Album',\n  path: 'a/:albumID',\n  pathOptions: {\n    end: false\n  }\n}")),l.default.createElement(i.Subsection,{title:"No Matching Route",id:"catch-all"},l.default.createElement(u.Warning,null,l.default.createElement(c.SideBySide,null,l.default.createElement(c.Explanation,null,l.default.createElement("p",null,"If none of your routes match a location, Curi will do nothing! You need to set a catch-all route to match these locations yourself. The best way to do this is to add a route to the end of your routes array with a ",l.default.createElement(o.InlineJS,null,"path")," of ",l.default.createElement(o.InlineJS,null,'"(.*)"'),", which will match every pathname.")),l.default.createElement(c.CodeBlock,null,"{\n  name: 'Not Found',\n  path: '(.*)',\n}"))))),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Now that you know how to setup your routes, we will take a look at"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"responses"}},"responses"),".")))}},121:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=c(n(0)),a=n(1),r=c(n(60)),o=n(2),u=n(57),i=(n(10),n(4));function c(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"There are a few concepts that you should know about Curi."),l.default.createElement(u.Section,{title:"The Router",id:"router-object"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"A router is created using a ",l.default.createElement(o.InlineJS,null,"history")," object and a"," ",l.default.createElement(o.InlineJS,null,"routes")," array."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"history")," object controls navigation between locations within an application."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"routes")," array defines how the application renders for different locations.")),l.default.createElement(i.CodeBlock,null,'import curi from "@curi/core";\n\nconst history = Browser();\nconst routes = [...];\nconst router = curi(history, routes);'))),l.default.createElement(u.Section,{title:"History",id:"history-object"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"There are three kinds of histories:"),l.default.createElement("ol",null,l.default.createElement("li",null,l.default.createElement(o.InlineJS,null,"browser")," is the go to history for running an application in the browser."),l.default.createElement("li",null,l.default.createElement(o.InlineJS,null,"hash")," is a fallback browser history for applications served from static file hosts."),l.default.createElement("li",null,l.default.createElement(o.InlineJS,null,"in-memory")," is used outside of the browser. For example, on the server or in a React Native app."))),l.default.createElement(i.CodeBlock,null,'import Browser from "@hickory/browser";\nconst browserHistory = Browser();\n\nimport Hash from "@hickory/hash";\nconst hashHistory = Hash();\n\nimport InMemory from "@hickory/in-memory";\nconst inMemoryHistory = InMemory();')),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"history")," object will map URLs into location objects."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"query")," is a string by default, but the history object can be setup to automatically parse it into an object."),l.default.createElement("p",null,"Only the ",l.default.createElement(o.InlineJS,null,"pathname")," will be used for route matching.")),l.default.createElement(i.CodeBlock,null,'// www.example.com/page?key=value#trending\nlocation = {\n  pathname: "/page",\n  query: { key: "value" }\n  hash: "trending"\n}'))),l.default.createElement(u.Section,{title:"Routes",id:"routes-array"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"routes")," is an array of route objects. Each route has a unique ",l.default.createElement(o.InlineJS,null,"name")," and a ",l.default.createElement(o.InlineJS,null,"path")," that describes what locations to match."),l.default.createElement("p",null,l.default.createElement("strong",null,"Note:")," ",l.default.createElement(o.InlineJS,null,"path")," strings do not include a leading slash."),l.default.createElement("p",null,"Routes can be nested. A child route's ",l.default.createElement(o.InlineJS,null,"path")," will build on the paths from any ancestor routes."),l.default.createElement("p",null,'The "Not Found" route\'s ',l.default.createElement(o.InlineJS,null,"path")," matches every location, so it is included after all other routes to render a 404 page."),l.default.createElement("p",null,"Route names and params are what will be used for navigation within the app. URLs can be annoying to write, so Curi will handle this for you. All you have to know is the name of the route to navigate to. This also prevents you from navigating to a route that doesn't exist (although it doesn't prevent a user from manually navigating to a route that doesn't exist, which is why the \"Not Found\" route is important).")),l.default.createElement(i.CodeBlock,null,'const routes = [\n  {\n    name: "Home",\n    path: ""\n  },\n  {\n    name: "Album",\n    path: "photos/:albumID",\n    children: [\n      // matches /photos/6789/12345\n      {\n        name: "Photo",\n        path: ":photoID"\n      }\n    ]\n  },\n  {\n    name: "Not Found",\n    path: "(.*)"\n  }\n];'))),l.default.createElement(u.Section,{title:"Responses",id:"response-object"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"When Curi receives a location, it compares the location's"," ",l.default.createElement(o.InlineJS,null,"pathname")," to each route's ",l.default.createElement(o.InlineJS,null,"path")," to find which one matches best and uses that route to create a response object."),l.default.createElement("p",null,"Some of a response's properties are set based on the matched route, while others are set by the matched route's ",l.default.createElement(o.InlineJS,null,"response()")," ","function."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"body")," is the most important property because it is what the application will render (e.g. a React or Vue component).")),l.default.createElement(i.CodeBlock,null,"response = {\n  // match properties\n  name: 'Photo',\n  partials: ['Album'],\n  params: { photoID: 12345, albumID: 6789 },\n  location: {\n    pathname: '/photos/6789/12345',\n    ...\n  },\n\n  // set by matched route's response() function\n  body: function Photo() {...},\n  status: 200,\n  data: {...},\n  title: 'Photo 12345',\n  error: undefined\n}"))),l.default.createElement(u.Section,{title:"Navigation",id:"navigation"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"The router receives locations from its ",l.default.createElement(o.InlineJS,null,"history")," object. This either happens from in-app navigation (e.g. clicking a link) or browser navigation (e.g. click the back button or typing URL in the address bar and hitting enter)."),l.default.createElement("p",null,"The router has a ",l.default.createElement(o.InlineJS,null,"navigate()")," method that navigates using the ",l.default.createElement(o.InlineJS,null,"name")," of the route you want to navigate to and any route ",l.default.createElement(o.InlineJS,null,"params"),". The navigation ",l.default.createElement(o.InlineJS,null,"method")," controls how the history session is updated, with the default behavior acting like clicking a link.")),l.default.createElement(i.CodeBlock,null,'router.navigate({\n  name: "Photo",\n  params: { albumID: 1357, photoID: 02468 },\n  hash: "comments"\n});\n// /photos/1357/02468#comments\n\nrouter.navigate({\n  name: "Login",\n  state: { next: location.pathname },\n  method: "REPLACE"\n});'))),l.default.createElement(u.Section,{title:"Setting Response Properties",id:"route-response"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Each route can have a ",l.default.createElement(o.InlineJS,null,"response")," function for adding properties to a response when that route matches the location."),l.default.createElement("p",null,"The function receives an object with the ",l.default.createElement(o.InlineJS,null,"match")," properties of the response."),l.default.createElement("p",null,"The argument object also has a ",l.default.createElement(o.InlineJS,null,"resolved")," property to access any asynchronously resolve data from the matched routes"," ",l.default.createElement(o.InlineJS,null,"on.initial()")," and ",l.default.createElement(o.InlineJS,null,"on.every()")," functions.")),l.default.createElement(i.CodeBlock,null,'import User from "./components/User";\nconst routes = [\n  {\n    name: "User",\n    path: "",\n    response({ match, resolved }) {\n      return {\n        body: User,\n        title: `User ${match.params.id}`\n      };\n    }\n  }\n];'))),l.default.createElement(u.Section,{title:"Async Routes",id:"async-route"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"A route can have functions that will be called when a route matches. These are grouped under the ",l.default.createElement(o.InlineJS,null,"on")," property."),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"on.initial()")," will be run the first time a route matches and its return value will be re-used on subsequent matches. This is ideal for code splitting."),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"on.every()")," is run every time a route matches, so data that varies based on route params can be loaded here."),l.default.createElement("p",null,"Both of these methods receive the matched route properties of a response and are expected to return a Promise."),l.default.createElement("p",null,"If either function has an uncaught error, it will be available in the route's ",l.default.createElement(o.InlineJS,null,"response()")," method as"," ",l.default.createElement(o.InlineJS,null,"resolved.error"),".")),l.default.createElement(i.CodeBlock,null,'const routes = [\n  {\n    name: "User",\n    path: "user/:id",\n    on: {\n      initial() => import("./components/User"),\n      every({ params })) => fetch(`api/user/${params.id}`)\n        .then(resp => JSON.parse(resp))\n    },\n    response({ resolved }) {\n      if (resolved.error) {\n        // handle the error\n      }\n      return {\n        body: resolved.initial,\n        data: resolved.every\n      }\n    }\n  }\n];'))),l.default.createElement(u.Section,{title:"Observers",id:"observer"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"When the router has created a response, it emits it to any observers. You can give the router an observer function through its"," ",l.default.createElement(o.InlineJS,null,"respond()")," method."),l.default.createElement("p",null,"You usually do not have to call this yourself. Framework implementations will set observers up internally to automatically trigger re-renders for new responses. ",l.default.createElement(o.InlineJS,null,"@curi/react")," does this using the ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," component and"," ",l.default.createElement(o.InlineJS,null,"@curi/vue")," uses the ",l.default.createElement(o.InlineJS,null,"CuriPlugin"),".")),l.default.createElement(i.CodeBlock,null,"const router = curi(history, routes);\n\n// { observe: true } sets up an observer function\n// to be called for every new response\nconst stop = router.respond(({ response }) => {\n  console.log('new response!', response);\n}, { observe: true });\n// ...\nstop();\n// no longer observing")),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"If you have any asynchronous routes (routes with"," ",l.default.createElement(o.InlineJS,null,"on.initial()")," or ",l.default.createElement(o.InlineJS,null,"on.every()")," functions),"," ",l.default.createElement(o.InlineJS,null,"router.respond()")," should be used to delay the initial render. If you don't pass the ",l.default.createElement(o.InlineJS,null,"{ observe: true }")," ","option, the observer function will only be called once, which is perfect for delaying the initial render.")),l.default.createElement(i.CodeBlock,null,"// wait for initial response to render with an\n// observer function that will only be called once\nrouter.respond(() => {\n  // safe to render async routes now\n});"))),l.default.createElement(u.Section,{title:"Rendering",id:"rendering"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"We've finally gotten to rendering. How this is done really varies based on how you are rendering, but the idea is always the same."),l.default.createElement("p",null,"When the app loads and whenever there is navigation in the app, a new response is created. The application will use the properties of this new response, especially ",l.default.createElement(o.InlineJS,null,"response.body"),", to render new content."))),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"@curi/react")," uses a ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," with a render-invoked ",l.default.createElement(o.InlineJS,null,"children")," prop that will be called whenever there is a new response."),l.default.createElement("p",null,"In React applications, ",l.default.createElement(o.InlineJS,null,"response.body")," should be a React component, so rendering the application means creating an element from ",l.default.createElement(o.InlineJS,null,"response.body"),"."),l.default.createElement("p",null,"The"," ",l.default.createElement(a.Link,{to:"Tutorial",params:{slug:"react-basics"}},"React Basics Tutorial")," ","gets into more detail about how this works.")),l.default.createElement(i.CodeBlock,null,"// React\nReactDOM.render((\n  <CuriProvider router={router}>\n    {({ response }) => {\n      const { body:Body } = response;\n      return <Body />;\n    }}\n  </CuriProvider>\n), document.getElementById('root'));")),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"@curi/vue")," sets up reactive objects that update when there is a new response. ",l.default.createElement(o.InlineComponent,null,"component :is")," can be used to render the ",l.default.createElement(o.InlineJS,null,"body")," component."),l.default.createElement("p",null,"The"," ",l.default.createElement(a.Link,{to:"Tutorial",params:{slug:"react-basics"}},"Vue Basics Tutorial")," ","details how to use Vue and Curi.")),l.default.createElement(i.CodeBlock,null,"// Vue\nVue.use(CuriPlugin, { router });\nnew Vue({\n  el: '#app',\n  template: '<app />',\n  components: { app }\n});\n")),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"@curi/svelte")," uses the Svelte store and"," ",l.default.createElement(o.InlineComponent,null,"svelte:component")," to render.")),l.default.createElement(i.CodeBlock,null,"// Svelte\nconst store = curiStore(router);\nnew app({ target, store });"))),l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Curi can match routes synchronously or asynchronously. The"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"sync-or-async"}},"Sync or Async Guide")," ","covers how this works and what it means for your application."))}},122:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=o(n(0)),a=o(n(15)),r=o(n(3));function o(e){return e&&e.__esModule?e:{default:e}}var u=function(e){var t=e.guides;return l.default.createElement("ul",{className:"link-list"},t.map(function(e){return l.default.createElement("li",{key:e.name,className:"solo"},l.default.createElement(r.default,{to:"Guide",params:{slug:e.slug}},e.name))}))};t.default=function(){var e=a.default.grouped();return l.default.createElement("ul",null,Object.keys(e).map(function(t){return l.default.createElement("li",{className:"link-group",key:t},l.default.createElement("h3",null,t),l.default.createElement(u,{guides:e[t]}))}))}},123:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=c(n(0)),a=n(1),r=c(n(60)),o=n(2),u=n(57),i=n(4);function c(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"The core Curi package to install is ",l.default.createElement(o.InlineJS,null,"@curi/core"),"."),l.default.createElement("p",null,"The router will also need a Hickory package (",l.default.createElement(o.InlineJS,null,"@hickory/browser"),", ",l.default.createElement(o.InlineJS,null,"@hickory/hash"),", or ",l.default.createElement(o.InlineJS,null,"@hickory/in-memory"),"). Which Hickory package you need depends on the application, but the browser package is best for most websites.")),l.default.createElement(i.CodeBlock,{lang:"bash"},"npm install @hickory/browser @curi/core")),l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"These packages can also be loaded from"," ",l.default.createElement("a",{href:"https://unpkg.com"},"Unpkg"),".")),l.default.createElement(i.CodeBlock,{lang:"markup"},'<script\n src="https://unpkg.com/@hickory/browser/dist/hickory-browser.min.js"\n><\/script>\n<script\n src="https://unpkg.com/@curi/core/dist/curi.min.js"\n><\/script>')),l.default.createElement(u.Section,{title:"Promises",id:"promises"},l.default.createElement(i.SideBySide,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Curi uses Promises, so you may need to include a polyfill to add Promise support for older browsers (including IE 11)."),l.default.createElement("p",null,"If you need a general ES2015 polyfill, you can check out the one provided by Babel's"," ",l.default.createElement("a",{href:"https://babeljs.io/docs/usage/polyfill/#usage-in-browser"},"babel-polyfill")," ","package. If you only need a Promise polyfill, then you should check out the"," ",l.default.createElement("a",{href:"https://github.com/stefanpenner/es6-promise"},"es6-promise")," ","package or ",l.default.createElement("a",{href:"https://polyfill.io/v2/docs/"},"polyfill.io"),".")))),l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,l.default.createElement(a.Link,{to:"Guide",params:{slug:"getting-started"}},"Get started")," ","with Curi."))}},124:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=g(n(123)),a=g(n(121)),r=g(n(120)),o=g(n(119)),u=g(n(118)),i=g(n(117)),c=g(n(116)),d=g(n(115)),s=g(n(114)),m=g(n(113)),f=g(n(112)),p=g(n(111)),h=g(n(110)),E=g(n(109)),y=g(n(108));function g(e){return e&&e.__esModule?e:{default:e}}var S={installation:l.default,"getting-started":a.default,"sync-or-async":y.default,routes:r.default,observers:o.default,responses:u.default,"navigation-objects":i.default,"route-interactions":c.default,"side-effects":d.default,"code-splitting":s.default,loading:m.default,"react-native":f.default,apollo:p.default,"migrate-rrv3":h.default,"migrate-rrv4":E.default};t.default=S},55:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=r(n(0)),a=r(n(124));function r(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.params,n=e.data;if(!n)return l.default.createElement("div",null,"The requested guide could not be found.");var r=a.default[t.slug];return l.default.createElement(r,{name:n.name})}},57:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Subsection=t.Section=void 0;var l,a=(l=n(0))&&l.__esModule?l:{default:l},r=n(1);function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var l in n)Object.prototype.hasOwnProperty.call(n,l)&&(e[l]=n[l])}return e}).apply(this,arguments)}function u(e,t){if(null==e)return{};var n,l,a={},r=Object.keys(e);for(l=0;l<r.length;l++)n=r[l],t.indexOf(n)>=0||(a[n]=e[n]);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(l=0;l<o.length;l++)n=o[l],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=function(e){var t=e.title,n=e.id,l=e.children,o=e.tag,u=e.type,i=void 0===u?"section":u;return a.default.createElement("div",{className:i,id:n},a.default.createElement(o,null,t,a.default.createElement(r.Link,{className:"header-link",hash:n},"#")),l)};t.Section=function(e){var t=e.tag,n=void 0===t?"h2":t,l=u(e,["tag"]);return a.default.createElement(i,o({type:"section",tag:n},l))};t.Subsection=function(e){var t=e.tag,n=void 0===t?"h3":t,l=u(e,["tag"]);return a.default.createElement(i,o({type:"subsection",tag:n},l))}},60:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=i(n(0)),a=i(n(122)),r=i(n(7)),o=i(n(6)),u=i(n(5));function i(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.children;return l.default.createElement(r.default,{type:"guide"},l.default.createElement(u.default,null,t||null),l.default.createElement(o.default,null,l.default.createElement("h2",null,"Guides"),l.default.createElement(a.default,null)))}}}]);