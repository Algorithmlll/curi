(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{134:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"React Router v4 isn't like most other routers because it lacks a centralized configuration. Migrating to Curi mostly involves re-centralizing your routes to simplify route management.")),a.default.createElement(i.Section,{title:"Routes",id:"routes"},a.default.createElement("p",null,"Let’s get started with setting up our routes."),a.default.createElement(i.Subsection,{title:"With React Router",id:"routes-with-react-router"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"With React Router v4, ",a.default.createElement(r.InlineComponent,null,"Route"),"s are defined in components. They are usually grouped together under a ",a.default.createElement(r.InlineComponent,null,"Switch")," so that only a single route from a group renders. Nested routes are rendered inside of the compnent rendered by the parent"," ",a.default.createElement(r.InlineComponent,null,"Route"))),a.default.createElement(s.CodeBlock,{lang:"jsx"},'import { Route, Switch } from "react-router-dom";\n            \nconst App = () => (\n  <Switch>\n    <Route exact path="/" component={Home} />\n    <Route path="/inbox" component={Inbox} />\n  </Switch>                 \n);\n\n// the <Inbox> matches nested routes (and includes\n// a <Route> for "exact" /inbox matches)\nconst Inbox = ({ match }) => (\n  <Switch>\n    <Route\n      exact\n      path={match.path}\n      component={Messages}\n    />\n    <Route\n      exact\n      path={`${match.path}/:message`}\n      component={Message}\n    />\n  </Switch>\n);')),a.default.createElement(i.Subsection,{title:"With Curi",id:"routes-with-curi"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,'Routes in Curi are JavaScript objects. They are grouped together in an array of "top-level" routes. Nested routes are grouped under their parent route\'s ',a.default.createElement(r.InlineJS,null,"children")," property."),a.default.createElement("p",null,"First, we will define the names and paths for our routes."),a.default.createElement("p",null,"Each route must have a unique name. A route's name will be used for interacting with it. For example, to navigate to a route, you only have to know its name, not its URL."),a.default.createElement("p",null,"The biggest difference between the Curi paths and the React Router paths is that with Curi, you never include a forward slash at the beginning of the path. This means that while the root path for React Router is ",a.default.createElement(r.InlineJS,null,"'/'"),", the root path for Curi is"," ",a.default.createElement(r.InlineJS,null,"''"),".")),a.default.createElement(s.CodeBlock,null,"const routes = [\n  {\n    name: 'Home',\n    path: ''\n  },\n  {\n    name: 'Inbox',\n    path: 'inbox',\n    children: [\n      {\n        name: 'Message',\n        path: ':message'\n      }\n    ]\n  }\n];"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Next, we should add our components to each route."),a.default.createElement("p",null,"Curi routes can have a ",a.default.createElement(r.InlineJS,null,"response()")," property, which is a function that returns an object of properties to merge onto the response that we will be using to render. For this React application, we want a response's ",a.default.createElement(r.InlineJS,null,"body")," property to be the React component associated with each route.")),a.default.createElement(s.CodeBlock,null,"import Home from './pages/Home';\nimport Inbox from './pages/Inbox';\nimport Mesage from './pages/Message';\n\nconst routes = [\n  {\n    name: 'Home',\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    name: 'Inbox',\n    path: 'inbox',\n    response: () => {\n      return {\n        body: Inbox\n      };\n    },\n    children: [\n      {\n        name: 'Message',\n        path: ':message',\n        response: () => {\n          return {\n            body: Message\n          };\n        }\n      }\n    ]\n  }\n];"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"With React Router v4, a component's lifecycle methods are used for loading data, code splitting, and other non-rendering tasks. With Curi, routes can have functions that are called when they match the new location. These are grouped under the route's"," ",a.default.createElement(r.InlineJS,null,"resolve")," object. The ",a.default.createElement(r.InlineJS,null,"resolve")," functions are called every time that a route matches a location."),a.default.createElement("p",null,"The"," ",a.default.createElement(o.Link,{to:"Package",params:{package:"router"},hash:"route-properties"},a.default.createElement(r.InlineJS,null,"@curi/router")," route API documentation")," ","covers all of the route properties.")),a.default.createElement(s.CodeBlock,null,"const routes = [\n  {\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    path: 'inbox',\n    response: () => {\n      return {\n        body: Inbox\n      };\n    },\n    children: [\n      {\n        path: ':message',\n        response: () => {\n          return {\n            body: Message\n          };\n        },\n        resolve: {\n          body: (route) => { return ... },\n        }\n      }\n    ]\n  }\n];")),a.default.createElement("p",null,"Once your routes have been defined, you can move on to creating your Curi router.")),a.default.createElement(i.Section,{title:"Creating the router",id:"creating-the-router"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"With React Router, you create your router by rendering a"," ",a.default.createElement(r.InlineComponent,null,"Router")," component. This may be a ",a.default.createElement(r.InlineComponent,null,"BrowserRouter"),", a ",a.default.createElement(r.InlineComponent,null,"HashRouter"),", a ",a.default.createElement(r.InlineComponent,null,"MemoryRouter"),", or a plain"," ",a.default.createElement(r.InlineComponent,null,"Router")," that you pass your own ",a.default.createElement(r.InlineJS,null,"history")," instance to. The ",a.default.createElement(r.InlineComponent,null,"___Router")," components create a ",a.default.createElement(r.InlineJS,null,"history")," ","instance for you using props passed to the component.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"import { BrowserRouter } from 'react-router-dom';\n\nReactDOM.render((\n  <BrowserRouter>\n    <App />\n  </BrowserRouter>\n), holder);"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"With Curi, the router is created prior to rendering. It takes a Hickory history object, your routes array, and possibly an options object. ",a.default.createElement("a",{href:"https://github.com/pshrmn/hickory"},"Hickory")," is similar to the ",a.default.createElement(r.InlineJS,null,"history")," package used by React Router, but has a slight modified API (easier navigation blocking and navigation that imitates how anchors work) and more convenient location objects (you can use a ",a.default.createElement(r.InlineJS,null,"query")," object instead of having to manually create a ",a.default.createElement(r.InlineJS,null,"search")," string).")),a.default.createElement(s.CodeBlock,null,"import { curi } from '@curi/router';\nimport Browser from '@hickory/browser';\nconst history = Browser();\nconst routes = [...];\nconst router = curi(history, routes);")),a.default.createElement(i.Section,{title:"Rendering",id:"rendering"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"We will walk through the rendering differences between React Router and Curi by looking at what happens in each when we navigate to the URL with the pathname ",a.default.createElement(r.InlineJS,null,"/inbox/test-message-please-ignore"),".")),a.default.createElement(i.Subsection,{title:"React Router",id:"rendering-react-router"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"React Router matches routes while it renders. It uses the"," ",a.default.createElement(r.InlineComponent,null,"Router")," component to listen for location changes. Each time that the location changes, the application re-renders."),a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Switch")," will iterate over its children"," ",a.default.createElement(r.InlineComponent,null,"Route"),"s. The first route, ",a.default.createElement(r.InlineJS,null,'"/"')," has an"," ",a.default.createElement(r.InlineJS,null,"exact")," prop, so it only matches when the pathname is"," ",a.default.createElement(r.InlineJS,null,'"/"'),". Since it is not, the next ",a.default.createElement(r.InlineComponent,null,"Route")," will be checked. The next route, ",a.default.createElement(r.InlineJS,null,'"/inbox"')," matches the beginning of the pathname ",a.default.createElement(r.InlineJS,null,'"/inbox/test-message-please-ignore"'),". It is not an exact match, but that route does not do exact matching, so React Router will render its component, ",a.default.createElement(r.InlineComponent,null,"Inbox"),"."),a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Inbox")," has its own ",a.default.createElement(r.InlineComponent,null,"Switch")," to iterate over. Its first route only matches ",a.default.createElement(r.InlineJS,null,'"/inbox"')," exactly, so it moves on to the next route, which has a ",a.default.createElement(r.InlineJS,null,"message")," ","route param. This route matches and stores"," ",a.default.createElement(r.InlineJS,null,'"test-message-please-ignore"')," as"," ",a.default.createElement(r.InlineJS,null,"match.params.message"),". The ",a.default.createElement(r.InlineComponent,null,"Message")," component will then be rendered, which has access to the ",a.default.createElement(r.InlineJS,null,"message")," ","param.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},'ReactDOM.render((\n  <BrowserRouter>\n    <App />\n  </BrowserRouter>\n), holder);\n\nconst App = () => (\n  <Switch>\n    <Route exact path="/" component={Home} />\n    <Route path="/inbox" component={Inbox} />\n  </Switch>                 \n);\n\nconst Inbox = ({ match }) => (\n  <Switch>\n    <Route\n      exact\n      path={match.path}\n      component={Messages}\n    />\n    <Route\n      exact\n      path={`${match.path}/:message`}\n      component={Message}\n    />\n  </Switch>\n);\n\n/*\n<BrowserRouter>\n  <App>\n    <Inbox>\n      <Message>\n    </Inbox>\n  </App>\n</BrowserRouter>\n*/')),a.default.createElement(i.Subsection,{title:"Curi",id:"rendering-with-curi"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"With Curi, we also need to re-render our application every time that the location changes. We will do this by creating a root Curi component by calling the ",a.default.createElement(r.InlineJS,null,"curiProvider()")," function, which comes from the ",a.default.createElement(r.InlineJS,null,"@curi/react-dom")," package, and passing it our Curi router. While the name of this component is entirely up to you, we will refer to it as the ",a.default.createElement(r.InlineComponent,null,"Router")," here."),a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Router")," will setup an observer on the provided router so that it can re-render your application whenever there is a new ",a.default.createElement(r.InlineJS,null,"response"),". The ",a.default.createElement(r.InlineComponent,null,"Router")," expects a function as its ",a.default.createElement(r.InlineJS,null,"children")," prop (a render-invoked function). This function renders the application using the"," ",a.default.createElement(r.InlineJS,null,"response"),"."),a.default.createElement("p",null,"When the ",a.default.createElement(r.InlineComponent,null,"Router"),"'s ",a.default.createElement(r.InlineJS,null,"children()")," function is called, it will receive an object with three properties:"),a.default.createElement("ol",null,a.default.createElement("li",null,a.default.createElement(r.InlineJS,null,"response")," is the new response object"),a.default.createElement("li",null,a.default.createElement(r.InlineJS,null,"navigation")," is an object with additional information about the navigation"),a.default.createElement("li",null,a.default.createElement(r.InlineJS,null,"router")," is your Curi router (mostly useful if the function is defined in a separate file)")),a.default.createElement("p",null,"Above, we added ",a.default.createElement(r.InlineJS,null,"response()")," functions to each route. The functions set React components as the ",a.default.createElement(r.InlineJS,null,"body")," property of responses. We can now use ",a.default.createElement(r.InlineJS,null,"response.body")," to render those components."),a.default.createElement("p",null,"In the React Router section, we had three components that were rendered: ",a.default.createElement(r.InlineComponent,null,"App"),",",a.default.createElement(r.InlineComponent,null,"Inbox"),", and ",a.default.createElement(r.InlineComponent,null,"Message"),". With Curi, only the most accurately matched route actually matches. That means that for the URL ",a.default.createElement(r.InlineJS,null,"/inbox/test-message-please-ignore"),", the"," ",a.default.createElement(r.InlineJS,null,'"Message"')," route will match, but its parent route,"," ",a.default.createElement(r.InlineJS,null,'"Inbox"')," will not, so ",a.default.createElement(r.InlineJS,null,"response.body")," will be the ",a.default.createElement(r.InlineComponent,null,"Message")," component. Unlike React Router, we don’t render ",a.default.createElement(r.InlineComponent,null,"Inbox")," because we did not match the"," ",a.default.createElement(r.InlineJS,null,"inbox")," route.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},'import { curiProvider } from "@curi/react-dom";\n\nconst router = curi(history, routes);            \nconst Router = curiProvider(router);\n\nReactDOM.render((\n  <Router>\n    {({ response }) => {\n      const { body:Body } = response;\n      return <Body />;\n    }}\n  </Router>\n), holder);\n\n/*\n  <Router>\n    <Message />\n  </Router>\n*/'),a.default.createElement(s.Explanation,null,a.default.createElement(u.Note,null,"Wildcard routes (",a.default.createElement(r.InlineJS,null,"{ path: '(.*)' }"),") can be used to easily display a not found page for any location not matched by other routes.")),a.default.createElement(s.CodeBlock,null,'const routes = [\n  // ...,\n  {\n    name: "Not Found",\n    path: "(.*)",\n    response() {\n      return { body: NotFound };\n    }\n  }\n];'),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"It was mentioned above that there is no need for the"," ",a.default.createElement(r.InlineComponent,null,"App")," component with Curi. If you want to have an"," ",a.default.createElement(r.InlineComponent,null,"App")," component, you can render it either inside of the"," ",a.default.createElement(r.InlineJS,null,"children()")," function or as a parent of your"," ",a.default.createElement(r.InlineComponent,null,"Router"),". This can be useful for rendering content that is unrelated to specific routes, like a page header or menu."),a.default.createElement("p",null,"Rendering the ",a.default.createElement(r.InlineComponent,null,"App")," inside of the ",a.default.createElement(r.InlineJS,null,"children()")," ","function is necessary if any of the components rendered by the"," ",a.default.createElement(r.InlineComponent,null,"App")," are location aware components, since they need to access the Curi router (through React’s context, which the"," ",a.default.createElement(r.InlineComponent,null,"Router")," provides)")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"function render({ response }) {\n  const { body:Body } = response;\n  return (\n    <App>\n      <Body />\n    </App>\n  );\n}\n// or\nfunction render({ response }) {\n  const { body:Body } = response;\n  return (\n    <div>\n      <Header />\n      <Body />\n      <Footer />\n    </div>\n  );\n}"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"What about props that you want to send to your route components? Pass them to the ",a.default.createElement(r.InlineComponent,null,"Body")," component that you render. Props can be passed individually, but passing the whole"," ",a.default.createElement(r.InlineJS,null,"response")," object is recommended.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"function render({ response }) {\n  const { body:Body } = response;\n  return <Body response={response} />;\n}"))),a.default.createElement(i.Section,{title:"Links",id:"links"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"You will want to be able to navigate between routes in your application. React Router provides a ",a.default.createElement(r.InlineComponent,null,"Link")," component to do this, and so does Curi (through the ",a.default.createElement(r.InlineJS,null,"@curi/react-dom")," ","package). There are a few differences to note between these two components:")),a.default.createElement("ul",null,a.default.createElement("li",null,a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"React Router expects you to generate the pathname yourself, while Curi expects you to pass the name of the route that you want to navigate to. Any path parameters are passed to Curi’s"," ",a.default.createElement(r.InlineComponent,null,"Link")," using the ",a.default.createElement(r.InlineJS,null,"params")," prop.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"// React Router\n<Link to='/'>Home</Link>\n<Link to={`/inbox/${message}`}>Hello</Link>\n\n// Curi\n<Link to='Home'>Home</Link>\n<Link to='Message' params={{ message }}>Hello</Link>")),a.default.createElement("li",null,a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"With React Router, any additional location properties are passed to the ",a.default.createElement(r.InlineComponent,null,"Link")," using the ",a.default.createElement(r.InlineJS,null,"to")," object. With Curi, these properties are passed using the prop name (",a.default.createElement(r.InlineJS,null,"hash"),", ",a.default.createElement(r.InlineJS,null,"query")," &",a.default.createElement(r.InlineJS,null,"state"),").")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"// React Router\n<Link to={{ pathname: '/inbox', hash: '#test' }}>\n  Inbox\n</Link>\n\n// Curi\n<Link to='Inbox' hash='test'>Inbox</Link>")),a.default.createElement("li",null,a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Active detection with Curi uses an ",a.default.createElement(r.InlineComponent,null,"Active")," component."," ",a.default.createElement(r.InlineComponent,null,"Active"),"'s ",a.default.createElement(r.InlineJS,null,"children")," prop is a render-invoked function that receives a boolean ",a.default.createElement(r.InlineJS,null,"true")," when the named route is active and ",a.default.createElement(r.InlineJS,null,"false")," when it is not. You can also pass ",a.default.createElement(r.InlineJS,null,"partial={true}")," to partial matches (ancestor routes) be considered active (the opposite of React Router's ",a.default.createElement(r.InlineJS,null,"onlyActiveOnIndex"),").")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"// React Router\n<Link\n  to='/'\n  onlyActiveOnIndex\n  activeClassName='active'\n>\n  Home\n</Link>\n\n// Curi\n// You need to add @curi/route-active\n// to your router object\nimport active from '@curi/route-active';\nconst router = curi(history, routes, {\n  route: [active()]\n});\n\n// The <Active> component determines if a route is active\n// and passes true/false to the render-invoked children\n// function\n<Active name=\"Home\">\n  {active => (\n    <Link\n      to='Home'\n      className={active ? \"active\" : \"\"}\n    >Home</Link>\n  )}\n</Active>")))),a.default.createElement(i.Section,{title:"Accessing router props from nested components",id:"router-props"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"React Router provides a ",a.default.createElement(r.InlineJS,null,"withRouter")," higher-order component that will inject router props into the wrapped component."),a.default.createElement("p",null,"Curi provides similar functionality with the ",a.default.createElement(r.InlineJS,null,"Curious")," ","component."),a.default.createElement("p",null,a.default.createElement(r.InlineJS,null,"Curious")," has a render-invoked ",a.default.createElement(r.InlineJS,null,"children")," ","function, which you can use to inject the Curi ",a.default.createElement(r.InlineJS,null,"router"),", the current ",a.default.createElement(r.InlineJS,null,"response"),", and the current"," ",a.default.createElement(r.InlineJS,null,"navigation")," object into components.")),a.default.createElement(s.CodeBlock,null,"// React Router\nexport default withRouter(SomeComponent);\n\n// Curi\nexport default () => (\n  <Curious>\n    {({ response }) => (\n      <SomeComponent response={response} />\n    )}\n  </Curious>\n);")),a.default.createElement("p",null,"At this point, hopefully you are comfortable with migrating from React Router v4 to Curi. If there are any concepts not covered here that you think should be, please feel free to open up an issue"," ",a.default.createElement("a",{href:"https://github.com/pshrmn/curi/issues"},"on GitHub"),"."))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=n(1),r=n(5),u=n(9),i=n(76),s=n(6)},135:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Curi is mostly conceptually similar to React Router versions 2 and 3."),a.default.createElement("ol",null,a.default.createElement("li",null,"Both use a centralized router."),a.default.createElement("li",null,"Both routers are made up of route objects (although with React Router some of these are disguised as JSX with ",a.default.createElement(r.InlineComponent,null,"Route")," ","components)."),a.default.createElement("li",null,"With both Reaft Router and Curi, routes can be nested. This can be used to specify child routes that build off of the paths from their parent routes.")),a.default.createElement("p",null,"Migration from React Router v2/3 to Curi should not require a complete reworking of your application, but there are some key differences."),a.default.createElement("ol",null,a.default.createElement("li",null,"Curi's routing is handled entirely outside of React; there are no"," ",a.default.createElement(r.InlineComponent,null,"Route")," components."),a.default.createElement("li",null,"With Curi, when a nested route matches, only that route renders. Any ancestor routes that also (partially) match are not rendered. This is different from React Router, where ancestors of the best matched route also render."))),a.default.createElement(i.Section,{title:"Routes",id:"routes"},a.default.createElement("p",null,"Let’s get started with setting up our routes."),a.default.createElement(i.Subsection,{title:"With React Router",id:"routes-with-react-router"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"In React Router v2/3, there are two ways to define routes. You can either use JavaScript objects or JSX ",a.default.createElement(r.InlineComponent,null,"Route"),"s (which React Router converts to JavaScript objects)."),a.default.createElement("p",null,"Both styles described above define the same route structure for three routes: ",a.default.createElement(r.InlineJS,null,"/"),", ",a.default.createElement(r.InlineJS,null,"/inbox"),", and"," ",a.default.createElement(r.InlineJS,null,"/inbox/:message"),". Each one of these has a component that will be rendered when it matches. The ",a.default.createElement(r.InlineJS,null,"/inbox/:message")," ","route has some methods defined to describe its behavior when the route enters, updates, and leaves.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"// JavaScript objects\n{\n  path: '/',\n  component: App,\n  indexRoute: Home,\n  childRoutes: [\n    {\n      path: 'inbox',\n      component: Inbox,\n      childRoutes: [\n        {\n          path: ':message',\n          component: Message,\n          onEnter: (next) => {...},\n          onChange: (prev, next) => {...},\n          onLeave: (prev) => {...}\n        }\n      ]\n    }\n  ]\n// JSX\n<Route path='/' component={App}>\n  <IndexRoute component={Home} />\n  <Route path='inbox' component={Inbox}>\n    <Route\n      path=':message'\n      component={Message}\n      onEnter={next => {...}}\n      onChange={(prev, next) => {...}}\n      onLeave={prev => {...}}\n    />\n  </Route>\n</Route>")),a.default.createElement(i.Subsection,{title:"With Curi",id:"routes-with-curi"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Routes in Curi are always JavaScript objects. Like React Router, each route object has a path property that describes the path segments that the route matches. React Router v2/3 uses a custom path matcher, but Curi uses ",a.default.createElement(r.InlineJS,null,"path-to-regexp"),". You can read learn how to format paths from the"," ",a.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp"},a.default.createElement(r.InlineJS,null,"path-to-regexp")," repo"),"."),a.default.createElement("p",null,"First, we will define the names and paths for our routes."),a.default.createElement("p",null,"Each route must also have a unique name. A route's name will be used for interacting with it. For example, to navigate to a route, you only have to know its name, not its URL."),a.default.createElement("p",null,"The biggest difference between the Curi paths and the React Router paths is that with Curi, you never include a forward slash at the beginning of the path. This means that while the root path for React Router is ",a.default.createElement(r.InlineJS,null,"'/'"),", the root path for Curi is"," ",a.default.createElement(r.InlineJS,null,"''"),".")),a.default.createElement(s.CodeBlock,null,"const routes = [\n  {\n    name: 'Home',\n    path: ''\n  },\n  {\n    name: 'Inbox',\n    path: 'inbox',\n    children: [\n      {\n        name: 'Message',\n        path: ':message'\n      }\n    ]\n  }\n];"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Next, we should add our components to each route. We will ignore the ",a.default.createElement(r.InlineComponent,null,"App")," component that is used in the React Router routes. That is not route specific and will be rendered by our application (assuming we actually need it)."),a.default.createElement("p",null,'With Curi, the router creates a "response" object when it matches locations. Some of the properties of the response are automatically set based on the location and the matching route. Others can be set by a route. This is done using the'," ",a.default.createElement(r.InlineJS,null,"response()")," property, which is a function that returns an object whose properties will be added to the response. For this React application, we want a response's ",a.default.createElement(r.InlineJS,null,"body")," property to be the React component associated with each route."),a.default.createElement(u.Note,null,"Only known properties will be merged onto the response.")),a.default.createElement(s.CodeBlock,null,"import Home from './pages/Home';\nimport Inbox from './pages/Inbox';\nimport Mesage from './pages/Message';\n\nconst routes = [\n  {\n    name: 'Home',\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    name: 'Inbox',\n    path: 'inbox',\n    response: () => {\n      return {\n        body: Inbox\n      };\n    },\n    children: [\n      {\n        name: 'Message',\n        path: ':message',\n        response: () => {\n          return {\n            body: Message\n          };\n        }\n      }\n    ]\n  }\n];"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"We are close to replicating our React Router routes, but we still need to implement the ",a.default.createElement(r.InlineJS,null,"on___")," methods for our ",a.default.createElement(r.InlineJS,null,":message")," ","route. With Curi, routes can have functions that are called when they match the new location. These are grouped under the route's"," ",a.default.createElement(r.InlineJS,null,"resolve")," object. The ",a.default.createElement(r.InlineJS,null,"resolve")," functions are called every time that a route matches a location."),a.default.createElement("p",null,"With React Router, ",a.default.createElement(r.InlineJS,null,"onEnter")," is called when the route first matches, while ",a.default.createElement(r.InlineJS,null,"onChange")," is called when the same route matches a new location (e.g. with new path parameters)."," ",a.default.createElement(r.InlineJS,null,"onEnter")," and ",a.default.createElement(r.InlineJS,null,"onChange")," are nearly the same; the big difference between the two is that ",a.default.createElement(r.InlineJS,null,"onChange")," ","will receive the previous props, which could be used to determine which props changed. The functionality for both ",a.default.createElement(r.InlineJS,null,"onEnter")," ","and ",a.default.createElement(r.InlineJS,null,"onChange")," can be covered using a ",a.default.createElement(r.InlineJS,null,"resolve")," ","function."),a.default.createElement("p",null,"There currently is no equivalent to ",a.default.createElement(r.InlineJS,null,"onLeave")," with Curi. This is mostly because I haven’t seen a compelling need for it. It certainly could be implemented, but so far I have not found a reason to use that. If you have something you need this functionality for, please open up an issue in the GitHub repo."),a.default.createElement("p",null,"The"," ",a.default.createElement(o.Link,{to:"Package",params:{package:"router"},hash:"route-properties"},a.default.createElement(r.InlineJS,null,"@curi/router")," route API documentation")," ","covers all of the route properties.")),a.default.createElement(s.CodeBlock,null,"const routes = [\n  {\n    name: 'Home',\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    name: 'Inbox',\n    path: 'inbox',\n    response: () => {\n      return {\n        body: Inbox\n      };\n    },\n    children: [\n      {\n        name: 'Message',\n        path: ':message',\n        response: () => {\n          return {\n            body: Message\n          };\n        },\n        resolve: {\n          data: (route) => { return ... },\n        }\n      }\n    ]\n  }\n];")),a.default.createElement("p",null,"Once your routes have been defined, you can move on to creating your Curi router.")),a.default.createElement(i.Section,{title:"Creating the router",id:"creating-the-router"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"With React Router, you create your router by rendering a"," ",a.default.createElement(r.InlineComponent,null,"Router"),". That either takes the ",a.default.createElement(r.InlineComponent,null,"Route")," components as props or the route objects through its ",a.default.createElement(r.InlineJS,null,"routes")," prop. The ",a.default.createElement(r.InlineComponent,null,"Router")," also takes a ",a.default.createElement(r.InlineJS,null,"history")," prop, which is either one of the pre-routerured objects (",a.default.createElement(r.InlineJS,null,"browserHistory")," ","or ",a.default.createElement(r.InlineJS,null,"hashHistory"),") or one that you create yourself.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"import { Router, browserHistory } from 'react-router';\nconst routes = [...];\nReactDOM.render((\n  <Router history={browserHistory} routes={routes} />\n), holder);"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"With Curi, the router is created prior to rendering. It takes a Hickory history object, your routes array, and possibly an options object. ",a.default.createElement("a",{href:"https://github.com/pshrmn/hickory"},"Hickory")," is similar to the ",a.default.createElement(r.InlineJS,null,"history")," package used by React Router, but has a slight modified API (easier navigation blocking and navigation that imitates how anchors work) and more convenient location objects (you can use a ",a.default.createElement(r.InlineJS,null,"query")," object instead of having to manually create a ",a.default.createElement(r.InlineJS,null,"search")," string).")),a.default.createElement(s.CodeBlock,null,"import { curi } from '@curi/router';\nimport Browser from '@hickory/browser';\nconst history = Browser();\nconst routes = [...];\nconst router = curi(history, routes);")),a.default.createElement(i.Section,{title:"Rendering",id:"rendering"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"We will walk through the rendering differences between React Router and Curi by looking at what happens in each when we navigate to the URI ",a.default.createElement(r.InlineJS,null,"/inbox/test-message-please-ignore"),".")),a.default.createElement(i.Subsection,{title:"React Router v2/3",id:"rendering-react-router"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"React Router uses the ",a.default.createElement(r.InlineComponent,null,"Router")," component to subscribe to location changes. Each time that the location changes, it walks over its routes and determines which route(s!) match."),a.default.createElement("p",null,"React Router starts by rendering the root component. In the above router, that is the ",a.default.createElement(r.InlineComponent,null,"App"),". Next, our ",a.default.createElement(r.InlineJS,null,"inbox")," ","route also matches, so React Router also renders our"," ",a.default.createElement(r.InlineComponent,null,"Inbox")," component. Finally, the URI"," ",a.default.createElement(r.InlineJS,null,"/inbox/test-message-please-ignore")," also matches our ",a.default.createElement(r.InlineJS,null,":message")," ","route (which is concatenated with its parents to form the path"," ",a.default.createElement(r.InlineJS,null,"/inbox/:message"),"), so ",a.default.createElement(r.InlineComponent,null,"Message")," is rendered as well. Each child component is rendered by its parent, so we end up with a component tree that looks something like this:"),a.default.createElement("p",null,"With this structure, any routes with children will be rendered when one of the children matches. That means that those routes need to know how to render based on what type of match they have. For example, ",a.default.createElement(r.InlineComponent,null,"Inbox")," needs to know how to render for an exact match (the URI is ",a.default.createElement(r.InlineJS,null,"/inbox"),") and for a partial match (",a.default.createElement(r.InlineJS,null,"/inbox/test-message-please-ignore"),"). Also, if the"," ",a.default.createElement(r.InlineComponent,null,"Inbox")," needs to pass any props to ",a.default.createElement(r.InlineComponent,null,"Message"),", it has to use ",a.default.createElement(r.InlineJS,null,"React.cloneElement"),", which works but is not the cleanest looking code.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"<App>\n  <Inbox>\n    <Message>\n  </Inbox>\n</App>")),a.default.createElement(i.Subsection,{title:"Curi",id:"rendering-with-curi"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"With Curi, we also need to re-render our application every time that the location changes. We will do this by creating a root Curi component by calling the ",a.default.createElement(r.InlineJS,null,"curiProvider()")," function, which comes from the ",a.default.createElement(r.InlineJS,null,"@curi/react-dom")," package, and passing it our Curi router. While the name of this component is entirely up to you, we will refer to it as the ",a.default.createElement(r.InlineComponent,null,"Router")," here."),a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Router")," will setup an observer on the provided router so that it can re-render your application whenever there is a new ",a.default.createElement(r.InlineJS,null,"response"),". The ",a.default.createElement(r.InlineComponent,null,"Router")," expects a function as its ",a.default.createElement(r.InlineJS,null,"children")," prop (a render-invoked function). This function renders the application using the"," ",a.default.createElement(r.InlineJS,null,"response"),"."),a.default.createElement("p",null,"When the ",a.default.createElement(r.InlineComponent,null,"Router"),"'s ",a.default.createElement(r.InlineJS,null,"children()")," function is called, it will receive an object with three properties:"),a.default.createElement("ol",null,a.default.createElement("li",null,a.default.createElement(r.InlineJS,null,"response")," is the new response object"),a.default.createElement("li",null,a.default.createElement(r.InlineJS,null,"navigation")," is an object with additional information about the navigation"),a.default.createElement("li",null,a.default.createElement(r.InlineJS,null,"router")," is your Curi router (mostly useful if the function is defined in a separate file)")),a.default.createElement("p",null,"Above, we added ",a.default.createElement(r.InlineJS,null,"response()")," functions to each route. The functions set React components as the ",a.default.createElement(r.InlineJS,null,"body")," property of responses. We can now use ",a.default.createElement(r.InlineJS,null,"response.body")," to render those components."),a.default.createElement("p",null,"In the React Router section, we had three components that were rendered: ",a.default.createElement(r.InlineComponent,null,"App"),",",a.default.createElement(r.InlineComponent,null,"Inbox"),", and ",a.default.createElement(r.InlineComponent,null,"Message"),". With Curi, only the most accurately matched route actually matches. That means that for the URL ",a.default.createElement(r.InlineJS,null,"/inbox/test-message-please-ignore"),", the"," ",a.default.createElement(r.InlineJS,null,'"Message"')," route will match, but its parent route,"," ",a.default.createElement(r.InlineJS,null,'"Inbox"')," will not, so ",a.default.createElement(r.InlineJS,null,"response.body")," will be the ",a.default.createElement(r.InlineComponent,null,"Message")," component. Unlike React Router, we don’t render ",a.default.createElement(r.InlineComponent,null,"Inbox")," because we did not match the"," ",a.default.createElement(r.InlineJS,null,"inbox")," route.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},'import { curiProvider } from "@curi/react-dom";\n\nconst router = curi(history, routes);            \nconst Router = curiProvider(router);\n\nReactDOM.render((\n  <Router>\n    {({ response }) => {\n      const { body:Body } = response;\n      return <Body />;\n    }}\n  </Router>\n), holder);\n\n/*\n  <Router>\n    <Message />\n  </Router>\n*/'),a.default.createElement(s.Explanation,null,a.default.createElement(u.Note,null,"Wildcard routes (",a.default.createElement(r.InlineJS,null,"{ path: '(.*)' }"),") can be used to easily display a not found page for any location not matched by other routes.")),a.default.createElement(s.CodeBlock,null,'const routes = [\n  // ...,\n  {\n    name: "Not Found",\n    path: "(.*)",\n    response() {\n      return { body: NotFound };\n    }\n  }\n];'),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"It was mentioned above that there is no need for the"," ",a.default.createElement(r.InlineComponent,null,"App")," component with Curi. If you want to have an"," ",a.default.createElement(r.InlineComponent,null,"App")," component, you can render it either inside of the"," ",a.default.createElement(r.InlineJS,null,"children()")," function or as a parent of your"," ",a.default.createElement(r.InlineComponent,null,"Router"),". This can be useful for rendering content that is unrelated to specific routes, like a page header or menu."),a.default.createElement("p",null,"Rendering the ",a.default.createElement(r.InlineComponent,null,"App")," inside of the ",a.default.createElement(r.InlineJS,null,"children()")," ","function is necessary if any of the components rendered by the"," ",a.default.createElement(r.InlineComponent,null,"App")," are location aware components, since they need to access the Curi router (through React’s context, which the"," ",a.default.createElement(r.InlineComponent,null,"Router")," provides)")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"function render({ response }) {\n  const { body:Body } = response;\n  return (\n    <App>\n      <Body />\n    </App>\n  );\n}\n// or\nfunction render({ response }) {\n  const { body:Body } = response;\n  return (\n    <div>\n      <Header />\n      <Body />\n      <Footer />\n    </div>\n  );\n}"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"What about props that you want to send to your route components? Pass them to the ",a.default.createElement(r.InlineComponent,null,"Body")," component that you render. Props can be passed individually, but passing the whole"," ",a.default.createElement(r.InlineJS,null,"response")," object is recommended.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"function render({ response }) {\n  const { body:Body } = response;\n  return <Body response={response} />;\n}"))),a.default.createElement(i.Section,{title:"Links",id:"links"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"You will want to be able to navigate between routes in your application. React Router provides a ",a.default.createElement(r.InlineComponent,null,"Link")," component to do this, and so does Curi (through the ",a.default.createElement(r.InlineJS,null,"@curi/react-dom")," ","package). There are a few differences to note between these two components:")),a.default.createElement("ul",null,a.default.createElement("li",null,a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"React Router expects you to generate the pathname yourself, while Curi expects you to pass the name of the route that you want to navigate to. Any path parameters are passed to Curi’s"," ",a.default.createElement(r.InlineComponent,null,"Link")," using the ",a.default.createElement(r.InlineJS,null,"params")," prop.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"// React Router\n<Link to='/'>Home</Link>\n<Link to={`/inbox/${message}`}>Hello</Link>\n\n// Curi\n<Link to='Home'>Home</Link>\n<Link to='Message' params={{ message }}>Hello</Link>")),a.default.createElement("li",null,a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"With React Router, any additional location properties are passed to the ",a.default.createElement(r.InlineComponent,null,"Link")," using the ",a.default.createElement(r.InlineJS,null,"to")," object. With Curi, these properties are passed using the prop name (",a.default.createElement(r.InlineJS,null,"hash"),", ",a.default.createElement(r.InlineJS,null,"query")," &",a.default.createElement(r.InlineJS,null,"state"),").")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"// React Router\n<Link to={{ pathname: '/inbox', hash: '#test' }}>\n  Inbox\n</Link>\n\n// Curi\n<Link to='Inbox' hash='test'>Inbox</Link>")),a.default.createElement("li",null,a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Active detection with Curi uses an ",a.default.createElement(r.InlineComponent,null,"Active")," component."," ",a.default.createElement(r.InlineComponent,null,"Active"),"'s ",a.default.createElement(r.InlineJS,null,"children")," prop is a render-invoked function that receives a boolean ",a.default.createElement(r.InlineJS,null,"true")," when the named route is active and ",a.default.createElement(r.InlineJS,null,"false")," when it is not. You can also pass ",a.default.createElement(r.InlineJS,null,"partial={true}")," to let partial matches (ancestor routes) be considered active (the opposite of React Router's ",a.default.createElement(r.InlineJS,null,"onlyActiveOnIndex"),").")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"// React Router\n<Link\n  to='/'\n  onlyActiveOnIndex\n  activeClassName='active'\n>\n  Home\n</Link>\n\n// Curi\n// You need to add @curi/route-active\n// to your router object\nimport active from '@curi/route-active';\nconst router = curi(history, routes, {\n  route: [active()]\n});\n\n// The <Active> component determines if a route is active\n// and passes true/false to the render-invoked children\n// function\n<Active name=\"Home\">\n  {active => (\n    <Link\n      to='Home'\n      className={active ? \"active\" : \"\"}\n    >Home</Link>\n  )}\n</Active>")))),a.default.createElement(i.Section,{title:"Accessing router props from nested components",id:"router-props"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"React Router provides a ",a.default.createElement(r.InlineJS,null,"withRouter")," higher-order component that will inject router props into the wrapped component."),a.default.createElement("p",null,"Curi provides similar functionality with the ",a.default.createElement(r.InlineJS,null,"Curious")," ","component."),a.default.createElement("p",null,a.default.createElement(r.InlineJS,null,"Curious")," has a render-invoked ",a.default.createElement(r.InlineJS,null,"children")," ","function, which you can use to inject the Curi ",a.default.createElement(r.InlineJS,null,"router"),", the current ",a.default.createElement(r.InlineJS,null,"response"),", and the current"," ",a.default.createElement(r.InlineJS,null,"navigation")," object into components.")),a.default.createElement(s.CodeBlock,null,"// React Router\nexport default withRouter(SomeComponent);\n\n// Curi\nexport default () => (\n  <Curious>\n    {({ response }) => (\n      <SomeComponent response={response} />\n    )}\n  </Curious>\n);")),a.default.createElement("p",null,"At this point, hopefully you are comfortable with migrating from React Router v2/3 to Curi. If there are any concepts not covered here that you think should be, please feel free to open up an issue"," ",a.default.createElement("a",{href:"https://github.com/pshrmn/curi/issues"},"on GitHub"),"."))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=n(1),r=n(5),u=n(9),i=n(76),s=n(6)},136:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(u.Section,{title:"Hot Module Replacement",id:"hmr"},a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"Hot module replacement (HMR) can make development more convenient by automatically updating page content without refreshing the page. With Webpack, there are only a few steps required to get this working with Curi."),a.default.createElement("p",null,"The first step is to get your Webpack configuration setup for hot module replacement. Webpack's"," ",a.default.createElement("a",{href:"https://webpack.js.org/guides/hot-module-replacement/"},"hot module replacement guide")," ","is a good resource to learn how to do this.")),a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"The next step is identifying what file(s) you want to watch. A watched file will be notified when it, any of its dependencies, or any dependencies depndencies (and so on down the line) are updated. The best way to do this with a Curi application is to watch the file where your routes are defined."),a.default.createElement("p",null,"The ",a.default.createElement(o.InlineJS,null,"router")," has a ",a.default.createElement(o.InlineJS,null,"refresh()")," method that is used for providing new routes to the router. When it is called, it will also generate and emit a new response."),a.default.createElement("p",null,a.default.createElement(o.InlineJS,null,"module.hot.accept()")," is used for watching a file and calling a callback when that files or any files in its dependency chain are updated. In the callback, we can re-import the routes and pass them to the router's ",a.default.createElement(o.InlineJS,null,"refresh()")," method. This will in turn emit a new response, which will automatically be rendered."),a.default.createElement("p",null,"With that, your application should be setup to support hot module replacement.")),a.default.createElement(i.CodeBlock,{"data-line":"9-14"},'// index.js\nimport { curi } from "@curi/core";\nimport Browser from "@hickory/browser";\nimport routes from "./routes";\n\nconst history = Browser();\nconst router = curi(history, routes);\n\nif (module.hot) {\n  module.hot.accept("./routes.js", function() {\n    const nextRoutes = require("./routes").default;\n    router.refresh(nextRoutes);\n  });\n}'),a.default.createElement(i.Explanation,null,a.default.createElement(r.Note,null,a.default.createElement("p",null,'This approach does not automatically work with code splitting because the "main" module cannot be hot reloaded. Using a single bundle in development is one way to fix that.'),a.default.createElement("p",null,"If you are using code splitting (importing module with"," ",a.default.createElement(o.InlineJS,null,"import()"),") and compiling with Babel using the"," ",a.default.createElement(o.InlineJS,null,"@babel/plugin-syntax-dynamic-import")," plugin, you will want to use the ",a.default.createElement(o.InlineJS,null,"dynamic-import-node")," in development instead. This will produce a single bundle (no actual code splitting), so it should only be used in development."))),a.default.createElement(i.CodeBlock,null,'// .babelrc.js\n\n// you will need to set the NODE_ENV to "production"\n// for your production build\nconst __DEV__ = process.env.NODE_ENV !== "production";\n\nmodule.exports = {\n  plugins: [\n    __DEV__\n      ? "dynamic-import-node"\n      : "@babel/plugin-syntax-dynamic-import"\n  ]\n};')))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=(n(1),n(5)),r=n(9),u=n(76),i=n(6)},137:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(s.Explanation,null,a.default.createElement("p",null,a.default.createElement("a",{href:"https://apollographql.com"},"Apollo")," is a great solution for managing an application's data using"," ",a.default.createElement("a",{href:"http://graphql.org"},"GraphQL"),"."),a.default.createElement("p",null,"There are a few different implementation strategies for integrating Apollo and Curi based on how tightly you want them to be paired."),a.default.createElement(u.Note,null,a.default.createElement("p",null,"This guide only covers integration between Curi and Apollo. If you are not already familiar with how to use Apollo, you will want to learn that first."),a.default.createElement("p",null,"Also, this guide will only be referencing Apollo's React implementation, but the principles are the same no matter how you render your application."))),a.default.createElement(i.Section,{title:"Setup",id:"setup"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Your application's Apollo client instance should be defined in its own module so that it can be imported throughout the application.")),a.default.createElement(s.CodeBlock,null,'// apollo.js\nimport ApolloClient from "apollo-boost";\n\nexport default ApolloClient({\n  uri: "https://example.com/graphql"\n});'),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Apollo's React package provides an ",a.default.createElement(r.InlineComponent,null,"ApolloProvider")," ","component for accessing your Apollo client throughout the application. The ",a.default.createElement(r.InlineComponent,null,"Router")," (or whatever you name the root Curi component) should be a descendant of the"," ",a.default.createElement(r.InlineComponent,null,"ApolloProvider")," because we don't need to re-render the"," ",a.default.createElement(r.InlineComponent,null,"ApolloProvider")," for every new response.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},'import { ApolloProvider } from "react-apollo";\nimport { curiProvider } from "@curi/react-dom";\n\nconst Router = curiProvider(router);\n\nReactDOM.render((\n  <ApolloProvider client={client}>\n    <Router>\n      {() => {...}}\n    </Router>\n  </ApolloProvider>\n), holder);')),a.default.createElement(i.Section,{title:"Loose Pairing",id:"loose-pairing"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Apollo and Curi don't actually have to know about each other. Curi can create a response without doing any data fetching and let Apollo handle that with its ",a.default.createElement(r.InlineComponent,null,"Query")," component.")),a.default.createElement(s.CodeBlock,null,"// routes.js\nimport Noun from \"./pages/Noun\";\n\n// nothing Apollo related in here\nconst routes = [\n  {\n    name: 'Noun',\n    path: 'noun/:word',\n    response: () => {\n      return {\n        body: Noun\n      };\n    }\n  }\n];"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Any location data that a query needs can be taken from the response object. The best way to access this from your components would be to pass the ",a.default.createElement(r.InlineJS,null,"response")," to the components rendered in the"," ",a.default.createElement(r.InlineComponent,null,"Router"),"'s ",a.default.createElement(r.InlineJS,null,"children")," prop, which is a render-invoked function.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"// index.js\nReactDOM.render((\n  <ApolloProvider client={client}>\n    <Router>\n      {({ response }) => {\n        const { body:Body } = response;\n        return <Body response={response} />;\n      }}\n    </Router>\n  </ApolloProvider>\n), holder);"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Because we pass the ",a.default.createElement(r.InlineJS,null,"response")," to the route's"," ",a.default.createElement(r.InlineJS,null,"body")," component, we can pass a ",a.default.createElement(r.InlineComponent,null,"Query")," the response's location params using ",a.default.createElement(r.InlineJS,null,"props.response.params"),".")),a.default.createElement(s.CodeBlock,{lang:"jsx"},'// pages/Nouns.js\nimport { Query } from "react-apollo";\n\nconst GET_NOUN = gql`\n  query noun($word: String!) {\n    noun(word: $word) {\n      word,\n      type,\n      definition\n    }\n  }\n`;\n\n// use the "word" param from the response props\n// to query the correct data\nconst Noun = ({ response }) => (\n  <Query\n    query={GET_NOUN}\n    variables={{ word: response.params.word }}\n  >\n    {({ loading, error, data }) => {\n      if (loading) {\n        return <Loading />;\n      }\n      // ...\n\n      return (\n        <div>\n          <h1>{data.noun.word}</h1>\n          <p>{data.noun.definition}</p>\n        </div>\n      )\n    }}\n  </Query>\n);')),a.default.createElement(i.Section,{title:"Tight Pairing",id:"tight-pairing"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"You can use your Apollo client instance to call queries in a route's"," ",a.default.createElement(r.InlineJS,null,"resolve")," functions. ",a.default.createElement(r.InlineJS,null,"resolve")," functions are expected to return a Promise, which is exactly what"," ",a.default.createElement(r.InlineJS,null,"client.query()")," returns, so tightly pairing Curi and Apollo is mostly center around using a ",a.default.createElement(r.InlineJS,null,"resolve")," function to return a ",a.default.createElement(r.InlineJS,null,"client.query()")," call. This will delay navigation until after a route's GraphQL data has been loaded by Apollo.")),a.default.createElement(s.CodeBlock,null,'import client from "./apollo";\nimport { EXAMPLE_QUERY } from "./queries";\n\nconst routes = [\n  {\n    name: "Example",\n    path: "example/:id",\n    resolve: {\n      data({ params }) {\n        return client.query({\n          query: EXAMPLE_QUERY,\n          variables: { id: params.id }\n        });\n      }\n    }\n  }\n];'),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"There are two strategies for doing this. Both approaches require you to be able to import your Apollo client in the module where you define your routes, which is why we created client in its own module in the ",a.default.createElement(o.Link,{hash:"setup"},"setup")," section.")),a.default.createElement(s.CodeBlock,null,'// index.js\nimport client from "./apollo";\n\nReactDOM.render((\n  <ApolloProvider client={client}>\n    /*...*/\n  </ApolloProvider>\n), holder);\n\n// routes.js\nimport client from "./apollo";\n\n// ...'),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The first approach is to avoid the ",a.default.createElement(r.InlineComponent,null,"Query")," altogether. Instead, you can use a route's ",a.default.createElement(r.InlineJS,null,"response()")," property to attach the data fetched by Apollo directly to a response through its"," ",a.default.createElement(r.InlineJS,null,"data")," property."),a.default.createElement("p",null,"While we know at this point that the query has executed, we should also check ",a.default.createElement(r.InlineJS,null,"resolved.error")," in the ",a.default.createElement(r.InlineJS,null,"response()")," ","function to ensure that the query was executed successfully.")),a.default.createElement(s.CodeBlock,null,'// routes.js\nimport client from "./apollo";\nimport GET_VERB from "./queries";\n\nimport Verb from "./pages/Verb";\n\nexport default [\n  {\n    name: "Verb",\n    path: "verb/:word",\n    resolve: {\n      verb({ params }) {\n        return client.query({\n          query: GET_VERB,\n          variables: { word: params.word }\n        })\n      }\n    },\n    response({ error, resolved }) {\n      if (error) {\n        // handle failed queries\n      }\n      return {\n        body: Verb,\n        data: resolved.verb.data\n      }\n    }\n  }\n];'),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"In the response's ",a.default.createElement(r.InlineJS,null,"body")," component, you would access the query data through the ",a.default.createElement(r.InlineJS,null,"response"),"'s ",a.default.createElement(r.InlineJS,null,"data")," ","property.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"// pages/Verb.js\nconst Verb = ({ response }) => (\n  <div>\n    <h1>{response.data.verb.word}</h1>\n    <p>\n      {response.data.verb.definition}\n    </p>\n  </div>\n)"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The second approach is to use a ",a.default.createElement(r.InlineJS,null,"resolve")," function as a way to cache the data, but also use ",a.default.createElement(r.InlineComponent,null,"Query"),". With this approach, we do not have to attach the query data to the response; we are just relying on the fact that Apollo will execute and cache the results prior to navigation.")),a.default.createElement(s.CodeBlock,null,'// routes.js\nimport client from "./apollo";\nimport { GET_VERB } from "./queries";\n\nexport default [\n  {\n    name: "Verb",\n    path: "verb/:word",\n    resolve: {\n      data({ params }) {\n        // load the data so it is cached by\n        // your Apollo client\n        return client.query({\n          query: GET_VERB,\n          variables: { word: params.word }\n        })\n      }\n    }\n  }\n];'),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The route's component will render a ",a.default.createElement(r.InlineComponent,null,"Query")," to also call the query. Because the query has already been executed, Apollo will grab the data from its cache instead of re-sending a request to your server.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},'// pages/Verb.js\nimport { GET_VERB } from "../queries";\n\nconst Verb = ({ response }) => (\n  <Query\n    query={GET_VERB}\n    variables={{ word: response.params.word }}\n  >\n    {({ loading, error, data }) => {\n      // ...\n      return (\n        <div>\n          <h1>{data.verb.word}</h1>\n          <p>\n            {data.verb.definition}\n          </p>\n        </div>\n      );\n    }}\n  </Query>\n)'),a.default.createElement(i.Subsection,{title:"Prefetching",id:"prefetch"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"One additional benefit of adding queries to routes using"," ",a.default.createElement(r.InlineJS,null,"resolve")," functions is that you can prefetch data for a route."),a.default.createElement("p",null,"The"," ",a.default.createElement(o.Link,{to:"Package",params:{package:"route-prefetch"}},a.default.createElement(r.InlineJS,null,"@curi/route-prefetch"))," ","interaction lets you programmatically fetch the data for a route prior to navigating to a location.")),a.default.createElement(s.CodeBlock,null,'// index.js\nimport prefetch from "@curi/route-prefetch";\n\nconst routes = [\n  {\n    name: "Example",\n    path: "example/:id",\n    resolve: {\n      examples({ params }) {\n        client.query({\n          query: GET_EXAMPLES,\n          variables: { id: params.id }\n        })\n      }\n    }\n  }\n]\n\nconst router = curi(history, routes, {\n  route: [prefetch()]\n});\n\n// this will call the GET_EXAMPLES query\n// and Apollo will cache the results\nrouter.route.prefetch(\n  "Example",\n  { params: { id: 2 }}\n);'))))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=n(1),r=n(5),u=n(9),i=n(76),s=n(6)},138:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(s.Explanation,null,a.default.createElement("p",null,'It is important to keep in mind that some visitors to your site rely on screen readers, so you should ensure that they have a pleasant experience. One "issue" with single-page applications is that they traditionally are more difficult for screen reader users because they do not have a great way for detecting navigation.'),a.default.createElement("p",null,"Curi provides a couple approaches to help you make your site accessible.")),a.default.createElement(i.Section,{title:"Announcing Navigation",id:"aria-live"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"When the content of"," ",a.default.createElement("a",{href:"https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions"},"ARIA live regions")," ","change, the new content will be announced to screen reader users. The"," ",a.default.createElement(o.Link,{to:"Package",params:{package:"side-effect-aria-live"}},a.default.createElement(r.InlineJS,null,"@curi/side-effect-aria-live"))," ","package provides a side effect for creating a live region and updating its content to announce navigation."),a.default.createElement("p",null,"The side effect takes a function which returns a string that should be read by screen readers. This can be whatever you want it to be, but screen readers normally read a page's title, so if you are setting ",a.default.createElement(r.InlineJS,null,"title"),"s for your responses, it is probably a good idea to have those announced.")),a.default.createElement(s.CodeBlock,null,'import ariaLive from "@curi/side-effect-aria-live";\n  \nconst announcer = ariaLive(\n  ({ response }) => `Navigated to ${response.title}`\n);\n\nconst routes = [\n  {\n    name: "Home",\n    path: "",\n    response() {\n      return {\n        title: "Home"\n      };\n    }\n  }\n]\n\nconst router = curi(history, routes, {\n  sideEffects: [announcer]\n});\n\n// when the user navigates to "/", the screen reader\n// will read: "Navigated to Home"')),a.default.createElement(i.Section,{title:"Focusing Content",id:"focus"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Screen readers read the content of elements in the page that are focused. They can move through the page to read different elements. When you navigate, the content of the site will be re-rendered, so it is important for you to focus on the new content so that users using screen readers don't have to tab around looking for the new content. This is focus management and there are a couple things to keep in mind when implementing it.")),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"When you focus an element, make sure to focus the specific content for a page. If you were to just focus the page's ",a.default.createElement(r.InlineComponent,null,"body")," or a root ",a.default.createElement(r.InlineComponent,null,"div"),", then the user might have to tab through less important content, like the page's menus, while looking for the new content.")),a.default.createElement(s.CodeBlock,{lang:"html"},"\x3c!--\n  it is better to focus the important content (<main>)\n  and not the entire page\n--\x3e\n<div>\n  <header></header>\n  <main></main>\n</div>"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The element that you focus needs to be focusable. Elements can be natively focusable (e.g. ",a.default.createElement(r.InlineComponent,null,"input"),"s and ",a.default.createElement(r.InlineComponent,null,"a"),"s) or you can use the ",a.default.createElement(r.InlineJS,null,"tabIndex")," property. A ",a.default.createElement(r.InlineJS,null,"tabIndex")," of"," ",a.default.createElement(r.InlineJS,null,"-1")," lets you focus an element, but keeps screen readers from accidentally focusing it when a user is tabbing through the page's contents."),a.default.createElement(u.Warning,null,"If you try to focus an element that is not focusable, then the document's ",a.default.createElement(r.InlineComponent,null,"body")," will be focused instead.")),a.default.createElement(s.CodeBlock,{lang:"html"},'\x3c!-- you can focus us --\x3e\n<input />\n<a href="https://example.com">Example</a>\n<div tabIndex="-1"></div>\n\n\x3c!-- but not me --\x3e\n<div></div>'),a.default.createElement(i.Subsection,{title:"Focusing in React Applications",id:"focus-react"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"@curi/react-dom")," package provides a ",a.default.createElement(r.InlineComponent,null,"Focus")," ","component that gives you a ",a.default.createElement(r.InlineJS,null,"ref")," to attach to the component that should be focused. Whenever the user navigates, it will re-focus so that the screen reader is focused on the correct content.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},'import { curiProvider, Focus } from "@curi/react-dom";\n\nconst Router = curiProvider(router);\n\nReactDOM.render((\n  <Router>\n    {({ response }) => {\n      const { body:Body } = response;\n      return (\n        <Header />\n        <Focus>\n          {ref => (\n            <main ref={ref} tabIndex={-1}>\n            </main>\n          )}\n        </Focus>\n      );\n    }}\n  </Router>\n), holder);')),a.default.createElement(i.Subsection,{title:"Focusing in Vue Applications",id:"focus-vue"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"@curi/vue")," package provides a directive for focusing an element. The directive needs to be passed something that changes when the user navigates, so you can just pass it the current ",a.default.createElement(r.InlineJS,null,"response"))),a.default.createElement(s.CodeBlock,{lang:"html"},'<template>\n  <header>...</header>\n  <main tabIndex="-1" v-curi-focus="$curi.response">\n    <component :is="$curi.response.body" />\n  </main>\n</template>'))),a.default.createElement(i.Section,{title:"More Resources",id:"more"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The above content is great for making navigation within your application accessible, but those aren't the only steps that you should take to making your site more accessible."),a.default.createElement("p",null,"If you are interested in other resources for improving the accessibility of your website, I would recommend Google's"," ",a.default.createElement("a",{href:"https://developers.google.com/web/fundamentals/accessibility/"},"collection of accessibility articles"),". WebAIM also provides a good"," ",a.default.createElement("a",{href:"https://webaim.org/standards/wcag/checklist"},"checklist")," ","to consult."),a.default.createElement("p",null,"The"," ",a.default.createElement("a",{href:"https://chrome.google.com/webstore/detail/chromevox/kgejglhpjiefppelpmljglcjbhoiplfn?hl=en"},"ChromeVox")," ","extension for Chrome is a free screen reader that you can use to experience your site like a user using a screen reader would. This documentation site uses the above announcement and focus techniques, so you can see how they work by activating a screen reader and navigating throughout this site."))))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=n(1),r=n(5),u=n(9),i=n(76),s=n(6)},139:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"In the code splitting guide, we added a function that calls"," ",a.default.createElement(r.InlineJS,null,"import()")," to a route's ",a.default.createElement(r.InlineJS,null,"resolve")," object in order to dynamically load modules. We can do the same thing for other data.")),a.default.createElement(u.Section,{title:"resolve",id:"resolve"},a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"An async function (with any name you want it to have) can be added to the ",a.default.createElement(r.InlineJS,null,"resolve")," object and the value it resolves will be available in the route's ",a.default.createElement(r.InlineJS,null,"response()")," function (as a property of the ",a.default.createElement(r.InlineJS,null,"resolved")," object)."),a.default.createElement("p",null,"When the ",a.default.createElement(r.InlineJS,null,"Recipe")," route matches, we want to fetch data for that specific recipe (using the ",a.default.createElement(r.InlineJS,null,"id")," param from the path).")),a.default.createElement(i.CodeBlock,null,"const routes = [\n  {\n    name: 'Recipe',\n    path: 'recipe/:id'\n  }\n];"),a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"Here, we will name the ",a.default.createElement(r.InlineJS,null,"resolve")," function for fetching data"," ",a.default.createElement(r.InlineJS,null,'"data"'),"."),a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"resolve.data()")," function will be passed an object that contains the matched route response properties, including the route"," ",a.default.createElement(r.InlineJS,null,"params"),"."),a.default.createElement("p",null,"All ",a.default.createElement(r.InlineJS,null,"resolve")," functions are expected to return a Promise."),a.default.createElement("p",null,"Now, when we navigate to ",a.default.createElement(r.InlineJS,null,"/recipe/chocolate-chip-cookies"),", the ",a.default.createElement(r.InlineJS,null,"resolve.data()")," function will call the fake API function to load the ",a.default.createElement(r.InlineJS,null,'"chocolate-chip-cookies"')," recipe. The function will resolve with the loaded data.")),a.default.createElement(i.CodeBlock,null,"{\n  name: 'Recipe',\n  path: 'recipe/:id',\n  resolve: {\n    data: ({ params }) => fakeAPI.getRecipe(params.id)\n  }\n}")),a.default.createElement(u.Section,{title:"response",id:"response"},a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"While ",a.default.createElement(r.InlineJS,null,"resolve.data()")," starts our data loading, it doesn't actually do anything. Instead, we should handle any loaded data with the ",a.default.createElement(r.InlineJS,null,"response()")," function."),a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"response()")," and ",a.default.createElement(r.InlineJS,null,"resolve.data()")," are separate because while a route is resolving, the user may navigate again, which overrides the current navigation. We cannot cancel the"," ",a.default.createElement(r.InlineJS,null,"resolve.data()")," function for the current navigation, so if it performs any side effects, our application is stuck with them. To avoid this, the ",a.default.createElement(r.InlineJS,null,"response()")," function is not called until we know that the current navigation will complete."),a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"response()")," function will receive an object with a number of properties. These are covered in in the"," ",a.default.createElement(o.Link,{to:"Guide",params:{slug:"routes-and-responses"},hash:"route-response"},"Routes and Responses")," ","guide, but the only one we care about right now is"," ",a.default.createElement(r.InlineJS,null,"resolved"),".")),a.default.createElement(i.CodeBlock,null,"{\n  name: 'Recipe',\n  path: 'recipe/:id',\n  resolve: {\n    data: ({ params }) => fakeAPI.getRecipe(params.id),\n  },\n  response({ resolved }) {\n    return {\n      body: Recipe,\n      data: resolved.data\n    }\n  }\n}"),a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"If at some point in time we decide that we want to change our URI pathname structure, we can also use the ",a.default.createElement(r.InlineJS,null,"response()")," ","function to redirect."),a.default.createElement("p",null,"You can specify the route to redirect to with ",a.default.createElement(r.InlineJS,null,"redirectTo"),". This takes the ",a.default.createElement(r.InlineJS,null,"name")," of the route to redirect to,"," ",a.default.createElement(r.InlineJS,null,"params")," if the route (or ancestor routes) have route params. ",a.default.createElement(r.InlineJS,null,"hash"),", ",a.default.createElement(r.InlineJS,null,"query"),", and ",a.default.createElement(r.InlineJS,null,"state")," can also be provided."),a.default.createElement("p",null,"After Curi emits the response, it will also automatically redirect to the new location!")),a.default.createElement(i.CodeBlock,null,"{\n  name: 'Old Recipe',\n  path: 'r/:id',\n  response: ({ params }) => {\n    // destructure the current location to preserve\n    // query/hash values\n    return {\n      redirectTo: {\n        name: 'Recipe',\n        params: params,\n        hash: location.hash\n      }\n    };\n  }\n}")),a.default.createElement("p",null,"A route's ",a.default.createElement(r.InlineJS,null,"resolve")," object and ",a.default.createElement(r.InlineJS,null,"response()")," functions offer a convenient way to do data loading prior to actually rendering the route, but please remember that your application will not be re-rendering until ",a.default.createElement("em",null,"after")," the fetching has resolved. If you have a long running load function, you may wish to implement some sort of loading display. The"," ",a.default.createElement(o.Link,{to:"Example",params:{category:"react",slug:"data-loading"}},"data loading example")," ","shows one approach to how to do this."))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=n(1),r=n(5),u=(n(9),n(76)),i=n(6)},140:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"If you are bundling an application with a lot of routes, users of your application may be downloading a lot of unnecessary content for the initial page render. Using code splitting, you can reduce the initial download size for your application by splitting code that is conditionally loaded into a separate bundle that is only downloaded when it is needed."),a.default.createElement(r.Note,null,"This guide assumes that you are using Webpack 2+ to bundle your application.")),a.default.createElement(u.Section,{title:"An app without code splitting",id:"no-split"},a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"Let's start out by describing our application's routes without code splitting. We will import each route's component from the files where they are defined.")),a.default.createElement(i.CodeBlock,null,"import Home from './components/Home';\nimport Contact from './components/Contact';\nimport ContactMethod from './components/ContactMethod';\n\nconst routes = [\n  {\n    name: 'Home',\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    name: 'Contact',\n    path: 'contact',\n    response: () => {\n      return {\n        body: Contact\n      };\n    },\n    children: [\n      {\n        name: 'Contact Method',\n        path: ':method',\n        response: () => {\n          return {\n            body: ContactMethod\n          };\n        }\n      }\n    ]\n  }\n];")),a.default.createElement(u.Section,{title:"import() in resolve",id:"import"},a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"Instead of having static imports, we will use the"," ",a.default.createElement(o.InlineJS,null,"import()")," function to import our modules. We will import our components by adding a property to a route's ",a.default.createElement(o.InlineJS,null,"resolve")," ","object. The property name for the function is how we will access the resolved data in the route's ",a.default.createElement(o.InlineJS,null,"response()")," function."),a.default.createElement("p",null,a.default.createElement(o.InlineJS,null,"resolve")," functions are called every time a route matches. However, ",a.default.createElement(o.InlineJS,null,"import()")," calls automatically re-use the results of a previous call, so we do not have to worry about extra network requests."),a.default.createElement("p",null,"Here we will name the ",a.default.createElement(o.InlineJS,null,"resolve")," function for importing a component ",a.default.createElement(o.InlineJS,null,"body"),", since it will be set as the response's"," ",a.default.createElement(o.InlineJS,null,"body")," property."),a.default.createElement("p",null,a.default.createElement(o.InlineJS,null,"resolve.body()")," should return a Promise;"," ",a.default.createElement(o.InlineJS,null,"import()"),", conveniently, returns a Promise. In our"," ",a.default.createElement(o.InlineJS,null,"response()")," function, instead of referencing values imported at the top of the file, we can reference the result of the"," ",a.default.createElement(o.InlineJS,null,"resolve.body()")," function using ",a.default.createElement(o.InlineJS,null,"resolved.body"),"."),a.default.createElement("p",null,a.default.createElement(o.InlineJS,null,"import()")," resolves with a module object. If the component is a default export (",a.default.createElement(o.InlineJS,null,"export default MyComponent"),"), we can access the component through the imported module object's"," ",a.default.createElement(o.InlineJS,null,"default")," property.")),a.default.createElement(i.CodeBlock,null,"const routes = [\n  {\n    name: 'Home',\n    path: '',\n    resolve: {\n      body: () => (\n        import('./components/Home')\n          .then(module => module.default)\n      ),\n    },\n    response: ({ resolved }) => {\n      return {\n        body: resolved.body\n      };\n    }\n  },\n  {\n    name: 'Contact',\n    path: 'contact',\n    resolve: {\n      body: () => (\n        import('./components/Contact')\n          .then(module => module.default)\n      ),\n    },\n    response: ({ resolved }) => {\n      return {\n        body: resolved.body\n      };\n    },\n    children: [\n      {\n        name: 'Contact Method',\n        path: ':method',\n        resolve: {\n          body: () => (\n            import('./components/ContactMethod')\n              .then(module => module.default)\n          )\n        },\n        response: ({ resolved }) => {\n          return {\n            body: resolved.body\n          };\n        }\n      }\n    ]\n  }\n];")),a.default.createElement(u.Section,{title:"Other Approaches",id:"other"},a.default.createElement("p",null,"The approaches taken here are not the only way to do code splitting. Another approach is to skip the ",a.default.createElement(o.InlineJS,null,"resolve")," method and do code splitting at other points in your application (e.g."," ",a.default.createElement("a",{href:"https://github.com/jamiebuilds/react-loadable"},a.default.createElement(o.InlineJS,null,"react-loadable")),")."),a.default.createElement("p",null,"Whatever path you decide to go, hopefully this has shown you that setting up code splitting with a ",a.default.createElement(o.InlineJS,null,"resolve")," function is fairly simple to do. If you are using Webpack and want to reduce your initial bundle size, ",a.default.createElement(o.InlineJS,null,"resolve")," functions are a good way to accomplish this.")))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=(n(1),n(5)),r=n(9),u=n(76),i=n(6)},141:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"Curi side effects are permanent router response handlers that are run after those registered using ",a.default.createElement(r.InlineJS,null,"router.observe()")," and"," ",a.default.createElement(r.InlineJS,null,"router.once()"),"."),a.default.createElement("p",null,"Whenever a new response is generated, all of the side effect functions will be called. They will be given an object with the new"," ",a.default.createElement(r.InlineJS,null,"response"),", object, a ",a.default.createElement(r.InlineJS,null,"navigation")," object with some extra routing data (the navigation action the previous response), and the ",a.default.createElement(r.InlineJS,null,"router")," object.")),a.default.createElement(i.CodeBlock,null,"function logResponse({ response }) {\n  // call your logging API to record the response\n}"),a.default.createElement(u.Section,{title:"Adding Side Effects",id:"adding"},a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"Side effects are provided to your router with the"," ",a.default.createElement(r.InlineJS,null,"sideEffects")," property of the options object. This is an array of observer functions.")),a.default.createElement(i.CodeBlock,null,"const router = curi(history, routes, {\n  sideEffects: [logResponse, updateTitle]\n});"),a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"Side effects are always run after observers registered using"," ",a.default.createElement(r.InlineJS,null,"router.observe()")," and ",a.default.createElement(r.InlineJS,null,"router.once()"),". Because those forms of response handler registration are primarily used for rendering the application, this means that the side effects will be called after the application has re-rendered.")),a.default.createElement(i.CodeBlock,null,"const router = curi(history, routes, {\n  sideEffects: [logResponse]\n});\n\nconst render = () => {\n  // render the app\n};\n\nrouter.observe(render);\n\n// whenever there is a response, render will be\n// called before logResponse"),a.default.createElement(u.Subsection,{title:"Official Side Effects",id:"official"},a.default.createElement(i.Explanation,null,a.default.createElement("p",null,'Curi has two "official" side effect packages:'),a.default.createElement("ul",null,a.default.createElement("li",null,a.default.createElement(o.Link,{to:"Package",params:{package:"side-effect-title"}},"@curi/side-effect-title")),a.default.createElement("li",null,a.default.createElement(o.Link,{to:"Package",params:{package:"side-effect-scroll"}},"@curi/side-effect-scroll")))),a.default.createElement(i.CodeBlock,null,'import titleEffect from "@curi/side-effect-title";\nimport scrollEffect from "@curi/side-effect-scroll";\n\nconst router = curi(history, routes, {\n  sideEffect: [titleEffect(), scrollEffect()]\n});'))),a.default.createElement(u.Section,{title:"Creating Side Effects",id:"creating"},a.default.createElement(i.Explanation,null,a.default.createElement("p",null,'When creating your own side effect, you can write a regular function or a side effect "factory".')),a.default.createElement(i.CodeBlock,null,"function mySideEffect({ response, navigation }) {\n  console.log('Navigating to', response.location);\n  console.log('Navigation action:', navigation.action);\n}\n\nconst router = curi(history, routes, {\n  sideEffects: [mySideEffect]\n});"),a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"A side effect factory lets create a more customizable side effect.")),a.default.createElement(i.CodeBlock,null,"function AnalyticsLogger(options) {\n  // do some setup with the provided options\n  const logger = setupMyLogger(options);\n\n  // and return the actual side effect function\n  return sideEffect({ response }) {\n    logger(response);\n  }\n}"),a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"You may want to review the"," ",a.default.createElement(o.Link,{to:"Guide",params:{slug:"responses"},hash:"response-properties"},"response properties")," ","to know which properties you should expect a response to have."))))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=n(1),r=n(5),u=n(76),i=n(6)},142:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(u.Explanation,null,a.default.createElement("p",null,"Route interactions let you interact with a registered route using its name."),a.default.createElement("p",null,"A registered route is generally any route that is in the array of routes that you used to create your router. However, some interactions only register routes that meet some criteria. For example, the"," ",a.default.createElement(o.InlineJS,null,"prefetch")," interaction only registers routes with asynchronous methods."),a.default.createElement("p",null,"Route interactions are defined using objects with four properties: name, register, get, and reset.")),a.default.createElement(u.CodeBlock,null,"{\n  // The string you will use to call the interaction.\n  name: 'my',\n\n  // A function used internally to register routes\n  // with the interaction. You only need to use this when\n  // writing your own interactions.\n  register: function(route, parentData) {...},\n\n  // This is the function that you will call. For example,\n  // with this interaction, the get function will be\n  // called when you call router.route.my('...')\n  get: function(route) {...},\n  reset: function() {...}\n}"),a.default.createElement(u.Explanation,null,a.default.createElement("p",null,"Instead of importing the actual route interaction object, you typically import a factory function to create the object. This isn't absolutely necessary, but is useful for server-side rendering.")),a.default.createElement(u.CodeBlock,null,'// interactions/my.js\nexport default function createMyInteraction() {\n  return {\n    name: "my",\n    register() {...},\n    get() {...},\n    reset() {...}\n  };\n}\n\n// index.js\nimport createMyInteraction from "./interactions/my";\n\nconst interaction = createMyInteraction();'),a.default.createElement(r.Section,{title:"Adding Interactions",id:"adding"},a.default.createElement(u.Explanation,null,a.default.createElement("p",null,"Route interactions are provided to the router call as an array using the ",a.default.createElement(o.InlineJS,null,"route")," property of the options object (the third argument).")),a.default.createElement(u.CodeBlock,null,"const router = curi(history, routes, {\n  route: [createMyInteraction()]\n});"),a.default.createElement(u.Explanation,null,a.default.createElement("p",null,"The route interaction will be added to the router's ",a.default.createElement(o.InlineJS,null,"route")," ","property. When you call an interaction, you pass the name of the route that you want to interact with.")),a.default.createElement(u.CodeBlock,null,"const myValue = router.route.my('Some Route', ...);")),a.default.createElement(r.Section,{title:"Creating Route Interactions",id:"creating"},a.default.createElement(u.Explanation,null,a.default.createElement("p",null,"There are a few steps to creating your own route interactions."),a.default.createElement("p",null,"Remember to export a function that will create the interaction object, not the actual interaction object.")),a.default.createElement(u.CodeBlock,null,"// we'll create an interaction that confirms\n// a route is registered\nexport default function confirmInteraction() {\n  ...\n}"),a.default.createElement(u.Explanation,null,a.default.createElement("p",null,"The function should return an object with four properties:"," ",a.default.createElement(o.InlineJS,null,"name"),", ",a.default.createElement(o.InlineJS,null,"register"),", ",a.default.createElement(o.InlineJS,null,"get"),", and"," ",a.default.createElement(o.InlineJS,null,"reset"),"."),a.default.createElement("table",null,a.default.createElement("thead",null,a.default.createElement("tr",null,a.default.createElement("th",null,"property"),a.default.createElement("th",null,"description"))),a.default.createElement("tbody",null,a.default.createElement("tr",null,a.default.createElement("td",null,"name"),a.default.createElement("td",null,"a unique identifier for the route interaction")),a.default.createElement("tr",null,a.default.createElement("td",null,"register"),a.default.createElement("td",null,"a function to internally store information about routes")),a.default.createElement("tr",null,a.default.createElement("td",null,"get"),a.default.createElement("td",null,"a function that will receive a route's name (and possibly other arguments) and perform some task using the related route")),a.default.createElement("tr",null,a.default.createElement("td",null,"reset"),a.default.createElement("td",null,"a function that will reset the interaction's internal state (this is used if you call ",a.default.createElement(o.InlineJS,null,"router.replaceRoutes()"),")"))))),a.default.createElement(u.CodeBlock,null,"export default function confirmInteraction() {\n  // maintain an object of known routes\n  let knownRoutes = {};\n  return {\n    name: 'confirm',\n    // when a route is registered,\n    // we store it using its name\n    register: route => {\n      knownRoutes[route.name] = true;\n    },\n    // get checks the known routes to see if one exists\n    // with the requested name\n    get: (name) => {\n      return knownRoutes[name] != null\n    },\n    // reset the known routes\n    reset: () => {\n      knownRoutes = {};\n    }\n  };\n}"),a.default.createElement(u.Explanation,null,a.default.createElement("p",null,"In your application, you can import it, call the factory to create the interaction, and register the interaction when you create the router.")),a.default.createElement(u.CodeBlock,null,"import { curi } from '@curi/router';\nimport confirmFactory from './interactions/confirm'\n\nconst routes = [{ name: 'Home', path: '' }];\n\nconst router = curi(history, routes, {\n  route: [confirmFactory()]\n});\n\nrouter.route.confirm('Home'); // true\nrouter.route.confirm('Elsewhere'); // false"),a.default.createElement(r.Subsection,{title:"Slightly more advanced",id:"Slightly-more-advanced"},a.default.createElement(u.Explanation,null,a.default.createElement("p",null,"You might want to write an interaction that uses data from parent routes when registering a route. For example, the built-in pathname interaction joins a route's path with it parent path(s)."),a.default.createElement("p",null,"The second argument passed to a router interaction's"," ",a.default.createElement(o.InlineJS,null,"register()")," function is a parent data object. For root routes, this will be ",a.default.createElement(o.InlineJS,null,"undefined"),". For nested routes, this is the value returned by the parent route's ",a.default.createElement(o.InlineJS,null,"register()")," ","function.")),a.default.createElement(u.CodeBlock,null,"function ParentFactory() {\n  let routeTree = {};\n  return {\n    name: 'routeParent',\n    register: (route, parent) => {\n      routeTree[route.name] = parent;\n      // we return route.name and any child routes will\n      // receive that as their parent value\n      return route.name;\n    },\n    get: (name) => {\n      return routeTree[name];\n    },\n    reset: () => {\n      routeTree = {};\n    }\n  }\n}"))))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=(n(1),n(5)),r=n(76),u=n(6)},143:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(u.Section,{title:"Store Integration",id:"store"},a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"Curi relies on Svelte's store to interface with an application. By adding the ",a.default.createElement(r.InlineJS,null,"response")," (plus the ",a.default.createElement(r.InlineJS,null,"router")," and"," ",a.default.createElement(r.InlineJS,null,"navigation")," objects) to the store, they are accessible throughout the application."),a.default.createElement("p",null,a.default.createElement(r.InlineJS,null,"@curi/svelte")," provides a function to link the router to the store. This sets up an"," ",a.default.createElement(o.Link,{to:"Guide",params:{slug:"navigating"},hash:"observer"},"observer"),", so that whenever there is a new response, the parts of your application that use the response will be re-rendered.")),a.default.createElement(i.CodeBlock,{lang:"jsx"},'import store from "svelte/store";\nimport { curiStore } from "@curi/svelte";\n\nimport router from "./router";\n\nconst store = new Store();\ncuriStore(router, store);'),a.default.createElement(u.Subsection,{title:"Rendering with the response",id:"rendering-response"},a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"Svelte allows you to render dynamic components using the"," ",a.default.createElement(r.InlineComponent,null,"svelte:component this")," syntax. If you set Svelte components as the ",a.default.createElement(r.InlineJS,null,"body")," properties on your responses, you can combine ",a.default.createElement(r.InlineComponent,null,"svelte:component this")," and"," ",a.default.createElement(r.InlineJS,null,"response.body")," to render the appropriate component for a"," ",a.default.createElement(r.InlineJS,null,"response"),"."),a.default.createElement("p",null,"A root component is a good place to perform general application layout, like menus, in addition to rendering the response's"," ",a.default.createElement(r.InlineJS,null,"body"),".")),a.default.createElement(i.CodeBlock,{lang:"html"},'<template>\n  <header>\n    <NavLinks />\n  </header>\n  <main>\n    <svelte:component this={$curi.response.body} />\n  </main>\n</template>\n\n<script>\n  import NavLinks from "./NavLinks";\n  export default {\n    components: { NavLinks }\n  };\n<\/script>'),a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"If your routes use an object to attach multiple components to a response, splitting them apart in computed properties may give your templates a cleaner look."),a.default.createElement("p",null,"If you do attach multiple components to a response, please remember that you want every route to set the same ",a.default.createElement(r.InlineJS,null,"body")," ","shape. Otherwise, you'll have to determine the shape and change how you render, which can quickly become messy.")),a.default.createElement(i.CodeBlock,{lang:"html"},'<script>\nconst routes = [\n  {\n    name: "Home",\n    path: "",\n    response() {\n      return {\n        body: {\n          main: HomeMain,\n          menu: HomeMenu\n        }\n      }\n    }\n  },\n  // ...\n];\n<\/script>\n\n<template>\n  <header>\n    <svelte:component this={menu} />\n  </header>\n  <main>\n  <svelte:component this={main} />\n  </main>\n</template>\n\n<script>\n  export default {\n    computed: {\n      main({ $curi }) {\n        return $curi.response.body.main;\n      },\n      menu({ $curi }) {\n        return $curi.response.body.menu;\n      }\n    }\n  }\n<\/script>'))),a.default.createElement(u.Section,{title:"Navigating",id:"navigating"},a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Link")," component is used to navigate between routes within an application. When it renders in the DOM, it will render as an anchor (",a.default.createElement(r.InlineComponent,null,"a"),") element."),a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Link"),"'s ",a.default.createElement(r.InlineJS,null,"to")," prop describes which route clicking the link should navigate to. If you pass an invalid route name, Curi will warn you."),a.default.createElement("p",null,"If a route has any params (or if any of a route's ancestors have params for nested routes), the ",a.default.createElement(r.InlineJS,null,"params")," prop is used to pass these to the ",a.default.createElement(r.InlineComponent,null,"Link"),".")),a.default.createElement(i.CodeBlock,{lang:"html"},'<template>\n  <nav>\n    <ul>\n      <li>\n        <Link to="Home">Home</Link>\n      </li>\n      <li>\n        <Link to="About">About</Link>\n      </li>\n      <li>\n        <Link to="User" params={{ id: \'blue\' }}>\n          Blue\n        </Link>\n      </li>\n    </ul>\n  </nav>\n</template>\n\n<script>\n  import { Link } from "@curi/svelte";\n\n  export default {\n    components: { Link }\n  };\n<\/script>'),a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Link")," also takes ",a.default.createElement(r.InlineJS,null,"hash"),", ",a.default.createElement(r.InlineJS,null,"query"),", and ",a.default.createElement(r.InlineJS,null,"state")," props to attach their values to the location that will be navigated to.")),a.default.createElement(i.CodeBlock,{lang:"jsx"},'<Link to="Home" hash="details">Home</Link>\n// renders\n<a href="/#details">Home</a>')),a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"Please check out the full"," ",a.default.createElement(o.Link,{to:"Package",params:{package:"svelte"},hash:"API"},a.default.createElement(r.InlineJS,null,"@curi/svelte"))," ","API documentation to see every component that the package provides.")))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=n(1),r=n(5),u=(n(9),n(76)),i=n(6)},144:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(u.Section,{title:"The Curi Plugin",id:"plugin"},a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"CuriPlugin")," for Vue allows you to interface your router with a Vue application. The plugin sets up a reactive object for tracking responses using an"," ",a.default.createElement(o.Link,{to:"Guide",params:{slug:"navigating"},hash:"observer"},"observer"),", so whenever there is a new response, the parts of your application that use the response will be re-rendered."),a.default.createElement("p",null,"The plugin also makes the ",a.default.createElement(r.InlineJS,null,"response")," accessible to every component in your application through the ",a.default.createElement(r.InlineJS,null,"$curi")," property.")),a.default.createElement(i.CodeBlock,{lang:"jsx"},'import Vue from "vue";\nimport { CuriPlugin } from "@curi/vue";\n\nimport router from "./router";\n\nVue.use(CuriPlugin, { router });'),a.default.createElement(u.Subsection,{title:"Rendering with the response",id:"rendering-response"},a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"Vue allows you to render dynamic components using the"," ",a.default.createElement(r.InlineComponent,null,"component :is")," syntax. If you set Vue components as the"," ",a.default.createElement(r.InlineJS,null,"body")," properties on your responses, you can combine"," ",a.default.createElement(r.InlineComponent,null,"component :is")," and ",a.default.createElement(r.InlineJS,null,"response.body")," to render the appropriate component for a ",a.default.createElement(r.InlineJS,null,"response"),"."),a.default.createElement("p",null,"A root component is a good place to perform general application layout, like menus, in addition to rendering the response's"," ",a.default.createElement(r.InlineJS,null,"body"),".")),a.default.createElement(i.CodeBlock,{lang:"html"},'<template>\n  <header>\n    <NavLinks />\n  </header>\n  <main>\n    <component :is="$curi.response.body" />\n  </main>\n</template>\n\n<script>\n  import NavLinks from "./NavLinks";\n  export default {\n    components: { NavLinks }\n  };\n<\/script>'),a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"If your routes use an object to attach multiple components to a response, splitting them apart in computed properties may give your templates a cleaner look."),a.default.createElement("p",null,"If you do attach multiple components to a response, please remember that you want every route to set the same ",a.default.createElement(r.InlineJS,null,"body")," ","shape. Otherwise, you'll have to determine the shape and change how you render, which can quickly become messy.")),a.default.createElement(i.CodeBlock,{lang:"html"},'<script>\nconst routes = [\n  {\n    name: "Home",\n    path: "",\n    response() {\n      return {\n        body: {\n          main: HomeMain,\n          menu: HomeMenu\n        }\n      }\n    }\n  },\n  // ...\n];\n<\/script>\n\n<template>\n  <header>\n    <component :is="menu" />\n  </header>\n  <main>\n    <component :is="main" />\n  </main>\n</template>\n\n<script>\n  export default {\n    computed: {\n      main() {\n        return this.$curi.response.body.main;\n      },\n      menu() {\n        return this.$curi.response.body.menu;\n      }\n    }\n  }\n<\/script>'),a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"In addition to the ",a.default.createElement(r.InlineJS,null,"response"),", the current"," ",a.default.createElement(r.InlineJS,null,"navigation")," object (the ",a.default.createElement(r.InlineJS,null,"previous")," response and the navigation ",a.default.createElement(r.InlineJS,null,"action"),") is globally available through"," ",a.default.createElement(r.InlineJS,null,"$curi.navigation")),a.default.createElement("p",null,"The router is globally available as ",a.default.createElement(r.InlineJS,null,"$router"),"."))),a.default.createElement(u.Subsection,{title:"Accessibility",id:"accessibility"},a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"Managing the application's focus when navigating is useful for users who use screen readers. The ",a.default.createElement(r.InlineJS,null,"curi-focus")," directive provides a convenient way to focus a page's main content when it renders a new response."),a.default.createElement("p",null,"You can read some more about accessibility in the"," ",a.default.createElement(o.Link,{to:"Guide",params:{slug:"accessibility"}},"accessibility")," ","guide.")),a.default.createElement(i.CodeBlock,{lang:"html","data-line":"5"},'<template>\n  <header>\n    <NavLinks />\n  </header>\n  <main :tabIndex="-1" v-curi-focus="$curi.response">\n    <component :is="$curi.response.body" />\n  </main>\n</template>\n\n<script>\n  import NavLinks from "./NavLinks";\n  export default {\n    components: { NavLinks }\n  };\n<\/script>'))),a.default.createElement(u.Section,{title:"Navigating",id:"navigating"},a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"curi-link")," component is used to navigate between routes within an application. When it renders in the DOM, it will render as an anchor (",a.default.createElement(r.InlineComponent,null,"a"),") element."),a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"curi-link"),"'s ",a.default.createElement(r.InlineJS,null,"to")," prop describes which route clicking the link should navigate to. If you pass an invalid route name, Curi will warn you."),a.default.createElement("p",null,"If a route has any params (or if any of a route's ancestors have params for nested routes), the ",a.default.createElement(r.InlineJS,null,"params")," prop is used to pass these to the ",a.default.createElement(r.InlineComponent,null,"Link"),".")),a.default.createElement(i.CodeBlock,{lang:"html"},'<template>\n  <nav>\n    <ul>\n      <li>\n        <curi-link to="Home">Home</curi-link>\n      </li>\n      <li>\n        <curi-link to="About">About</curi-link>\n      </li>\n      <li>\n        <curi-link to="User" :params="{ id: \'blue\' }">\n          Blue\n        </curi-link>\n      </li>\n    </ul>\n  </nav>\n</template>'),a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"curi-link")," also takes ",a.default.createElement(r.InlineJS,null,"hash"),","," ",a.default.createElement(r.InlineJS,null,"query"),", and ",a.default.createElement(r.InlineJS,null,"state")," props to attach their values to the location that will be navigated to.")),a.default.createElement(i.CodeBlock,{lang:"jsx"},'<curi-link to="Home" hash="details">Home</curi-link>\n// renders\n<a href="/#details">Home</a>')),a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"Please check out the full"," ",a.default.createElement(o.Link,{to:"Package",params:{package:"vue"},hash:"API"},a.default.createElement(r.InlineJS,null,"@curi/vue"))," ","API documentation to see every component that the package provides.")))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=n(1),r=n(5),u=(n(9),n(76)),i=n(6)},145:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(i.Section,{title:"Rendering Responses",id:"rendering"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"curiProvider()")," function is used to create the component at the root of a Curi + React application. You can call this component anything that you want, but here it will be referred to as the ",a.default.createElement(r.InlineComponent,null,"Router"),"."),a.default.createElement(u.Note,null,a.default.createElement("p",null,"Why does ",a.default.createElement(r.InlineJS,null,"@curi/react-native")," export a function to create a component and not just a component? Props signify values that can change, but an application should only ever have one router. By hard-coding the ",a.default.createElement(r.InlineJS,null,"router")," into a component, we avoid having to handle the possibility of switching routers (which should not happen).")),a.default.createElement("p",null,a.default.createElement(r.InlineJS,null,"curiProvider()")," is passed the application's Curi router. The returned component will automatically add an"," ",a.default.createElement(o.Link,{to:"Guide",params:{slug:"navigating"},hash:"observer"},"observer")," ","to the Curi router when it mounts, so that it can re-render when there are new responses."),a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Router")," takes a render-invoked function as its"," ",a.default.createElement(r.InlineJS,null,"children")," prop. This function will be called with an object that has three properties— ",a.default.createElement(r.InlineJS,null,"response"),","," ",a.default.createElement(r.InlineJS,null,"router"),", and ",a.default.createElement(r.InlineJS,null,"navigation"),"—and returns the React element(s) that form the root of the application.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"import { curiProvider } from '@curi/react-native';\n\nimport router from \"./router\";\nconst Router = curiProvider(router);\n\nconst App = () => (\n  <Router>\n    {({ response, router, navigation }) => {\n      return <response.body />;\n    }}\n  </Router>\n);"),a.default.createElement(i.Subsection,{title:"What to return from children()",id:"children-return"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The render-invoked ",a.default.createElement(r.InlineJS,null,"children()")," is responsible for rendering the root elements for an application."),a.default.createElement("p",null,"Unlike with the DOM, React Native cannot have its initial render delayed with a ",a.default.createElement(r.InlineJS,null,"router.once()")," call. Instead, the"," ",a.default.createElement(r.InlineJS,null,"children()")," function should check if the"," ",a.default.createElement(r.InlineJS,null,"response")," exists, and rendering a loading component when it does not."),a.default.createElement("p",null,"If you set React components as the ",a.default.createElement(r.InlineJS,null,"body")," properties on your responses, you can create a React element for the"," ",a.default.createElement(r.InlineJS,null,"body")," component in this function."),a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Body")," element (it is useful to rename the"," ",a.default.createElement(r.InlineJS,null,"response"),"'s ",a.default.createElement(r.InlineJS,null,"body")," to ",a.default.createElement(r.InlineJS,null,"Body"),' for JSX transformation) is a placeholder for the "real" component that you render for a route. This means that the "real" component will be different for every route. When it comes to passing props to the'," ",a.default.createElement(r.InlineComponent,null,"Body"),", you ",a.default.createElement("em",null,"could")," use ",a.default.createElement(r.InlineJS,null,"response.name")," ","to determine what props to pass based on which route matched, but passing the same props to every route's ",a.default.createElement(r.InlineComponent,null,"Body")," is usually sufficient. Passing the entire ",a.default.createElement(r.InlineJS,null,"response")," is generally useful so that the route components can access any"," ",a.default.createElement(r.InlineJS,null,"params"),", ",a.default.createElement(r.InlineJS,null,"data"),", and other properties of the"," ",a.default.createElement(r.InlineJS,null,"response"),".")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"const App = () => (\n  <Router>\n    {({ response, router, navigation }) => {\n      // async route protection\n      if (!response) {\n        return <Loading />;\n      }\n\n      // rename body to Body for JSX transformation\n      const { body:Body } = response;\n      return (\n        <React.Fragment>\n          <NavLinks />\n          <Body response={response} />\n        </React.Fragment>\n      );\n    }}\n  </Router>\n);"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"If your routes use an object to attach multiple components to a response, the ",a.default.createElement(r.InlineJS,null,"children()")," function also provides a good place to split these apart."),a.default.createElement("p",null,"If you do take this approach, please remember that you want every route to set the same ",a.default.createElement(r.InlineJS,null,"body")," shape. Otherwise, you'll have to determine the shape and change how you render in the"," ",a.default.createElement(r.InlineJS,null,"children()")," function, which can quickly become messy.")),a.default.createElement(s.CodeBlock,{lang:"jsx","data-line":"20,24,27"},'const routes = [\n  {\n    name: "Home",\n    path: "",\n    response() {\n      return {\n        body: {\n          Main: HomeMain,\n          Menu: HomeMenu\n        }\n      }\n    }\n  },\n  // ...\n];\n\nconst App = () => (\n  <Router>\n    {({ response, router, navigation }) => {\n      const { Main, Menu } = response.body;\n      return (\n        <React.Fragment>\n          <Menu />\n          <Main response={response} />\n        </React.Fragment>\n      );\n    }}\n  </Router>\n);'),a.default.createElement(s.Explanation,null,a.default.createElement(u.Note,null,a.default.createElement("p",null,"There is a ",a.default.createElement(r.InlineComponent,null,"Curious")," component that you can render to access the ",a.default.createElement(r.InlineJS,null,"response"),", ",a.default.createElement(r.InlineJS,null,"router"),", and"," ",a.default.createElement(r.InlineJS,null,"navigation")," objects anywhere* in your application. This can help prevent having to pass props through multiple layers of components."),a.default.createElement("p",null,"* anywhere that is a child of your ",a.default.createElement(r.InlineComponent,null,"Router"),"."))),a.default.createElement(s.CodeBlock,{lang:"jsx"},'import { Curious } from "@curi/react-native";\n            \nconst BaseRouteName = ({ response }) => (\n  <Text>{response.name}</Text>\n);\n\nexport default function RouteName() {\n  return (\n    <Curious>\n      {({ response }) => <BaseRouteName response={response} />}\n    </Curious>\n  );\n}'))),a.default.createElement(i.Section,{title:"Navigating",id:"navigating"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Link")," component is used to navigate between routes within an application. By default, the ",a.default.createElement(r.InlineComponent,null,"Link")," will render as a ",a.default.createElement(r.InlineComponent,null,"TouchableHighlight"),", but you can specify a different component using the ",a.default.createElement(r.InlineJS,null,"anchor")," prop."),a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Link"),"'s ",a.default.createElement(r.InlineJS,null,"to")," prop describes which route clicking the link should navigate to. If you pass an invalid route name, Curi will warn you."),a.default.createElement("p",null,"If a route has any params (or if any of a route's ancestors have params for nested routes), the ",a.default.createElement(r.InlineJS,null,"params")," prop is used to pass these to the ",a.default.createElement(r.InlineComponent,null,"Link"),".")),a.default.createElement(s.CodeBlock,{lang:"jsx"},'import { Link } from "@curi/react-native";\n          \nconst NavLinks = () => (\n  <View>\n    <Link to="Home">\n      <Text>Home</Text>\n    </Link>\n    <Link to="About" anchor={TouchableOpacity}>\n      <Text>About</Text>\n    </Link>\n    <Link to="User" params={{ id: "blue" }}>\n      <Text>Blue</Text>\n    </Link>\n  </View>\n);'),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Link")," also takes ",a.default.createElement(r.InlineJS,null,"hash"),", ",a.default.createElement(r.InlineJS,null,"query"),", and ",a.default.createElement(r.InlineJS,null,"state")," props to attach their values to the location that will be navigated to.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},'<Link to="Home" hash="details">\n  <Text>Home</Text>\n</Link>')),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Please check out the full"," ",a.default.createElement(o.Link,{to:"Package",params:{package:"react-dom"},hash:"API"},a.default.createElement(r.InlineJS,null,"@curi/react-dom"))," ","API documentation to see every component that the package provides.")),a.default.createElement(i.Section,{title:"React Native Tips",id:"tips"},a.default.createElement(s.Explanation,null,a.default.createElement(u.Note,null,"This guide assumes that you are already familiar with React Native.")),a.default.createElement(i.Subsection,{title:"Back Button",id:"back-button"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"To add back button support, you need to use your"," ",a.default.createElement(r.InlineJS,null,"history")," object (which you can use directly or access through your router)."),a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"history.go()")," method is used for jumping between locations, so passing it ",a.default.createElement(r.InlineJS,null,"-1")," will jump back to the previous location."),a.default.createElement("p",null,"When the app is at the initial location, you may want to return"," ",a.default.createElement(r.InlineJS,null,"false")," to close the app when the user presses the back button.")),a.default.createElement(s.CodeBlock,null,"import { BackHandler } from 'react-native';\n\n// create your router\nconst router = curi(history, routes);\n\nBackHandler.addEventListener(\n  \"hardwareBackPress\",\n  () => {\n    // close the app when pressing back button\n    // while on the initial screen\n    if (router.history.index === 0) {\n      return false;\n    }\n    router.history.go(-1);\n    return true;\n  }\n);"))))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=n(1),r=n(5),u=n(9),i=n(76),s=n(6)},146:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(i.Section,{title:"Rendering Responses",id:"rendering"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"curiProvider()")," function is used to create the component at the root of a Curi + React application. You can call this component anything that you want, but here it will be referred to as the ",a.default.createElement(r.InlineComponent,null,"Router"),"."),a.default.createElement(u.Note,null,a.default.createElement("p",null,"Why does ",a.default.createElement(r.InlineJS,null,"@curi/react-dom")," export a function to create a component and not just a component? Props signify values that can change, but an application should only ever have one router. By hard-coding the ",a.default.createElement(r.InlineJS,null,"router")," into a component, we avoid having to handle the possibility of switching routers (which should not happen).")),a.default.createElement("p",null,a.default.createElement(r.InlineJS,null,"curiProvider()")," is passed the application's Curi router. The returned component will automatically add an"," ",a.default.createElement(o.Link,{to:"Guide",params:{slug:"navigating"},hash:"observer"},"observer")," ","to the Curi router when it mounts, so that it can re-render when there are new responses."),a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Router")," takes a render-invoked function as its"," ",a.default.createElement(r.InlineJS,null,"children")," prop. This function will be called with an object that has three properties— ",a.default.createElement(r.InlineJS,null,"response"),","," ",a.default.createElement(r.InlineJS,null,"router"),", and ",a.default.createElement(r.InlineJS,null,"navigation"),"—and returns the React element(s) that form the root of the application.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},'import { curiProvider } from \'@curi/react-dom\';\n\nimport router from "./router";\nconst Router = curiProvider(router);\n\n// router.once() is used to delay rendering in case\n// the initially matched route is asynchronous\nrouter.once(() => {\n  ReactDOM.render((\n    <Router>\n      {({ response, router, navigation }) => {\n        return <response.body />;\n      }}\n    </Router>\n  ), document.getElementById("root"));\n});'),a.default.createElement(i.Subsection,{title:"What to return from children()",id:"children-return"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The render-invoked ",a.default.createElement(r.InlineJS,null,"children()")," is responsible for rendering the root elements for an application."),a.default.createElement("p",null,"If you set React components as the ",a.default.createElement(r.InlineJS,null,"body")," properties on your responses, you can create a React element for the"," ",a.default.createElement(r.InlineJS,null,"body")," component in this function."),a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Body")," element (it is useful to rename the"," ",a.default.createElement(r.InlineJS,null,"response"),"'s ",a.default.createElement(r.InlineJS,null,"body")," to ",a.default.createElement(r.InlineJS,null,"Body"),' for JSX transformation) is a placeholder for the "real" component that you render for a route. This means that the "real" component will be different for every route. When it comes to passing props to the'," ",a.default.createElement(r.InlineComponent,null,"Body"),", you ",a.default.createElement("em",null,"could")," use ",a.default.createElement(r.InlineJS,null,"response.name")," ","to determine what props to pass based on which route matched, but passing the same props to every route's ",a.default.createElement(r.InlineComponent,null,"Body")," is usually sufficient. Passing the entire ",a.default.createElement(r.InlineJS,null,"response")," is generally useful so that the route components can access any"," ",a.default.createElement(r.InlineJS,null,"params"),", ",a.default.createElement(r.InlineJS,null,"data"),", and other properties of the"," ",a.default.createElement(r.InlineJS,null,"response"),".")),a.default.createElement(s.CodeBlock,{lang:"jsx"},'ReactDOM.render((\n  <Router>\n    {({ response, router, navigation }) => {\n      // rename body to Body for JSX transformation\n      const { body:Body } = response;\n      return (\n        <React.Fragment>\n          <header>\n            <NavLinks />\n          </header>\n          <main>\n            <Body response={response} />\n          </main>\n        </React.Fragment>\n      );\n    }}\n  </Router>\n), document.getElementById("root"));'),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"If your routes use an object to attach multiple components to a response, the ",a.default.createElement(r.InlineJS,null,"children()")," function also provides a good place to split these apart."),a.default.createElement("p",null,"If you do take this approach, please remember that you want every route to set the same ",a.default.createElement(r.InlineJS,null,"body")," shape. Otherwise, you'll have to determine the shape and change how you render in the"," ",a.default.createElement(r.InlineJS,null,"children()")," function, which can quickly become messy.")),a.default.createElement(s.CodeBlock,{lang:"jsx","data-line":"20,24,27"},'const routes = [\n  {\n    name: "Home",\n    path: "",\n    response() {\n      return {\n        body: {\n          Main: HomeMain,\n          Menu: HomeMenu\n        }\n      }\n    }\n  },\n  // ...\n];\n\nReactDOM.render((\n  <Router>\n    {({ response, router, navigation }) => {\n      const { Main, Menu } = response.body;\n      return (\n        <React.Fragment>\n          <header>\n            <Menu />\n          </header>\n          <main>\n            <Main response={response} />\n          </main>\n        </React.Fragment>\n      );\n    }}\n  </Router>\n), document.getElementById("root"));'),a.default.createElement(s.Explanation,null,a.default.createElement(u.Note,null,a.default.createElement("p",null,"There is a ",a.default.createElement(r.InlineComponent,null,"Curious")," component that you can render to access the ",a.default.createElement(r.InlineJS,null,"response"),", ",a.default.createElement(r.InlineJS,null,"router"),", and"," ",a.default.createElement(r.InlineJS,null,"navigation")," objects anywhere* in your application. This can help prevent having to pass props through multiple layers of components."),a.default.createElement("p",null,"* anywhere that is a child of your ",a.default.createElement(r.InlineComponent,null,"Router"),"."))),a.default.createElement(s.CodeBlock,{lang:"jsx"},'import { Curious } from "@curi/react-dom";\n            \nconst BaseRouteName = ({ response }) => (\n  <div>{response.name}</div>\n);\n\nexport default function RouteName() {\n  return (\n    <Curious>\n      {({ response }) => <BaseRouteName response={response} />}\n    </Curious>\n  );\n}')),a.default.createElement(i.Subsection,{title:"Accessibility",id:"accessibility"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Managing the application's focus when navigating is useful for users who use screen readers. The ",a.default.createElement(r.InlineComponent,null,"Focus")," component provides a convenient way to focus a page's main content when it renders a new response."),a.default.createElement("p",null,"You can read some more about accessibility in the"," ",a.default.createElement(o.Link,{to:"Guide",params:{slug:"accessibility"}},"accessibility")," ","guide.")),a.default.createElement(s.CodeBlock,{lang:"jsx","data-line":"12-18"},'import { Focus } from "@curi/react-dom";\n            \nReactDOM.render((\n  <Router>\n    {({ response }) => {\n      const { body:Body } = response;\n      return (\n        <React.Fragment>\n          <header>\n            <NavLinks />\n          </header>\n          <Focus>\n            {ref => (\n              <main ref={ref} tabIndex={-1}>\n                <Body response={response} />\n              </main>\n            )}\n          </Focus>\n        </React.Fragment>\n      );\n    }}\n  </Router>\n), document.getElementById("root"));'))),a.default.createElement(i.Section,{title:"Navigating",id:"navigating"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Link")," component is used to navigate between routes within an application. When it renders in the DOM, it will render as an anchor (",a.default.createElement(r.InlineComponent,null,"a"),") element."),a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Link"),"'s ",a.default.createElement(r.InlineJS,null,"to")," prop describes which route clicking the link should navigate to. If you pass an invalid route name, Curi will warn you."),a.default.createElement("p",null,"If a route has any params (or if any of a route's ancestors have params for nested routes), the ",a.default.createElement(r.InlineJS,null,"params")," prop is used to pass these to the ",a.default.createElement(r.InlineComponent,null,"Link"),".")),a.default.createElement(s.CodeBlock,{lang:"jsx"},'import { Link } from "@curi/react-dom";\n          \nconst NavLinks = () => (\n  <nav>\n    <ul>\n      <li>\n        <Link to="Home">Home</Link>\n      </li>\n      <li>\n        <Link to="About">About</Link>\n      </li>\n      <li>\n        <Link to="User" params={{ id: "red" }}>Red</Link>\n      </li>\n    </ul>\n  </nav>\n);'),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineComponent,null,"Link")," also takes ",a.default.createElement(r.InlineJS,null,"hash"),", ",a.default.createElement(r.InlineJS,null,"query"),", and ",a.default.createElement(r.InlineJS,null,"state")," props to attach their values to the location that will be navigated to.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},'<Link to="Home" hash="details">Home</Link>\n// renders\n<a href="/#details">Home</a>')),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Please check out the full"," ",a.default.createElement(o.Link,{to:"Package",params:{package:"react-dom"},hash:"API"},a.default.createElement(r.InlineJS,null,"@curi/react-dom"))," ","API documentation to see every component that the package provides.")))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=n(1),r=n(5),u=n(9),i=n(76),s=n(6)},147:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Navigation and observation are closely linked. Navigation is used to change locations, while observation is used to detect navigation changes and react (e.g. re-render the application).")),a.default.createElement(i.Section,{title:"Navigation",id:"navigation"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"When you create a router, you pass it a history object. That history object is responsible for tracking all navigation within your application. Navigation can be triggered a variety of ways."),a.default.createElement("p",null,'The first type is "external" navigation, meaning it comes from outside of the application. For a website, this would be navigating by entering a URL in the address bar or by pressing the browser\'s forward/back buttons.'),a.default.createElement("p",null,'The second type of navigation is "internal", where you use code to navigate to a new location. This is predominantly done by clicking links.'),a.default.createElement("p",null,"This guide is only going to discuss how to perform internal navigation, since that is the only type that you need to perform with code.")),a.default.createElement(s.CodeBlock,null,'import Browser from "@hickory/browser";\nimport { curi } from "@curi/router";\n\nimport routes from "./routes";\n\n// this history object is responsible for\n// tracking navigation\nconst history = Browser();\n\nconst router = curi(history, routes);'),a.default.createElement(i.Subsection,{title:"Navigation With History",id:"with-history"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Locations are stored in what is essentially an array (this varies by history type). An index is used to keep track of which location in the array is the current location."),a.default.createElement(u.Note,null,"With the browser and hash histories, you cannot actually access the array of locations/index. Browsers do not expose this because accessing this data could cause security issues.")),a.default.createElement(s.CodeBlock,null,'// array of locations\n[\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/three" }\n]\n// index = 2, current location = { pathname: "/three" }'),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"There are three ways to change locations: popping, pushing, and replacing and two methods for making these changes:"," ",a.default.createElement(r.InlineJS,null,"history.go()")," and ",a.default.createElement(r.InlineJS,null,"history.navigate()"),".")),a.default.createElement(i.Subsection,{tag:"h4",title:"Pop",id:"navigation-pop"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Popping means that you change the index to another (valid) index in the array. Popping is performed by specifying how many locations forward (positive numbers) or backward (negative numbers) you want to go. When you click a browser's back button, that is essentially popping by negative one."),a.default.createElement("p",null,"The history object's ",a.default.createElement(r.InlineJS,null,"go()")," function is used for popping between locations.")),a.default.createElement(s.CodeBlock,{"data-line":"9,16"},'locations = [\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/three" }\n]\nindex = 2\n// current location = { pathname: "/three" }\n\nhistory.go(-2)\n\nlocations = [\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/three" }\n]\nindex = 0\n// current location = { pathname: "/one" }')),a.default.createElement(i.Subsection,{tag:"h4",title:"Push",id:"navigation-push"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Pushing adds a new location after the current location in the array. Pushing is destructive because if there were any locations after the current location, they are lost when you push a new location."),a.default.createElement("p",null,"The history object's ",a.default.createElement(r.InlineJS,null,"navigate()")," method is used for pushing new locations. In order to ensure that a location is pushed, the ",a.default.createElement(r.InlineJS,null,'"PUSH"')," argument should be passed to the method call.")),a.default.createElement(s.CodeBlock,{"data-line":"9,13,15"},'locations = [\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/three" }\n]\nindex = 0\n// current location = { pathname: "/one" }\n\nhistory.navigate("/four", "PUSH")\n\nlocations = [\n  { pathname: "/one" },\n  { pathname: "/four" }\n]\nindex = 1\n// current location = { pathname: "/four" }')),a.default.createElement(i.Subsection,{tag:"h4",title:"Replace",id:"navigation-replace"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Replacing replaces the location at the current index with a new location. When you replace the current location, it has no effect on locations after the current one."),a.default.createElement("p",null,"The history object's ",a.default.createElement(r.InlineJS,null,"navigate()")," method is used for replacing locations. In order to ensure that a location is replaced, the ",a.default.createElement(r.InlineJS,null,'"REPLACE"')," argument should be passed to the method call.")),a.default.createElement(s.CodeBlock,{"data-line":"9,14"},'locations = [\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/three" }\n]\nindex = 2\n// current location = { pathname: "/three" }\n\nhistory.navigate("/four", "REPLACE")\n\nlocations = [\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/four" }\n]\nindex = 2\n// current location = { pathname: "/four" }')),a.default.createElement(i.Subsection,{tag:"h4",title:"Anchor",id:"navigation-anchor"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"history.navigate()")," method has one other way of navigating, which is also its default method. This method is called ",a.default.createElement(r.InlineJS,null,'"ANCHOR"')," because it simulates how clicking an anchor in a non-single-page application works."),a.default.createElement("p",null,"Anchor navigation is a hybrid of pushing and replacing. If you attempt to navigate to the same location as the current location (same ",a.default.createElement(r.InlineJS,null,"pathname"),", ",a.default.createElement(r.InlineJS,null,"query"),", and ",a.default.createElement(r.InlineJS,null,"hash"),"), then the current location will be replaced. If you attempt to navigate to a new location, it will be pushed."),a.default.createElement("p",null,"Unless you have a reason to explicitly push/replace, anchor navigation is what you should use for navigation.")),a.default.createElement(s.CodeBlock,{"data-line":"8,18,25,27"},'locations = [\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/three" }\n]\nindex = 2\n\nhistory.navigate("/three")\n\n// same location, so nothing changes\nlocations = [\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/three" }\n]\nindex = 2\n\nhistory.navigate("/four")\n\n// new location is pushed\nlocations = [\n  { pathname: "/one" },\n  { pathname: "/two" },\n  { pathname: "/three" },\n  { pathname: "/four" }\n]\nindex = 3'))),a.default.createElement(i.Subsection,{title:"Navigation with the Router",id:"with-router"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"In the above examples, navigation is done using URL pathnames, but one of the principles of Curi is that you shouldn't have to write URLs yourself. To help with this, the router has its own"," ",a.default.createElement(r.InlineJS,null,"navigate()")," method."),a.default.createElement("p",null,a.default.createElement(r.InlineJS,null,"router.navigate()")," takes an object with the"," ",a.default.createElement(r.InlineJS,null,"name")," of the route to navigate to. If the route (or any of its ancestors) requires ",a.default.createElement(r.InlineJS,null,"params"),", they should also be provided through the object."),a.default.createElement("p",null,a.default.createElement(r.InlineJS,null,"query"),", ",a.default.createElement(r.InlineJS,null,"hash"),", and ",a.default.createElement(r.InlineJS,null,"state")," properties can also be provided to pass any of those location details."),a.default.createElement("p",null,a.default.createElement(r.InlineJS,null,"router.navigate()")," does anchor style (",a.default.createElement(r.InlineJS,null,'"ANCHOR"'),") navigation by default, but if you want to do"," ",a.default.createElement(r.InlineJS,null,'"PUSH"'),"/",a.default.createElement(r.InlineJS,null,'"REPLACE"')," navigation, you can provide the type with the ",a.default.createElement(r.InlineJS,null,"method")," property.")),a.default.createElement(s.CodeBlock,null,'router.navigate({\n  name: "User",\n  params: { id: 1423 }\n});\n\n// replace the current location with the Login route\nrouter.navigte({\n  name: "Login",\n  state: { next: "/profile" }\n  method: "REPLACE"\n});'))),a.default.createElement(i.Section,{title:"Detecting Navigation",id:"detecting-navigation"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The Curi router uses an observer pattern to call registered functions (called response handlers) when there is a new response. The main function for response handlers is to use the new response to render the application, but any other functionality (like logging) can also be performed.")),a.default.createElement(i.Subsection,{title:"Response Handlers",id:"response-handlers"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"When response handlers are called, they are passed an object with three properties:"," ",a.default.createElement(o.Link,{to:"Package",params:{package:"router"},hash:"properties"},a.default.createElement(r.InlineJS,null,"router")),","," ",a.default.createElement(o.Link,{to:"Guide",params:{slug:"routes-and-responses"},hash:"responses"},a.default.createElement(r.InlineJS,null,"response")),", and"," ",a.default.createElement(o.Link,{to:"Guide",params:{slug:"navigation-objects"}},a.default.createElement(r.InlineJS,null,"navigation")),". Which objects/properties you use depends on what the response handler is doing.")),a.default.createElement(s.CodeBlock,null,"function responseHandler({\n  router,\n  response,\n  navigation\n}) {\n  // ...\n}")),a.default.createElement(i.Subsection,{title:"Registering Response Handlers",id:"registering"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"There are two ways to attach response handlers to the router:"," ",a.default.createElement(r.InlineJS,null,"router.once()")," and ",a.default.createElement(r.InlineJS,null,"router.observe()"),". Response handlers registered with ",a.default.createElement(r.InlineJS,null,"router.once()")," will only be called one time, while those registered with"," ",a.default.createElement(r.InlineJS,null,"router.observe()")," will be called for every new response."),a.default.createElement("p",null,"When you register a response handler using"," ",a.default.createElement(r.InlineJS,null,"router.observer()"),", it will return a function that you can use to stop calling the response handler for new responses. You should rarely need to do this, but it can be useful for memory management if you are adding and removing lots of observers.")),a.default.createElement(s.CodeBlock,null,"// fn will only be called one time\nrouter.once(fn);\n\n// obs will be called for every new response\nconst stop = router.observer(fn);")),a.default.createElement(i.Subsection,{title:"Use Cases",id:"use-cases"},a.default.createElement("p",null,"What should you use response handlers for?"),a.default.createElement(i.Subsection,{title:"Setup",id:"setup"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"If any of the routes in an application have ",a.default.createElement(r.InlineJS,null,"resolve")," ","functions, when they match their responses are created asynchronously. When the application first renders, if the router matches an async route, the response isn't immediately ready to use. To deal with this, you can use an observer to render once the initial response is ready."),a.default.createElement("p",null,"A setup function only needs to be called one time, so you can register it with ",a.default.createElement(r.InlineJS,null,"router.once()"),"."),a.default.createElement(u.Note,null,"In most applications, waiting for the initial response is the only time you may need to write response handlers yourself.")),a.default.createElement(s.CodeBlock,{lang:"jsx"},"const Router = curiProvider(router);\n              \nfunction setup() {\n  ReactDOM.render((\n    <Router>\n      {({ response }) => <response.body />}\n    </Router>\n  ), document.getElementById('root'));\n}\n\nrouter.once(setup);")),a.default.createElement(i.Subsection,{title:"Rendering",id:"rendering"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Rendering libraries need to know when there is a new response so that they can re-render the application."),a.default.createElement("p",null,"The Curi rendering packages (",a.default.createElement(o.Link,{to:"Package",params:{package:"react-dom"}},a.default.createElement(r.InlineJS,null,"@curi/react-dom")),","," ",a.default.createElement(o.Link,{to:"Package",params:{package:"react-native"}},a.default.createElement(r.InlineJS,null,"@curi/react-native")),","," ",a.default.createElement(o.Link,{to:"Package",params:{package:"vue"}},a.default.createElement(r.InlineJS,null,"@curi/vue")),", and"," ",a.default.createElement(o.Link,{to:"Package",params:{package:"svelte"}},a.default.createElement(r.InlineJS,null,"@curi/svelte")),") setup an observer internally so that they can automatically re-render."),a.default.createElement("p",null,"If you are using vanilla JavaScript to render your application or you are writing your own framework implementation, you would use ",a.default.createElement(r.InlineJS,null,"router.observer()")," to re-render new responses.")),a.default.createElement(s.CodeBlock,null,"function observer({ response }) {\n  // let the app know there is a new response\n}\n\nrouter.observer(observer);")),a.default.createElement(i.Subsection,{title:"Side Effects",id:"side-effects"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Side effects are observers that are provided to the router at creation instead of by calling ",a.default.createElement(r.InlineJS,null,"router.observe()"),". These can be useful for tasks that are not rendering related as well as for tasks that need to be performed after a render has completed."),a.default.createElement("p",null,"The"," ",a.default.createElement(o.Link,{to:"Package",params:{package:"side-effect-title"}},a.default.createElement(r.InlineJS,null,"@curi/side-effect-title"))," ","package provides a side effect that will use"," ",a.default.createElement(r.InlineJS,null,"response.title")," to set the page's"," ",a.default.createElement(r.InlineJS,null,"document.title"),"."),a.default.createElement("p",null,"With single-page applications, clicking on links wish hashes won't always scroll to the matching element in the page. The"," ",a.default.createElement(o.Link,{to:"Package",params:{package:"side-effect-scroll"}},a.default.createElement(r.InlineJS,null,"@curi/side-effect-scroll"))," ","package adds this behavior by scrolling the page to the element that matches the new response's hash (",a.default.createElement(r.InlineJS,null,"response.location.hash"),") after the new response has rendered."),a.default.createElement("p",null,"If you need to add logging to your application, you could write your own observer to do this. Your observer can either be added as a side effect when the router is constructed or later using"," ",a.default.createElement(r.InlineJS,null,"router.observe()"),".")),a.default.createElement(s.CodeBlock,null,"function logger({ response }) {\n  loggingAPI.add(response.location);\n}\n\n// as a side-effect\nconst router = curi(history, routes, {\n  sideEffects: [{ fn: logger }]\n});\n\n// as an observer\nrouter.observe(logger);")))))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=n(1),r=n(5),u=n(9),i=n(76),s=n(6)},148:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"Curi can have synchronous and asynchronous routes."),a.default.createElement("p",null,"When a navigation event is triggered (e.g. clicking a link or button), the router will match a route. If the route is synchronous, the response will be emitted immediately. If the route is asynchronous, the response will not be emitted until the route's async functions have finished. This is useful for code splitting and preloading data for a route."),a.default.createElement("p",null,"By default, routes are synchronous. If a route has any functions in its ",a.default.createElement(r.InlineJS,null,"resolve")," object, it becomes async.")),a.default.createElement(i.CodeBlock,null,'// sync\n{ name: "Home", path: "" },\n\n// async\n{\n  name: "User",\n  path: "user/:id,\n  // any functions in here makes the route async\n  resolve: {\n    body: () => import("./components/User"),\n  }\n}'),a.default.createElement(u.Section,{title:"Async Things to Think About",id:"think"},a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"For the most part, it shouldn't matter to you (or your users) whether Curi is sync or async, but there are a couple of things that you should be aware of when it comes to async matching.")),a.default.createElement("ol",null,a.default.createElement("li",null,a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"If the initial route that matches is async and you try to render immediately, the ",a.default.createElement(r.InlineJS,null,"response")," will be ",a.default.createElement(r.InlineJS,null,"null"),". You can wait to render until the initial response is ready with"," ",a.default.createElement(r.InlineJS,null,"router.oncd()"),". The function you pass to that will be called one time, once the initial response is ready.")),a.default.createElement(i.CodeBlock,null,"const router = curi(history, routes);\nrouter.once(() => {\n  // the initial response is ready,\n  // so it is safe to render\n  ReactDOM.render(...);\n});")),a.default.createElement("li",null,a.default.createElement(i.Explanation,null,a.default.createElement("p",null,"With async routes, there is a delay between when the user clicks a link and when the new response is emitted. During this time, the navigation can be interrupted with a new navigation. Curi handles this internally, but you might want to update your UI after a link/button is clicked to indicate that the next page is loading."),a.default.createElement("p",null,"You can see an example of this in the"," ",a.default.createElement(o.Link,{to:"Example",params:{category:"react",slug:"data-loading"}},"Data Loading Example"),".")),a.default.createElement(i.CodeBlock,{lang:"jsx"},'<Link\n  to="User"\n  params={{ id: 1 }}\n  onClick={() => {\n    // display a loading bar when\n    // the user clicks a link.\n    nprogress.start();\n  }}\n>User 1</Link>\n\n// use a side effect to finish\n// loading bar when the new response\n// is ready\nconst finishLoading = () => {\n  nprogress.done();\n};\n\nconst router = curi(history, routes, {\n  sideEffects: [finishLoading]\n});')))))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=n(1),r=n(5),u=n(76),i=(n(9),n(6))},149:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Routes describe the valid locations within an application. Responses provide data about the route that matches the current location.")),a.default.createElement(i.Section,{title:"Responses",id:"responses"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"When Curi receives a location, it compares the location's"," ",a.default.createElement(r.InlineJS,null,"pathname")," to each route's ",a.default.createElement(r.InlineJS,null,"path")," to find which one matches best and uses that route to create a response object.")),a.default.createElement(i.Subsection,{title:"The Properties of a Response Object",id:"response-properties"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"There are two types of response properties.")),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,'The "match" properties are set based on the route that matches a location. A response always has these properties.')),a.default.createElement(s.CodeBlock,null,"// match properties\n{\n  // The location object used to generate the response.\n  location: { pathname: '/photos/6789/12345', ... },\n\n  // The name of the best matching route\n  name: 'Photo',\n\n  // The name of ancestor routes that matched\n  // part of the location's pathname\n  partials: ['Album'],\n\n  // An object containing the values parsed\n  // from the pathname by path-to-regexp.\n  // This includes params from ancestor routes.\n  params: { photoID: 12345, albumID: 6789 },\n}"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,'The "settable" properties are ones that are added by a matched route\'s ',a.default.createElement(r.InlineJS,null,"response()")," function. These only exist on the response when they are returned by a route's ",a.default.createElement(r.InlineJS,null,"response()")," ","function."),a.default.createElement("p",null,'The "settable" properties are:'),a.default.createElement("table",null,a.default.createElement("thead",null,a.default.createElement("tr",null,a.default.createElement("th",null,"property"),a.default.createElement("th",null,"description"))),a.default.createElement("tbody",null,a.default.createElement("tr",null,a.default.createElement("td",null,"body"),a.default.createElement("td",null,"The component(s) that should be rendered for a route.")),a.default.createElement("tr",null,a.default.createElement("td",null,"status"),a.default.createElement("td",null,"An http status, mostly useful for server side rendering.")),a.default.createElement("tr",null,a.default.createElement("td",null,"data"),a.default.createElement("td",null,"A place to attach any data you want to the response, such as data loaded in the route's ",a.default.createElement(r.InlineJS,null,"resolve")," functions.")),a.default.createElement("tr",null,a.default.createElement("td",null,"title"),a.default.createElement("td",null,"The response's title, which can be used with"," ",a.default.createElement(o.Link,{to:"Package",params:{package:"side-effect-title"}},a.default.createElement(r.InlineJS,null,"@curi/side-effect-title"))," ","to set the browsers tab's title.")),a.default.createElement("tr",null,a.default.createElement("td",null,"error"),a.default.createElement("td",null,"A convenient place to attach any errors to the response.")),a.default.createElement("tr",null,a.default.createElement("td",null,"redirectTo"),a.default.createElement("td",null,"An object describing a route that Curi should automatically redirect to."))))),a.default.createElement(s.CodeBlock,null,"// settable properties (optional)\n{\n  body: Photo,\n  // or maybe\n  body: {\n    menu: PhotoMenu,\n    main: Photo\n  },\n  // Please see below for more information\n  // about this property\n\n  status: 200,\n\n  data: {...},\n\n  title: 'Photo 12345',\n\n  error: undefined,\n\n  redirectTo: {...}\n}")),a.default.createElement(i.Subsection,{title:"Response Body",id:"response-body"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Curi isn't strict about how you use responses, but you will most likely always want to use a route's ",a.default.createElement(r.InlineJS,null,"response()")," function to attach a ",a.default.createElement(r.InlineJS,null,"body")," property to a response. The usual pattern is to use a route's ",a.default.createElement(r.InlineJS,null,"body")," property to describe which component(s) to render when a route matches. This can either be a single component for basic layouts or an object with a number of components for"," ",a.default.createElement(o.Link,{to:"Example",params:{category:"react",slug:"multi-body"}},"advanced layouts"),"."),a.default.createElement(u.Note,null,"Each route should use the same ",a.default.createElement(r.InlineJS,null,"body"),' "shape". If one route returns a single component while another route return an object, you will be making rendering more complicated for yourself.')),a.default.createElement(s.CodeBlock,null,"// do NOT do this\n// mixing body shapes complicates rendering\nconst routes = [\n  {\n    response() {\n      return { body: One }\n    }\n  },\n  {\n    response() {\n      return {\n        body: {\n          main: Main,\n          menu: Menu\n        }\n      }\n    }\n  }\n];")),a.default.createElement(i.Subsection,{title:"Redirect Response",id:"redirect-properties"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"When a route's ",a.default.createElement(r.InlineJS,null,"response()")," function returns an object with a"," ",a.default.createElement(o.Link,{to:"Package",params:{package:"router"},hash:"response"},a.default.createElement(r.InlineJS,null,"redirectTo")," property"),", the router will use it to generate a location object that Curi will automatically redirect to.")),a.default.createElement(s.CodeBlock,null,"{\n  // The redirectTo property provides information on\n  // where you should redirect to\n  redirectTo: { pathname: '/login' }\n}"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"You can choose whether or not you want responses with a"," ",a.default.createElement(r.InlineJS,null,"redirectTo")," property to be emitted. If they are not emitted, then the router will redirect without the application's observers knowing about the redirect. The default behavior is to emit redirects, but this also means that you have to render using the redirect response. The ",a.default.createElement(r.InlineJS,null,"{ emitRedirects: false }")," ","option prevents this.")),a.default.createElement(s.CodeBlock,null,"const router = curi(history, routes, {\n  emitRedirects: false\n});"))),a.default.createElement(i.Section,{title:"Routes",id:"routes"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Routes are JavaScript objects with two required properties—",a.default.createElement(r.InlineJS,null,"name")," ","and ",a.default.createElement(r.InlineJS,null,"path"),"—and a number of optional properties."),a.default.createElement("p",null,"A route's ",a.default.createElement(r.InlineJS,null,"path")," is used to determine if a route matches a location. Path strings use"," ",a.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp"},a.default.createElement(r.InlineJS,null,"path-to-regexp"))," ","formatting, which allows you to define dynamic path parameters that a route should match."),a.default.createElement("p",null,"A route's ",a.default.createElement(r.InlineJS,null,"name")," is a unique identifier for a route. The"," ",a.default.createElement(r.InlineJS,null,"name")," is used to"," ",a.default.createElement(o.Link,{to:"Guide",params:{slug:"route-interactions"}},"interact")," ","with a specific route.")),a.default.createElement(s.CodeBlock,null,'const routes = [\n  {\n    name: "Home",\n    path: ""\n  },\n  {\n    name: "Album",\n    // the "id" segment can be any value\n    path: "a/:id"\n  }\n];'),a.default.createElement(i.Subsection,{title:"Resolve",id:"resolve"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"When a route matches, you might want to perform some actions before the application re-renders. This can include validating that a user is authorized to navigate to a route and loading data based on the path parameters parsed from the location."),a.default.createElement("p",null,"A route's ",a.default.createElement(r.InlineJS,null,"resolve")," property is an optional object for attaching functions to a route. A response will not be emitted until after all of a route's ",a.default.createElement(r.InlineJS,null,"resolve")," functions have finished."),a.default.createElement("p",null,"A route with ",a.default.createElement(r.InlineJS,null,"resolve")," properties is asynchronous, which has effects to be aware of. You can read about these in the"," ",a.default.createElement(o.Link,{to:"Guide",params:{slug:"sync-or-async"}},"Sync or Async")," ","guide."),a.default.createElement("p",null,"Curi uses Promises to manage a route's ",a.default.createElement(r.InlineJS,null,"resolve")," ","functions. Each function should return a Promise. This makes it easy to wait for all of the ",a.default.createElement(r.InlineJS,null,"resolve")," functions to complete before emitting the response for a matched route."),a.default.createElement(u.Note,null,a.default.createElement(r.InlineJS,null,"Promise.resolve()")," can be used to return a Promise."),a.default.createElement("p",null,"When ",a.default.createElement(r.InlineJS,null,"resolve"),' functions are called, they will be passed an object with the "match" properties of a response. These are the matched route\'s ',a.default.createElement(r.InlineJS,null,"name"),", the ",a.default.createElement(r.InlineJS,null,"location"),", an object of parsed ",a.default.createElement(r.InlineJS,null,"params"),", and an array of the names of"," ",a.default.createElement(r.InlineJS,null,"partial")," route matches.")),a.default.createElement(s.CodeBlock,null,'{\n  name: "User",\n  path: "u/:id",\n  resolve: {\n    authorized: () => {\n      // run code to verify the user can view the page\n      return Promise.resolve(true);\n    },\n    body: () => {\n      // import the User component using the import() API\n      return import("./components/User");\n    },\n    data: ({ name, location, params, partials }) => {\n      // get specific data using the route\'s params\n      return UserAPI.get(params.id);\n    }\n  }\n}')),a.default.createElement(i.Subsection,{title:"The Response Function",id:"route-response"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Each route can have a ",a.default.createElement(r.InlineJS,null,"response()")," function. The role of the ",a.default.createElement(r.InlineJS,null,"response()")," function is to return an object of properties to merge onto the response object that will be emitted for the new location."),a.default.createElement("p",null,"Only valid response properties will be merged onto the response. These are the optional response properties listed above (",a.default.createElement(r.InlineJS,null,"body"),", ",a.default.createElement(r.InlineJS,null,"title"),", ",a.default.createElement(r.InlineJS,null,"status"),", ",a.default.createElement(r.InlineJS,null,"data"),","," ",a.default.createElement(r.InlineJS,null,"redirectTo"),", and ",a.default.createElement(r.InlineJS,null,"error"),")."),a.default.createElement("p",null,"The function receives an object with a number of properties you might find useful."),a.default.createElement("p",null,"The first is an object of ",a.default.createElement(r.InlineJS,null,"resolve")," properties (the base response properties)."),a.default.createElement("p",null,"The second is a ",a.default.createElement(r.InlineJS,null,"resolved")," object, which contains the resolved values from the route's ",a.default.createElement(r.InlineJS,null,"resolve")," functions."),a.default.createElement("p",null,"The third property is an ",a.default.createElement(r.InlineJS,null,"error"),", which is only defined if one of the ",a.default.createElement(r.InlineJS,null,"resolve")," functions throws an error and you don't catch it.")),a.default.createElement(s.CodeBlock,null,'import User from "./components/User";\n\nconst routes = [\n  {\n    name: "User",\n    path: "u/:id",\n    resolve: {\n      data: ({ params }) => UserAPI.get(params.id)\n    },\n    response({ match, resolved, error }) {\n      if (error) {\n        // ...\n      }\n      return {\n        body: User,\n        data: resolved.data,\n        title: `User ${match.params.id}`\n      };\n    }\n  }\n];')),a.default.createElement(i.Section,{title:"Matching Routes",id:"matching-routes"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Whenever Curi receives a new location, it will determine which route has a ",a.default.createElement(r.InlineJS,null,"path")," that matches the new location's"," ",a.default.createElement(r.InlineJS,null,"pathname")," by walking over the route objects in the order that they are defined in the array. If a route has"," ",a.default.createElement(r.InlineJS,null,"children"),", those will be checked before moving to the route's nest sibling."),a.default.createElement("p",null,"We'll use this simple route setup to demonstrate how this works.")),a.default.createElement(s.CodeBlock,null,"const routes = [\n  {\n    name: 'Home',\n    path: '',\n  },\n  {\n    name: 'Album',\n    path: 'a/:album'\n  },\n  {\n    name: 'Not Found',\n    path: '(.*)' // this matches EVERY pathname\n  }\n];"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Curi's default matching behavior looks for exact matches. This means that when the route only matches part of the pathname, it does not count as a match. If the user navigates to a location with the pathname ",a.default.createElement(r.InlineJS,null,'"/a/red/yellow"'),", the ",a.default.createElement(r.InlineJS,null,"Album")," ","route will only partially match, so Curi will move on to the next route, ",a.default.createElement(r.InlineJS,null,"Not Found"),", which has a catch all ",a.default.createElement(r.InlineJS,null,"path")," ","that matches every pathname. Routes can be configured to allow partial matching, but exact matching is usually preferable."),a.default.createElement("p",null,"If a route has children, Curi will check if any of those routes form a complete match before moving on to the next route in the routes array.")),a.default.createElement(s.CodeBlock,null,"// when the pathname is '/a/Coloring+Book/All+Night',\n// the Album route will partially match the pathname.\n// Then, its child route Song will be tested and fully\n// match the pathname.\n{\n  name: 'Album',\n  path: 'a/:album',\n  children: [\n    {\n      name: 'Song',\n      path: ':title'\n    }\n  ]\n}"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"You can control whether a route does exact or partial matching with"," ",a.default.createElement(o.Link,{hash:"pathOptions"},a.default.createElement(r.InlineJS,null,"pathOptions"))," ","property. If you set ",a.default.createElement(r.InlineJS,null,"{ end: false }"),", a route that partially matches will consider itself matched.")),a.default.createElement(s.CodeBlock,null,"// when the pathname is\n// '/a/Good+Kid,+M.A.A.D+City/Poetic+Justice',\n// the Album route will partially match, but because\n// it sets \"end\" to false, the partial match will still be used.\n{\n  name: 'Album',\n  path: 'a/:albumID',\n  pathOptions: {\n    end: false\n  }\n}"),a.default.createElement(i.Subsection,{title:"No Matching Route",id:"catch-all"},a.default.createElement(u.Warning,null,a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"If none of your routes match a location, Curi will do nothing! You need to set a catch-all route to match these locations yourself. The best way to do this is to add a route to the end of your routes array with a ",a.default.createElement(r.InlineJS,null,"path")," of"," ",a.default.createElement(r.InlineJS,null,'"(.*)"'),", which will match every pathname.")),a.default.createElement(s.CodeBlock,null,"{\n  name: 'Not Found',\n  path: '(.*)',\n}"))))))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=n(1),r=n(5),u=n(9),i=n(76),s=n(6)},150:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(u.Section,{title:"The Router",id:"router-object"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The router is the controller of the single-page application. A router is created using a ",a.default.createElement(r.InlineJS,null,"history")," object and a"," ",a.default.createElement(r.InlineJS,null,"routes")," array.")),a.default.createElement(s.CodeBlock,null,"import { curi } from '@curi/router';\n\nconst history = Browser();\nconst routes = [...];\nconst router = curi(history, routes);")),a.default.createElement(u.Section,{title:"History",id:"history-object"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"history")," object manages navigation between locations within an application."),a.default.createElement("p",null,"There are three types of ",a.default.createElement(r.InlineJS,null,"history")," to choose from; which one you use depends on where your application is running.")),a.default.createElement("ol",null,a.default.createElement("li",null,a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"browser")," history is used for applications running in a browser."),a.default.createElement("p",null,"If you use the ",a.default.createElement(r.InlineJS,null,"browser")," history, your application should be hosted on a server that can handle dynamic requests. This either means a server with real time route matching (like an Express server) or through configuration where a fallback page is served when the request doesn't map to a real file on the server."),a.default.createElement("p",null,"You can use"," ",a.default.createElement(o.Link,{to:"Package",params:{package:"static"}},a.default.createElement(r.InlineJS,null,"@curi/static"))," ","to generate static HTML pages for a ",a.default.createElement(r.InlineJS,null,"browser")," history powered application.")),a.default.createElement(s.CodeBlock,null,'import Browser from "@hickory/browser";\nconst browserHistory = Browser();')),a.default.createElement("li",null,a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"hash")," history is a fallback history for applications running in a browser."),a.default.createElement("p",null,"A ",a.default.createElement(r.InlineJS,null,"hash")," history should only be used if you cannot configure the server to respond to requests that don't match files on the server. Most static file hosts are configurable, so you probably don't need to use this.")),a.default.createElement(s.CodeBlock,null,'import Hash from "@hickory/hash";\nconst hashHistory = Hash();')),a.default.createElement("li",null,a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"in-memory")," history is used for applications not running in a browser. For example, the ",a.default.createElement(r.InlineJS,null,"in-memory")," ","history is used on the server, in a React Native app, and during testing.")),a.default.createElement(s.CodeBlock,null,'import InMemory from "@hickory/in-memory";\nconst inMemoryHistory = InMemory();'))),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"If you are not familiar with how single-page applications interact with a server, this article should help:"," ",a.default.createElement("a",{href:"https://medium.com/@pshrmn/single-page-applications-and-the-server-32a23d67936"},"Single-Page Applications and the Server"),".")),a.default.createElement(u.Subsection,{title:"Locations",id:"locations"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"history")," object will map URLs into location objects. Only the ",a.default.createElement(r.InlineJS,null,"pathname"),", ",a.default.createElement(r.InlineJS,null,"query")," (search), and"," ",a.default.createElement(r.InlineJS,null,"hash")," segments are used; locations ignore the domain and protocol segments of a URL."),a.default.createElement("p",null,"When matching loactions to routes, only the ",a.default.createElement(r.InlineJS,null,"pathname")," is used.")),a.default.createElement(s.CodeBlock,null,'// https://www.example.com/page?key=value#trending\nlocation = {\n  pathname: "/page",\n  query: "key=value"\n  hash: "trending"\n}'),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"query")," value of a location is a string by default, but the history object can be configured to automatically parse it into an object."),a.default.createElement("p",null,"You can choose whichever query parsing/stringifying package you prefer. Some of the most popular are"," ",a.default.createElement("a",{href:"http://npmjs.com/package/qs"},a.default.createElement(r.InlineJS,null,"qs")),","," ",a.default.createElement("a",{href:"http://npmjs.com/package/query-string"},a.default.createElement(r.InlineJS,null,"query-string")),", and"," ",a.default.createElement("a",{href:"https://www.npmjs.com/package/querystring"},a.default.createElement(r.InlineJS,null,"querystring")),".")),a.default.createElement(s.CodeBlock,null,'import { parse, stringify } from "qs";\nimport Browser from "@hickory/browser";\n\nconst history = Browser({\n  query: { parse, stringify }\n});\n  \n// https://www.example.com/page?key=value#trending\nlocation = {\n  pathname: "/page",\n  query: { key: "value" }\n  hash: "trending"\n}')),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"For more details on the history objects and their APIs, please check out the"," ",a.default.createElement("a",{href:"https://github.com/pshrmn/hickory/tree/master/docs"},"Hickory documentation"),"."))),a.default.createElement(u.Section,{title:"Routes",id:"routes-array"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"The ",a.default.createElement(r.InlineJS,null,"routes")," array defines the valid locations within an application. When the router receives a new location, it matches it against the routes to generate a response."),a.default.createElement("p",null,"Each route is an object that has a unique ",a.default.createElement(r.InlineJS,null,"name")," and a"," ",a.default.createElement(r.InlineJS,null,"path")," string, which defines what locations the route matches."),a.default.createElement(i.Note,null,a.default.createElement(r.InlineJS,null,"path")," strings do not start with a slash."),a.default.createElement("p",null,"Routes can be nested. A child route's ",a.default.createElement(r.InlineJS,null,"path")," will build on the paths from any ancestor routes."),a.default.createElement("p",null,'You will almost always want to include a "catch all" route to match any "invalid" locations and render a 404 page. The path'," ",a.default.createElement(r.InlineJS,null,'"(.*)"')," matches every location. During development, Curi will log a warning in the console to let you know if you forgot to include a catch all route.")),a.default.createElement(s.CodeBlock,null,'const routes = [\n  {\n    name: "Home",\n    path: ""\n  },\n  {\n    name: "Album",\n    path: "photos/:albumID",\n    children: [\n      {\n        name: "Photo",\n        // matches /photos/6789/12345 with params\n        // { albumID: "6789", photoID: "12345" }\n        path: ":photoID"\n      }\n    ]\n  },\n  {\n    name: "Not Found",\n    path: "(.*)"\n  }\n];'),a.default.createElement(u.Subsection,{title:"Route names",id:"route-names"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Why do routes have names? Curi lets you interact with routes using their names."),a.default.createElement("p",null,"For example, Curi provides a ",a.default.createElement(r.InlineJS,null,"pathname")," route interaction to generate the ",a.default.createElement(r.InlineJS,null,"pathname")," of a location to navigate to. Instead of manually writing ",a.default.createElement(r.InlineJS,null,"pathname")," strings, you tell Curi the name of the route that you want to navigate to (and also any required params) and Curi will create the ",a.default.createElement(r.InlineJS,null,"pathname")," ","for you.")),a.default.createElement(s.CodeBlock,null,'const pathname = router.route.pathname(\n  "Photo",\n  {\n    albumID: "abcd",\n    photoId: "98765"\n  }\n);\n// pathname = "/photos/abcd/98765"'))),a.default.createElement(u.Section,{title:"Navigation",id:"navigation"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"When navigation occurs, the router receives the new location from its ",a.default.createElement(r.InlineJS,null,"history")," object. This either happens from in-app navigation (e.g. clicking a link) or platform navigation (e.g. clicking the back button or typing URL in the address bar and hitting enter)."),a.default.createElement("p",null,"The router has a ",a.default.createElement(r.InlineJS,null,"navigate()")," method to let you navigate with code. The function takes the ",a.default.createElement(r.InlineJS,null,"name")," of the route you want to navigate to and any route ",a.default.createElement(r.InlineJS,null,"params"),". The navigation"," ",a.default.createElement(r.InlineJS,null,"method")," controls how the history changes locations, with the default behavior acting like clicking a link.")),a.default.createElement(s.CodeBlock,null,'router.navigate({\n  name: "Photo",\n  params: { albumID: 1357, photoID: 02468 },\n  hash: "comments"\n});\n// /photos/1357/02468#comments\n\nrouter.navigate({\n  name: "Login",\n  state: { next: location.pathname },\n  // replace the current location with the Login location\n  // "REPLACE" is ideal for redirects\n  method: "REPLACE"\n});')),a.default.createElement(u.Section,{title:"Response Handlers",id:"response-handlers"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"When the router has created a response, it emits it to any response handlers. There are three types of response handlers: observers, one time functions, and side effects."),a.default.createElement("p",null,"Side effects are passed to the router when you are creating it. You can read more about them in the"," ",a.default.createElement(o.Link,{to:"Guide",params:{slug:"side-effects"}},"side effects guide"),"."),a.default.createElement("p",null,"One time functions are passed to the router using"," ",a.default.createElement(r.InlineJS,null,"router.once()"),". These are response handlers that will only be called one time. If a response already exists, then the response handler will be called immediately (unless configured not to). Otherwise, the one time response handler will be called after the next response is emitted."),a.default.createElement("p",null,"Observers are passed to the router using ",a.default.createElement(r.InlineJS,null,"router.observe()"),". Unlike one time functions, these will be called for every response emitted by the router (until you tell the router to stop calling it). You most likely will not need to call this yourself. The different framework implementations (",a.default.createElement(r.InlineJS,null,"@curi/react-dom"),","," ",a.default.createElement(r.InlineJS,null,"@curi/react-native"),", ",a.default.createElement(r.InlineJS,null,"@curi/vue"),", and"," ",a.default.createElement(r.InlineJS,null,"@curi/svelte"),") setup observers for you.")),a.default.createElement(s.CodeBlock,null,"const router = curi(history, routes);\n\nconst stop = router.observe(({ response }) => {\n  console.log('new response!', response);\n});\n// ...\nstop();\n// no longer observing"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"If you have any asynchronous routes (routes with ",a.default.createElement(r.InlineJS,null,"resolve")," ","functions), ",a.default.createElement(r.InlineJS,null,"router.once()")," should be used to delay the initial render until after the initial response is ready.")),a.default.createElement(s.CodeBlock,null,"// wait for initial response to be ready\nrouter.once(() => {\n  // safe to render async routes now\n});")),a.default.createElement(u.Section,{title:"Rendering",id:"rendering"},a.default.createElement(s.Explanation,null,a.default.createElement("p",null,"Rendering is left to whatever rendering library you are using. The way that Curi interfaces with each of them varies, but they all use observers to be notified when there is a new response.")),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,a.default.createElement(r.InlineJS,null,"@curi/react-dom")," uses a ",a.default.createElement(r.InlineComponent,null,"Router")," with a render-invoked ",a.default.createElement(r.InlineJS,null,"children")," function that will be called whenever there is a new response."),a.default.createElement("p",null,"In React applications, ",a.default.createElement(r.InlineJS,null,"response.body")," should be a React component, so rendering the application means creating an element from ",a.default.createElement(r.InlineJS,null,"response.body"),"."),a.default.createElement("p",null,"The"," ",a.default.createElement(o.Link,{to:"Tutorial",params:{slug:"react-basics"}},"React Basics Tutorial")," ","gets into more detail about how this works.")),a.default.createElement(s.CodeBlock,null,"// React\nconst Router = curiProvider(router);\n\nReactDOM.render((\n  <Router>\n    {({ response }) => {\n      const { body:Body } = response;\n      return <Body />;\n    }}\n  </Router>\n), document.getElementById('root'));"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,a.default.createElement(r.InlineJS,null,"@curi/vue")," sets up reactive objects that update when there is a new response. ",a.default.createElement(r.InlineComponent,null,"component :is")," can be used to render the ",a.default.createElement(r.InlineJS,null,"body")," component."),a.default.createElement("p",null,"The"," ",a.default.createElement(o.Link,{to:"Tutorial",params:{slug:"react-basics"}},"Vue Basics Tutorial")," ","details how to use Vue and Curi.")),a.default.createElement(s.CodeBlock,null,"// Vue\nVue.use(CuriPlugin, { router });\nnew Vue({\n  el: '#app',\n  template: '<app />',\n  components: { app }\n});"),a.default.createElement(s.Explanation,null,a.default.createElement("p",null,a.default.createElement(r.InlineJS,null,"@curi/svelte")," uses the Svelte store and"," ",a.default.createElement(r.InlineComponent,null,"svelte:component")," to render.")),a.default.createElement(s.CodeBlock,null,"// Svelte\nconst store = curiStore(router);\nnew app({ target, store });")))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=n(1),r=n(5),u=n(76),i=n(9),s=n(6)},151:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return a.default.createElement(a.default.Fragment,null,a.default.createElement(u.Explanation,null,a.default.createElement("p",null,"Every application that uses Curi needs to install is"," ",a.default.createElement(o.InlineJS,null,"@curi/router"),"."),a.default.createElement("p",null,"You will also need a Hickory package (",a.default.createElement(o.InlineJS,null,"@hickory/browser"),","," ",a.default.createElement(o.InlineJS,null,"@hickory/hash"),", or ",a.default.createElement(o.InlineJS,null,"@hickory/in-memory"),"). Which package you need depends on the application, but the browser package is best for most websites.")),a.default.createElement(u.CodeBlock,{lang:"bash"},"npm install @hickory/browser @curi/router"),a.default.createElement(u.Explanation,null,a.default.createElement("p",null,"These packages can also be loaded from"," ",a.default.createElement("a",{href:"https://unpkg.com"},"Unpkg"),".")),a.default.createElement(u.CodeBlock,{lang:"markup"},'<script\n  src="https://unpkg.com/@hickory/browser/dist/hickory-browser.min.js"\n><\/script>\n<script\n  src="https://unpkg.com/@curi/router/dist/curi-router.min.js"\n><\/script>'),a.default.createElement(r.Section,{title:"Promises",id:"promises"},a.default.createElement(u.Explanation,null,a.default.createElement("p",null,"Curi uses Promises, so you may need to include a polyfill to add Promise support for older browsers (including IE 11)."),a.default.createElement("p",null,"If you need a general ES2015 polyfill, you can check out the one provided by Babel's"," ",a.default.createElement("a",{href:"https://babeljs.io/docs/usage/polyfill/#usage-in-browser"},"babel-polyfill")," ","package. If you only need a Promise polyfill, then you should check out the"," ",a.default.createElement("a",{href:"https://github.com/stefanpenner/es6-promise"},"es6-promise")," ","package or"," ",a.default.createElement("a",{href:"https://polyfill.io/v2/docs/features/"},"polyfill.io"),".")),a.default.createElement(u.CodeBlock,{lang:"html"},'<script\n  src="https://cdn.polyfill.io/v2/polyfill.js?features=Promise"\n><\/script>')))};var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=(n(1),n(5)),r=n(76),u=n(6)},152:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=v(n(151)),a=v(n(150)),o=v(n(149)),r=v(n(148)),u=v(n(147)),i=v(n(146)),s=v(n(145)),c=v(n(144)),d=v(n(143)),m=v(n(142)),p=v(n(141)),h=v(n(140)),f=v(n(139)),E=v(n(138)),y=v(n(137)),g=v(n(136)),b=v(n(135)),w=v(n(134));function v(e){return e&&e.__esModule?e:{default:e}}var I={installation:l.default,"creating-a-router":a.default,"routes-and-responses":o.default,"sync-or-async":r.default,"navigating-and-observing":u.default,"react-dom":i.default,"react-native":s.default,vue:c.default,svelte:d.default,"route-interactions":m.default,"side-effects":p.default,"code-splitting":h.default,loading:f.default,accessibility:E.default,apollo:y.default,"dev-tips":g.default,"migrate-rrv3":b.default,"migrate-rrv4":w.default};t.default=I},74:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t=e.response;if(!t.data)return l.default.createElement(o.default,null,l.default.createElement("div",null,"The requested guide could not be found."));var n=a.default[t.params.slug];return l.default.createElement(o.default,null,l.default.createElement("h1",null,t.data.name),l.default.createElement(n,null))};var l=r(n(0)),a=r(n(152)),o=r(n(18));function r(e){return e&&e.__esModule?e:{default:e}}},76:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Subsection=t.Section=void 0;var l,a=(l=n(0))&&l.__esModule?l:{default:l},o=n(1);function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var l in n)Object.prototype.hasOwnProperty.call(n,l)&&(e[l]=n[l])}return e}).apply(this,arguments)}function u(e,t){if(null==e)return{};var n,l,a=function(e,t){if(null==e)return{};var n,l,a={},o=Object.keys(e);for(l=0;l<o.length;l++)n=o[l],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(l=0;l<o.length;l++)n=o[l],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}n(81);var i=function(e){var t=e.title,n=e.id,l=e.children,r=e.tag,u=e.type,i=void 0===u?"section":u;return a.default.createElement("div",{className:i,id:n},a.default.createElement(r,null,t,a.default.createElement(o.Link,{className:"header-link",hash:n},"#")),l)};t.Section=function(e){var t=e.tag,n=void 0===t?"h2":t,l=u(e,["tag"]);return a.default.createElement(i,r({type:"section",tag:n},l))};t.Subsection=function(e){var t=e.tag,n=void 0===t?"h3":t,l=u(e,["tag"]);return a.default.createElement(i,r({type:"subsection",tag:n},l))}},81:function(e,t,n){}}]);