(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{104:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=i(n(0)),a=n(1),r=i(n(55)),o=n(2),u=n(4);n(6);function i(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"Curi can have synchronous and asynchronous routes."),l.default.createElement("p",null,"When a navigation event is triggered (e.g. clicking a link or button), the router will match a route. If the route is synchronous, the response will be emitted immediately. If the route is asynchronous, the response will not be emitted until the route's async functions have finished. This is useful for code-splitting and preloading data for a route."),l.default.createElement("p",null,"By default, routes are synchronous. If a route has an"," ",l.default.createElement(o.InlineJS,null,"on.initial")," or ",l.default.createElement(o.InlineJS,null,"on.every()")," function, it becomes async."),l.default.createElement(o.PrismBlock,{lang:"javascript"},'// sync\n{ name: "Home", path: "" },\n\n// async\n{\n  name: "About",\n  path: "about,\n  on: {\n    // this makes the route async\n    initial: () => import("./components/About")\n  }\n}'),l.default.createElement(u.Section,{title:"Async Things to Think About",id:"think"},l.default.createElement("p",null,"For the most part, it shouldn't matter to you (or your users) whether Curi is sync or async. However, there are a couple of things that you should be aware of when it comes to async matching."),l.default.createElement("ol",null,l.default.createElement("li",null,l.default.createElement("p",null,"If you have async routes, you should wait for the initial response before rendering. If you don't, then the app will have to know how to render when a response is ",l.default.createElement(o.InlineJS,null,"null"),"."),l.default.createElement("p",null,"Waiting is done by passing a function that renders the app to"," ",l.default.createElement(o.InlineJS,null,"router.respond()"),". That function will be called once the initial response is ready."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const router = curi(history, routes);\nrouter.respond(() => {\n  // the initial response is ready, so it is safe to render\n  ReactDOM.render(...);\n});")),l.default.createElement("li",null,l.default.createElement("p",null,"With async routes, there is a delay between when the user clicks a link and when the new response is emitted. During this time, the navigation can be interrupted with a new navigation. Curi handles this internally, but you might want to update your UI after a link/button is clicked to indicate that the next page is loading."),l.default.createElement("p",null,"You can see an example of this in the"," ",l.default.createElement(a.Link,{to:"Example",params:{category:"react",slug:"data-loading"}},"Data Loading Example"),".")))),l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Get to know about route objects with the"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"routes"}},"All About Routes")," ","guide."))}},105:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=s(n(0)),a=n(1),r=s(n(55)),o=n(2),u=n(6),i=n(4);function s(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"The Curi router is somewhat similar to React Router versions 2 and 3, so migration is fairly easy. For instance, both use a centralized router. Both routers are made up of route objects (although with React Router some of these are disguised as JSX with ",l.default.createElement(o.InlineComponent,null,"Route")," components). With both, routes can be nested, allowing child routes to build off of the paths from their parent routes."),l.default.createElement("p",null,"Migration from React Router v2/3 to Curi should not require a complete reworking of your application, but there are some key differences."),l.default.createElement("ol",null,l.default.createElement("li",null,"The routing is handled entirely outside of React. With Curi, there are no ",l.default.createElement(o.InlineComponent,null,"Route")," components."),l.default.createElement("li",null,"With Curi, when a nested route matches, only that route renders. Any ancestor routes that also (partially) match are not rendered. This is different from React Router, where ancestors of the best matched route also render.")),l.default.createElement(i.Section,{title:"Routes",id:"routes"},l.default.createElement("p",null,"Let’s get started with setting up our routes."),l.default.createElement(i.Subsection,{title:"With React Router",id:"routes-with-react-router"},l.default.createElement("p",null,"In React Router v2/3, there are two ways to define routes. You can either use JavaScript objects or JSX ",l.default.createElement(o.InlineComponent,null,"Route"),"s (which React Router converts to JavaScript objects)."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"// JavaScript objects\n{\n  path: '/',\n  component: App,\n  indexRoute: Home,\n  childRoutes: [\n    {\n      path: 'inbox',\n      component: Inbox,\n      childRoutes: [\n        {\n          path: ':message',\n          component: Message,\n          onEnter: (next) => {...},\n          onChange: (prev, next) => {...},\n          onLeave: (prev) => {...}\n        }\n      ]\n    }\n  ]\n// JSX\n<Route path='/' component={App}>\n  <IndexRoute component={Home} />\n  <Route path='inbox' component={Inbox}>\n    <Route\n      path=':message'\n      component={Message}\n      onEnter={next => {...}}\n      onChange={(prev, next) => {...}}\n      onLeave={prev => {...}}\n    />\n  </Route>\n</Route>"),l.default.createElement("p",null,"Both styles described above define the same route structure for three routes: ",l.default.createElement(o.InlineJS,null,"/"),", ",l.default.createElement(o.InlineJS,null,"/inbox"),", and"," ",l.default.createElement(o.InlineJS,null,"/inbox/:message"),". Each one of these has a component that will be rendered when it matches. The ",l.default.createElement(o.InlineJS,null,"/inbox/:message")," route has some methods defined to describe its behavior when the route enters, updates, and leaves.")),l.default.createElement(i.Subsection,{title:"With Curi",id:"routes-with-curi"},l.default.createElement("p",null,"Routes in Curi are always JavaScript objects. Like React Router, each route object has a path property that describes the path segments that the route matches. React Router v2/3 uses a custom path matcher, but Curi uses ",l.default.createElement(o.InlineJS,null,"path-to-regexp"),". You can read learn how to format paths from the"," ",l.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp"},l.default.createElement(o.InlineJS,null,"path-to-regexp")," repo"),"."),l.default.createElement("p",null,"First, we will just define the paths for our routes."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    path: ''\n  },\n  {\n    path: 'inbox',\n    children: [\n      {\n        path: ':message'\n      }\n    ]\n  }\n];"),l.default.createElement("p",null,"The biggest difference between the Curi paths and the React Router paths is that with Curi, you never include a forward slash at the beginning of the path. This means that while the root path for React Router is ",l.default.createElement(o.InlineJS,null,"'/'"),", the root path for Curi is ",l.default.createElement(o.InlineJS,null,"''"),"."),l.default.createElement("p",null,"Next, we should add our components to each route. We will ignore the"," ",l.default.createElement(o.InlineComponent,null,"App")," component that is used in the React Router routes. That is not route specific and will be rendered by our application (assuming we actually need it)."),l.default.createElement("p",null,"With Curi routes, we have a ",l.default.createElement(o.InlineJS,null,"response()")," function. The object returned by ",l.default.createElement(o.InlineJS,null,"response()")," is used to modify the response that the application will use to render. For this React application, we want our ",l.default.createElement(o.InlineJS,null,"body")," property to be the React component associated with each route."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    path: 'inbox',\n    response: () => {\n      return {\n        body: Inbox\n      };\n    },\n    children: [\n      {\n        path: ':message',\n        response: () => {\n          return {\n            body: Message\n          };\n        }\n      }\n    ]\n  }\n];"),l.default.createElement("p",null,"We are close to replicating our React Router routes, we just have to implement the ",l.default.createElement(o.InlineJS,null,"on___")," methods for our ",l.default.createElement(o.InlineJS,null,":message")," ","route. With Curi, routes can have functions that are called when they match the new loaction. These are ",l.default.createElement(o.InlineJS,null,"on.initial()")," and"," ",l.default.createElement(o.InlineJS,null,"on.every()"),". ",l.default.createElement(o.InlineJS,null,"on.initial()")," is useful for tasks that only need to be run once per route, like the code splitting mentioned above. ",l.default.createElement(o.InlineJS,null,"on.every()")," will be called every time that a route matches, so it is ideal for data loading."),l.default.createElement("p",null,"With React Router, ",l.default.createElement(o.InlineJS,null,"onEnter")," is called when the route first matches, while ",l.default.createElement(o.InlineJS,null,"onChange")," is called when the same route matches a new location (e.g. with new path parameters)."," ",l.default.createElement(o.InlineJS,null,"onEnter")," and ",l.default.createElement(o.InlineJS,null,"onChange")," are nearly the same; the big difference between the two is that ",l.default.createElement(o.InlineJS,null,"onChange")," will receive the previous props, which could be used to determine which props changed. When converting these to Curi, we will use"," ",l.default.createElement(o.InlineJS,null,"on.every()")," for both."),l.default.createElement("p",null,"There currently is no equivalent to ",l.default.createElement(o.InlineJS,null,"onLeave")," with Curi. This is mostly because I haven’t seen a compelling need for it. It certainly could be implemented, but so far I have not found a reason to use that. If you have something you need this functionality for, please open up an issue in the GitHub repo."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    path: 'inbox',\n    response: () => {\n      return {\n        body: Inbox\n      };\n    },\n    children: [\n      {\n        path: ':message',\n        response: () => {\n          return {\n            body: Message\n          };\n        },\n        on: {\n          every: (route) => { return ... },\n        }\n      }\n    ]\n  }\n];"),l.default.createElement("p",null,"The"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"routes"},hash:"match"},"routes guide")," ","covers all of the route properties."),l.default.createElement("p",null,"We now have the equivalent routes implemented in Curi, but we have one last step. With Curi, each route has to have a unique name."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    name: 'Home',\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    name: 'Inbox',\n    path: 'inbox',\n    response: () => {\n      return {\n        body: Inbox\n      };\n    },\n    children: [\n      {\n        name: 'Message',\n        path: ':message',\n        response: () => {\n          return {\n            body: Message\n          };\n        },\n        on: {\n          every: (route) => { return ... },\n        }\n      }\n    ]\n  }\n];"),l.default.createElement("p",null,"Curi uses route names to allow you to interact with routes. For example, you can navigate to the “Inbox” route just by knowing its name instead of its URI. This can be especially handy when dealing with complicated pathnames or if you need to change the URI structure of your website. With Curi, you never have to write a URI yourself!")),l.default.createElement("p",null,"Once your routes have been defined, you can move on to creating your Curi router.")),l.default.createElement(i.Section,{title:"Creating the router",id:"creating-the-router"},l.default.createElement("p",null,"With React Router, you create your router by rendering a"," ",l.default.createElement(o.InlineComponent,null,"Router"),". That either takes the ",l.default.createElement(o.InlineComponent,null,"Route")," components as props or the route objects through its ",l.default.createElement(o.InlineJS,null,"routes")," prop. The"," ",l.default.createElement(o.InlineComponent,null,"Router")," also takes a ",l.default.createElement(o.InlineJS,null,"history")," prop, which is either one of the pre-routerured objects (",l.default.createElement(o.InlineJS,null,"browserHistory")," or"," ",l.default.createElement(o.InlineJS,null,"hashHistory"),") or one that you create yourself."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"import { Router, browserHistory } from 'react-router';\nconst routes = [...];\nReactDOM.render((\n  <Router history={browserHistory} routes={routes} />\n), holder);"),l.default.createElement("p",null,"With Curi, the router is created prior to rendering. It takes a Hickory history object, your routes array, and possibly an options object. ",l.default.createElement("a",{href:"https://github.com/pshrmn/hickory"},"Hickory")," ","is similar to the ",l.default.createElement(o.InlineJS,null,"history")," package used by React Router, but has a slight modified API (easier navigation blocking and navigation that imitates how anchors work) and more convenient location objects (you can use a ",l.default.createElement(o.InlineJS,null,"query")," object instead of having to manually create a ",l.default.createElement(o.InlineJS,null,"search")," string)."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"import curi from '@curi/core';\nimport Browser from '@hickory/browser';\nconst history = Browser();\nconst routes = [...];\nconst router = curi(history, routes);")),l.default.createElement(i.Section,{title:"Rendering",id:"rendering"},l.default.createElement("p",null,"We will walk through the rendering differences between React Router and Curi by looking at what happens in each when we navigate to the URI"," ",l.default.createElement(o.InlineJS,null,"/inbox/test-message-please-ignore"),"."),l.default.createElement(i.Subsection,{title:"React Router v2/3",id:"rendering-react-router"},l.default.createElement("p",null,"React Router uses the ",l.default.createElement(o.InlineComponent,null,"Router")," component to subscribe to location changes. Each time that the location changes, it walks over its routes and determines which route(s!) match."),l.default.createElement("p",null,"React Router starts by rendering the root component. In the above router, that is the ",l.default.createElement(o.InlineComponent,null,"App"),". Next, our ",l.default.createElement(o.InlineJS,null,"inbox")," route also matches, so React Router also renders our ",l.default.createElement(o.InlineComponent,null,"Inbox")," ","component. Finally, the URI"," ",l.default.createElement(o.InlineJS,null,"/inbox/test-message-please-ignore")," also matches our ",l.default.createElement(o.InlineJS,null,":message")," ","route (which is concatenated with its parents to form the path"," ",l.default.createElement(o.InlineJS,null,"/inbox/:message"),"), so ",l.default.createElement(o.InlineComponent,null,"Message")," is rendered as well. Each child component is rendered by its parent, so we end up with a component tree that looks something like this:"),l.default.createElement(o.PrismBlock,{lang:"jsx"},"<App>\n  <Inbox>\n    <Message>\n  </Inbox>\n</App>"),l.default.createElement("p",null,"With this structure, any routes with children will be rendered when one of the children matches. That means that those routes need to know how to render based on what type of match they have. For example,"," ",l.default.createElement(o.InlineComponent,null,"Inbox")," needs to know how to render for an exact match (the URI is ",l.default.createElement(o.InlineJS,null,"/inbox"),") and for a partial match (",l.default.createElement(o.InlineJS,null,"/inbox/test-message-please-ignore"),"). Also, if the ",l.default.createElement(o.InlineComponent,null,"Inbox")," needs to pass any props to"," ",l.default.createElement(o.InlineComponent,null,"Message"),", it has to use ",l.default.createElement(o.InlineJS,null,"React.cloneElement"),", which works but is not the cleanest looking code.")),l.default.createElement(i.Subsection,{title:"Curi",id:"rendering-with-curi"},l.default.createElement("p",null,"With Curi, we also need to re-render our application every time that the location changes. We will do this using the"," ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," component, which comes from the"," ",l.default.createElement(o.InlineJS,null,"@curi/react")," package."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," takes a ",l.default.createElement(o.InlineJS,null,"router")," prop, which it will use to listen for the router to emit new responses (by internally calling ",l.default.createElement(o.InlineJS,null,"router.respond()"),") The ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," ","places the new ",l.default.createElement(o.InlineJS,null,"response")," and ",l.default.createElement(o.InlineJS,null,"navigation")," ","(alongside the ",l.default.createElement(o.InlineJS,null,"router")," object) on React's ",l.default.createElement(o.InlineJS,null,"context")," ","so that child components will be able to access those values."," ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," also expects a function as its"," ",l.default.createElement(o.InlineJS,null,"children")," prop (a render-invoked prop)."),l.default.createElement("p",null,"We will also use ",l.default.createElement(o.InlineJS,null,"router.respond()")," to wait for the initial response to be emitted before rendering."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"router.respond(() => {\n  ReactDOM.render((\n    <CuriProvider router={router}>\n      {({ response }) => {...}}\n    </CuriProvider>\n  ), holder);\n});"),l.default.createElement("p",null,"So what should your ",l.default.createElement(o.InlineJS,null,"children")," function look like? When it is called, the function will receive an object with three properties:"," ",l.default.createElement(o.InlineJS,null,"response"),", the new response object, ",l.default.createElement(o.InlineJS,null,"navigation"),", an object with additional information about the navigation, and"," ",l.default.createElement(o.InlineJS,null,"router"),", your Curi router. We will ignore the"," ",l.default.createElement(o.InlineJS,null,"navigation")," and ",l.default.createElement(o.InlineJS,null,"router")," here because the"," ",l.default.createElement(o.InlineJS,null,"response")," is what we really want."),l.default.createElement("p",null,"Earlier, we added ",l.default.createElement(o.InlineJS,null,"body")," properties to each of the routes and said that when a route matches, that function would be called and its return value would be attached to the response. That means, that inside of our ",l.default.createElement(o.InlineJS,null,"children")," function, we can access the matched route’s component as ",l.default.createElement(o.InlineJS,null,"response.body"),"."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"function render({ response }) {\n  const { body:Body } = response;\n  return <Body />;\n}"),l.default.createElement("p",null,"That isn’t perfect because it doesn’t consider what happens when there is no body (which happens if none of the routes match the location or you don't set it in a route's ",l.default.createElement(o.InlineJS,null,"response()")," function)."),l.default.createElement(u.Note,null,"Wildcard routes (",l.default.createElement(o.InlineJS,null,"{ path: '(.*)' }"),") can be used to easily display a not found page for any location not matched by other routes."),l.default.createElement("p",null,"Let’s get back to our ",l.default.createElement(o.InlineJS,null,"response")," object. In the React Router section, we had three components that were rendered: ",l.default.createElement(o.InlineComponent,null,"App"),",",l.default.createElement(o.InlineComponent,null,"Inbox"),", and ",l.default.createElement(o.InlineComponent,null,"Message"),". With Curi, only the most accurately matched route actually matches. That means that for the URI"," ",l.default.createElement(o.InlineJS,null,"/inbox/test-message-please-ignore"),", the ",l.default.createElement(o.InlineJS,null,'"Message"')," ","route will match, but its parent route, ",l.default.createElement(o.InlineJS,null,'"Inbox"')," will not. The ",l.default.createElement(o.InlineJS,null,"response.body")," will be the ",l.default.createElement(o.InlineComponent,null,"Message")," component, so that is what our ",l.default.createElement(o.InlineJS,null,"render")," function will render. We don’t render ",l.default.createElement(o.InlineComponent,null,"Inbox")," because we did not match the ",l.default.createElement(o.InlineJS,null,"inbox")," ","route."),l.default.createElement("p",null,"It was mentioned above that there is no need for the ",l.default.createElement(o.InlineComponent,null,"App")," ","component with Curi. If you want to have an ",l.default.createElement(o.InlineComponent,null,"App")," component, you can render it either inside of the ",l.default.createElement(o.InlineJS,null,"render")," function or as a parent of your ",l.default.createElement(o.InlineComponent,null,"CuriProvider"),". This can be useful for rendering content that is unrelated to specific routes, like a page header or menu."),l.default.createElement("p",null,"Rendering the ",l.default.createElement(o.InlineComponent,null,"App")," inside of the ",l.default.createElement(o.InlineJS,null,"children")," ","function is necessary if any of the components rendered by the"," ",l.default.createElement(o.InlineComponent,null,"App")," are location aware components, since they need to access the Curi router (through React’s context, which the"," ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," provides)"),l.default.createElement(o.PrismBlock,{lang:"jsx"},"function render({ response }) {\n  const { body:Body } = response;\n  return (\n    <App>\n      <Body />\n    </App>\n  );\n}\n// or\nfunction render({ response }) {\n  const { body:Body } = response;\n  return (\n    <div>\n      <Header />\n      <Body />\n      <Footer />\n    </div>\n  );\n}"),l.default.createElement("p",null,"What about props that you want to send to your route components? Just pass them to the ",l.default.createElement(o.InlineComponent,null,"Body")," component that you render."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"function render({ response }) {\n  const { body:Body, data, params } = response;\n  return <Body data={data} params={params} />;\n}"),l.default.createElement("p",null,"The one catch here is that you will be passing the same props to all of your route components. You could add fine-grained control by using"," ",l.default.createElement(o.InlineJS,null,"response.name")," and a ",l.default.createElement(o.InlineJS,null,"switch")," or ",l.default.createElement(o.InlineJS,null,"if"),"/",l.default.createElement(o.InlineJS,null,"else")," ","chain, but this is probably overkill. If you’re worried about polluting the route component’s props, just pass the whole response object."))),l.default.createElement(i.Section,{title:"Links",id:"links"},l.default.createElement("p",null,"You obviously will want to be able to navigate between routes in your application. React Router provides a ",l.default.createElement(o.InlineComponent,null,"Link")," component to do this, and so does Curi (through the ",l.default.createElement(o.InlineJS,null,"@curi/react")," package). There are a few differences to note between these two components:"),l.default.createElement("ul",null,l.default.createElement("li",null,l.default.createElement("p",null,"React Router expects you to generate the pathname yourself, while Curi expects you to pass the name of the route that you want to navigate to. Any path parameters are passed to Curi’s"," ",l.default.createElement(o.InlineComponent,null,"Link")," using the ",l.default.createElement(o.InlineJS,null,"params")," prop."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"// React Router\n<Link to='/'>Home</Link>\n<Link to={`/inbox/${message}`}>Hello</Link>\n// Curi\n<Link to='Home'>Home</Link>\n<Link to='Message' params={{ message }}>Hello</Link>")),l.default.createElement("li",null,l.default.createElement("p",null,"With React Router, any additional location properties are passed to the ",l.default.createElement(o.InlineComponent,null,"Link")," using the ",l.default.createElement(o.InlineJS,null,"to")," object. With Curi, these properties are passed using the prop name (",l.default.createElement(o.InlineJS,null,"hash"),","," ",l.default.createElement(o.InlineJS,null,"query")," &",l.default.createElement(o.InlineJS,null,"state"),")."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"// React Router\n<Link to={{ pathname: '/inbox', hash: '#test' }}>Inbox</Link>\n// Curi\n<Link to='Inbox' hash='test'>Inbox</Link>")),l.default.createElement("li",null,l.default.createElement("p",null,"Active detection with Curi is more complicated than with React Router, but also more powerful. With Curi, you provide a"," ",l.default.createElement(o.InlineJS,null,"merge")," function that receives the props that will used to render the ",l.default.createElement(o.InlineComponent,null,"a")," and allows you to modify/add props. You can also pass ",l.default.createElement(o.InlineJS,null,"partial: true")," to allow for partial matches to be considered active (the opposite of React Router's"," ",l.default.createElement(o.InlineJS,null,"onlyActiveOnIndex"),")."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"// React Router\n<Link\n  to='/'\n  onlyActiveOnIndex\n  activeClassName='active'\n>Home</Link>\n// Curi\n// You need to add @curi/route-active to your router object\nimport active from '@curi/route-active';\nconst router = curi(history, routes, {\n  route: [active()]\n});\n\n// pass the merge function to your <Link>. The props it returns\n// will be passed to the anchor rendered by the <Link>\nfunction merge(props) {\n  props.className = 'active';\n  return props;\n}\n<Link\n  to='Home'\n  active={{ merge }}\n>Home</Link>")))),l.default.createElement(i.Section,{title:"Accessing router props from nested components",id:"router-props"},l.default.createElement("p",null,"React Router provides a ",l.default.createElement(o.InlineJS,null,"withRouter")," higher-order component that will inject router props into the wrapped component. Curi provides similar functionality with the ",l.default.createElement(o.InlineJS,null,"curious")," higher-order component provided by the ",l.default.createElement(o.InlineJS,null,"@curi/react")," package."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"export default withRouter(SomeComponent);\nexport default curious(SomeComponent);"),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"curious")," will inject the Curi router and the current response object into the wrapped component.")),l.default.createElement("p",null,"At this point, hopefully you are comfortable with migrating from React Router v2/3 to Curi. If there are any concepts not covered here that you think should be, please feel free to open up an issue"," ",l.default.createElement("a",{href:"https://github.com/pshrmn/curi/issues"},"on GitHub"),"."))}},106:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=s(n(0)),a=n(1),r=s(n(55)),o=n(2),u=n(6),i=n(4);function s(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null),l.default.createElement(u.Note,null,"This guide assumes that you are already familiar with React Native."),l.default.createElement(i.Section,{title:"Back Button",id:"back-button"},"To add back button support, you just need to use your ",l.default.createElement(o.InlineJS,null,"history")," ","object (which you can use directly or access through your router).",l.default.createElement(o.PrismBlock,{lang:"javascript"},"import { BackHandler } from 'react-native';\n\n// create your router\nconst router = curi(history, routes);\n\nBackHandler.addEventListener(\"hardwareBackPress\", () => {\n  // close the app when pressing back button on initial screen\n  if (router.history.index === 0) {\n    return false;\n  }\n  router.history.go(-1);\n  return true;\n});")),l.default.createElement(i.Section,{title:"Components",id:"components"},l.default.createElement("p",null,"The"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"react-native"}},l.default.createElement(o.InlineJS,null,"@curi/react-native"))," ","package is quite similar to the"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"react"}},l.default.createElement(o.InlineJS,null,"@curi/react"))," ","package. In fact, Curi's React Native package just re-exports most of the components from the React package."),l.default.createElement(i.Subsection,{title:l.default.createElement(o.InlineComponent,null,"Link"),id:"components-link"},l.default.createElement("p",null,"The main difference is that they have different ",l.default.createElement(o.InlineComponent,null,"Link")," ","components. While the React package's ",l.default.createElement(o.InlineComponent,null,"Link")," renders an anchor by default, the React Native ",l.default.createElement(o.InlineComponent,null,"Link")," renders a"," ",l.default.createElement(o.InlineComponent,null,"TouchableHighlight")," by default."),l.default.createElement(u.Note,null,"Don't forget to wrap the ",l.default.createElement(o.InlineComponent,null,"Link"),"'s text in a ",l.default.createElement(o.InlineComponent,null,"Text"),"!"),l.default.createElement(o.PrismBlock,{lang:"jsx"},"import { Link } from '@curi/react-native';\n\n<Link to='Home'>\n  <Text>Home</Text>\n</Link>")),l.default.createElement(i.Subsection,{title:l.default.createElement(o.InlineComponent,null,"CuriProvider"),id:"componentsCuriProvider"},l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"@curi/react")," provides a ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," component that will listen for new responses and re-render your application."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"import { CuriProvider } from '@curi/react-native';\n\nimport router from './router';\n\nconst App = () => (\n  <CuriProvider router={router}>\n    {({ response }) => {\n      const { body:Body } = response;\n      return <Body response={response} />;\n    }}\n  </CuriProvider>\n);"))))}},107:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=s(n(0)),a=n(1),r=s(n(55)),o=n(2),u=n(6),i=n(4);function s(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement(o.PrismBlock,{lang:"bash"},"npm install @curi/react"),l.default.createElement(u.Note,null,"This guide assumes that you are already familiar with React."),l.default.createElement("p",null,"Curi provides a number of React components through the"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"react"}},l.default.createElement(o.InlineJS,null,"@curi/react"))," ","package. To get started, there are only two components that you need to be aware of: ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," and ",l.default.createElement(o.InlineComponent,null,"Link"),"."),l.default.createElement(i.Section,{title:l.default.createElement(o.InlineComponent,null,"CuriProvider"),id:"CuriProvider"},l.default.createElement("p",null,"In order for other components to access router-related variables, we need to make them available through React's ",l.default.createElement(o.InlineJS,null,"context"),". The"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"react"},hash:"CuriProvider"},l.default.createElement(o.InlineComponent,null,"CuriProvider"))," ","component is responsible for doing this. You pass it two props: a Curi"," ",l.default.createElement(o.InlineJS,null,"router")," and a render-invoked ",l.default.createElement(o.InlineJS,null,"children")," prop. The"," ",l.default.createElement(o.InlineJS,null,"router")," will listen for new responses to be emitted and call the ",l.default.createElement(o.InlineJS,null,"children")," prop to re-render your application."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"import { CuriProvider } from '@curi/react';\n\n<CuriProvider router={router}>\n  {render}\n</CuriProvider>"),l.default.createElement(i.Subsection,{title:l.default.createElement("span",null,"The ",l.default.createElement(o.InlineJS,null,"children")," prop"),id:"child-fn"},l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"children")," prop is a render-invoked prop. This means that every time the ",l.default.createElement(o.InlineComponent,null,"CuriProvider")," is rendered, the"," ",l.default.createElement(o.InlineJS,null,"children")," function is called (",l.default.createElement(o.InlineJS,null,"this.props.children(...)"),"). The ",l.default.createElement(o.InlineJS,null,"children")," function should return the React elements that make up your application."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"children")," function receives an object with three properties to help you render your application: ",l.default.createElement(o.InlineJS,null,"response"),","," ",l.default.createElement(o.InlineJS,null,"navigation"),", and ",l.default.createElement(o.InlineJS,null,"router"),". The ",l.default.createElement(o.InlineJS,null,"response")," ","object is the most important of these, while the others may occasionally be useful or you may never use them."),l.default.createElement("p",null,"In our routes, we can attach a ",l.default.createElement(o.InlineJS,null,"body")," property to response objects, which we can then use in a ",l.default.createElement(o.InlineJS,null,"render")," function."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"import Home from './components/Home';\n\nconst routes = [\n  {\n    name: 'Home',\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  ...\n]"),l.default.createElement(o.PrismBlock,{lang:"javascript"},"function render({ response }) {\n  const { body:Body } = response;\n  return <Body />;\n}"),l.default.createElement(u.Note,null,'We rename "body" to "Body" so that the JSX is'," ",l.default.createElement("a",{href:"https://facebook.github.io/react/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized"},"transformed properly"),"."),l.default.createElement("p",null,"When no routes match, the body property of a response is"," ",l.default.createElement(o.InlineJS,null,"undefined"),". The best way to deal with this is with a catch all route."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"import NotFound from './components/NotFound';\n\nconst routes = [\n  // ...,\n  {\n    name: 'Not Found',\n    path: '(.*)' // this path matches EVERY pathname\n    response: () => {\n      return {\n        body: NotFound\n      };\n    }\n  }\n];"),l.default.createElement("p",null,"Finally, you can pass any props that you want to the ",l.default.createElement(o.InlineComponent,null,"Body")," ","component. Generally speaking, it is useful to pass the entire"," ",l.default.createElement(o.InlineJS,null,"response")," object. You can review all of the response properties in the"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"responses"},hash:"response-properties"},"responses")," ","guide."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"function render({ response }) {\n  const { body:Body } = response;\n  return <Body response={response} />;\n}"))),l.default.createElement(i.Section,{title:l.default.createElement(o.InlineComponent,null,"Link"),id:"link"},l.default.createElement("p",null,"A single page application isn't very useful if you cannot navigate between locations. The"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"react"},hash:"Link"},l.default.createElement(o.InlineComponent,null,"Link"))," ","component provides you with an easy way to do this by rendering anchor (",l.default.createElement(o.InlineComponent,null,"a"),") elements."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"import { Link } from '@curi/react'\n<Link to='Home'>Home</Link>"),l.default.createElement("p",null,"The most important prop of the ",l.default.createElement(o.InlineComponent,null,"Link")," is ",l.default.createElement(o.InlineJS,null,"to"),". This value should be the name of the route that you want to navigate to. For instance, take about following route:"),l.default.createElement(o.PrismBlock,{lang:"javascript"},"{\n  name: 'About',\n  path: 'about',\n  ...\n}\n"),l.default.createElement("p",null,"If you were to render a Link whose to property is ",l.default.createElement(o.InlineJS,null,'"About"'),", then it would render an anchor whose ",l.default.createElement(o.InlineJS,null,"href")," attribute is"," ",l.default.createElement(o.InlineJS,null,"/about"),". The great thing about this is that you don't have to know the URI of the route that you want to navigate to, only its name because Curi handles creating URI pathnames for you."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"<Link to='About'>About</Link>\n// <a href=\"/about\">About</a>"),l.default.createElement("p",null,"That works well enough for simple paths, but what about paths that include params? For that, you need to pass an object using the"," ",l.default.createElement(o.InlineJS,null,"params")," property. This object's keys should be the same as the route's expected params. The params object should also include the params for any parent routes."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"{\n  name: 'Album',\n  path: 'a/:albumID',\n  ...,\n  children: [\n    {\n      name: 'Song',\n      path: ':songID',\n      ...\n    }\n  ]\n}\n\n<Link to='Song' params={{ albumID: 2390, songID: 7 }}>\n  Some Song on Some Album\n</Link>\n// <a href=\"/a/2390/7>Some Song on Some Album</a>"),l.default.createElement("p",null,"If you want to attach additional location information to a Link, you can do so using the property names as props. These would be ",l.default.createElement(o.InlineJS,null,"query"),","," ",l.default.createElement(o.InlineJS,null,"hash"),", and ",l.default.createElement(o.InlineJS,null,"state"),"."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"<Link\n  to='Song'\n  params={{ albumID: 2390, songID: 8 }}\n  query={{ time: 17 }}\n>\n  Some Song on Some Album\n</Link>\n// <a href=\"/a/2390/8?time=17>Some Song on Some Album</a>"),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"children")," prop will be passed as the children of the anchor, the same as if you were to use a regular anchor."),l.default.createElement(i.Subsection,{title:"Why not an anchor?",id:"why-link"},l.default.createElement("p",null,"We use a ",l.default.createElement(o.InlineComponent,null,"Link")," because a regular anchor would not work here. Clicking the anchor would cause a full page reload. The"," ",l.default.createElement(o.InlineComponent,null,"Link")," uses calls the ",l.default.createElement(o.InlineJS,null,"navigate")," method from your Hickory history object to allow for in-app navigation without reloading the page."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"// if you render this, clicking it will reload the page\n<a href=\"/about\">About</a>\n\n// while rendering this will not cause a reload\n<Link to='About'>About</Link>\n"),l.default.createElement("p",null,'Both of the above elements render the same thing to the page, an anchor element, but the "magic" is the Link\'s usage of your history object.')),l.default.createElement(u.Note,null,"This does not cover all of the Link props. Please check out the"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"react"},hash:"Link"},"Link")," ","API docs to learn more about the other props.")),l.default.createElement("p",null,"The above guide should cover what you need to know to get started with using Curi and React. However, there are also more React components that you might find useful. You can read more about them in the"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"react"}},l.default.createElement(o.InlineJS,null,"@curi/react"))," ","documentation."))}},108:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=i(n(0)),a=n(1),r=i(n(55)),o=n(2),u=(n(6),n(4));function i(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"In the code splitting guide, we used the ",l.default.createElement(o.InlineJS,null,"on.initial()")," property of routes. Routes also have ",l.default.createElement(o.InlineJS,null,"on.every()")," and"," ",l.default.createElement(o.InlineJS,null,"response()")," properties. While ",l.default.createElement(o.InlineJS,null,"initial"),"is only called the first time a route matches, ",l.default.createElement(o.InlineJS,null,"on.every()")," and"," ",l.default.createElement(o.InlineJS,null,"response()")," are called every time a route matches."),l.default.createElement(u.Section,{title:"every",id:"every"},l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"on.every()")," is where you should perform any data loading for the matched route."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    name: 'Recipe',\n    path: 'recipe/:id'\n  }\n];"),l.default.createElement("p",null,"When the ",l.default.createElement(o.InlineJS,null,"Recipe")," route matches, we want to fetch data for that specific recipe (using the ",l.default.createElement(o.InlineJS,null,"id")," param from the path)."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"every"),' function will be passed a "route" object that contains ',l.default.createElement(o.InlineJS,null,"params"),", ",l.default.createElement(o.InlineJS,null,"location")," and ",l.default.createElement(o.InlineJS,null,"name")," ","properties. Between those properties, you should be able to create any data API requests."),l.default.createElement("p",null,"Just like the ",l.default.createElement(o.InlineJS,null,"on.initial()")," function, ",l.default.createElement(o.InlineJS,null,"on.every()")," is expected to return a Promise."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"{\n  name: 'Recipe',\n  path: 'recipe/:id',\n  on: {\n    every: ({ params }) => fakeAPI.getRecipe(params.id)\n  }\n}"),l.default.createElement("p",null,"Now, when we navigate to ",l.default.createElement(o.InlineJS,null,"/recipe/chocolate-chip-cookies"),", our"," ",l.default.createElement(o.InlineJS,null,"every")," function will call the fake API function to load the recipe. The function will resolve with the loaded data.")),l.default.createElement(u.Section,{title:"response",id:"response"},l.default.createElement("p",null,"While ",l.default.createElement(o.InlineJS,null,"on.every()")," starts our data loading, it doesn't actually do anything. Instead, we should handle any loaded data with the"," ",l.default.createElement(o.InlineJS,null,"response()")," function."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"response()")," and ",l.default.createElement(o.InlineJS,null,"on.every()")," are separate because while a route is resolving, the user may navigate again, which overrides the current navigation. We cannot cancel the ",l.default.createElement(o.InlineJS,null,"on.every()")," ","function for the current navigation, so if it performs any side effects, our application is stuck with them. To avoid this, the"," ",l.default.createElement(o.InlineJS,null,"response()")," function is not called until we know that the current navigation will complete."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"response()")," function will receive an object with a number of properties. These are covered in detail in the"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"routes"},hash:"response"},"All About Routes")," ","guide. The function returns an object with values that will modify the response."),l.default.createElement("p",null,"Here, we will be using the ",l.default.createElement(o.InlineJS,null,"resolved")," object to modify the response's ",l.default.createElement(o.InlineJS,null,"data")),l.default.createElement(o.PrismBlock,{lang:"javascript"},"{\n  name: 'Recipe',\n  path: 'recipe/:id',\n  response({ resolved }) {\n    return {\n      body: Recipe,\n      data: resolved.every\n    }\n  },\n  on: {\n    every: ({ params }) => fakeAPI.getRecipe(params.id),\n  }\n}"),l.default.createElement("p",null,"If at some point in time we decide that we want to change our URI pathname structure, we can also use the ",l.default.createElement(o.InlineJS,null,"response()")," function to redirect."),l.default.createElement("p",null,"You can specify the route to redirect to with ",l.default.createElement(o.InlineJS,null,"redirectTo"),". This takes the ",l.default.createElement(o.InlineJS,null,"name")," of the route to redirect to,"," ",l.default.createElement(o.InlineJS,null,"params")," if the route (or ancestor routes) have route params."," ",l.default.createElement(o.InlineJS,null,"hash"),", ",l.default.createElement(o.InlineJS,null,"query"),", and ",l.default.createElement(o.InlineJS,null,"state")," can also be provided."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"{\n  name: 'Old Recipe',\n  path: 'r/:id',\n  response: ({ params }) => {\n    // destructure the current location to preserve\n    // query/hash values\n    return {\n      redirectTo: {\n        name: 'Recipe',\n        params: params,\n        hash: location.hash\n      }\n    };\n  }\n}"),l.default.createElement("p",null,"After Curi emits the response, it will also automatically redirect to the new location!")),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"every")," and ",l.default.createElement(o.InlineJS,null,"response")," offer a conveneint great place to do any route setup prior to actually rendering the route. Please remember, however, that your application will not be re-rendering until after the fetching has resolved. If you have a long running load function, you may wish to implement some sort of loading display. The"," ",l.default.createElement(a.Link,{to:"Example",params:{category:"react",slug:"data-loading"}},"data loading example")," ","shows one approach to how to do this."))}},109:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=s(n(0)),a=n(1),r=s(n(55)),o=n(2),u=n(6),i=n(4);function s(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"If you are bundling an application with a lot of routes, users of your application may be downloading a lot of unnecessary content just to render the initial page. Using code splitting, you can reduce the initial download size for your application by splitting code that is conditionally loaded into a separate bundle that is only downloaded when it is needed."),l.default.createElement(u.Note,null,"This guide assumes that you are using Webpack 2+ to bundle your application."),l.default.createElement(i.Section,{title:"An app without code splitting",id:"no-split"},l.default.createElement("p",null,"Let's start out by describing our application's routes without code splitting. We will import each route's component from the files where they are defined."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"import Home from './components/Home';\nimport Contact from './components/Contact';\nimport ContactMethod from './components/ContactMethod';\n\nconst routes = [\n  {\n    name: 'Home',\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    name: 'Contact',\n    path: 'contact',\n    response: () => {\n      return {\n        body: Contact\n      };\n    },\n    children: [\n      {\n        name: 'Contact Method',\n        path: ':method',\n        response: () => {\n          return {\n            body: ContactMethod\n          };\n        }\n      }\n    ]\n  }\n];")),l.default.createElement(i.Section,{title:"import() in on.initial()",id:"initial"},l.default.createElement("p",null,"Instead of having static imports, we will use the ",l.default.createElement(o.InlineJS,null,"import()")," ","function to import our modules. We will import our components using the"," ",l.default.createElement(o.InlineJS,null,"on.initial()")," property of routes. This function will only be called the first time that its route matches, so we don't have to worry about making extra requests to our server."),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"on.initial()")," should be a function that returns a Promise;"," ",l.default.createElement(o.InlineJS,null,"import()"),", conveniently, returns a Promise. Then, in our"," ",l.default.createElement(o.InlineJS,null,"response()")," function, instead of referencing values imported at the top of the file, we can reference the result of the"," ",l.default.createElement(o.InlineJS,null,"initial")," function using ",l.default.createElement(o.InlineJS,null,"resolved.initial"),"."),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"import()")," resolves with a module object, so we will just assume that the component are default imports and reference them as"," ",l.default.createElement(o.InlineJS,null,"resolved.initial.default"),". Alternatively, we could just resolve the default value in our ",l.default.createElement(o.InlineJS,null,"on.initial()")," function."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    name: 'Home',\n    path: '',\n    response: ({ resolved }) => {\n      return {\n        body: resolved.initial.default\n      };\n    },\n    on: {\n      initial: () => import('./components/Home'),\n    }\n  },\n  {\n    name: 'Contact',\n    path: 'contact',\n    response: ({ resolved }) => {\n      return {\n        body: resolved.initial.default\n      };\n    },\n    on: {\n      initial: () => import('./components/Contact'),\n    },\n    children: [\n      {\n        name: 'Contact Method',\n        path: ':method',\n        response: ({ resolved }) => {\n          return {\n            body: resolved.initial.default\n          };\n        },\n        on: {\n          // we can resolve module.default in initial\n          // instead of in response\n          initial: () => import('./components/ContactMethod')\n            .then(module => module.default)\n        }\n      }\n    ]\n  }\n];")),l.default.createElement(i.Section,{title:"Next",id:"next"},l.default.createElement("p",null,"The approaches taken here are not the only way to do code splitting. You may choose to skip the ",l.default.createElement(o.InlineJS,null,"on.initial()")," method and do code splitting at other points in your application. Whatever path you decide to go, hopefully this has shown you that setting up code splitting with the ",l.default.createElement(o.InlineJS,null,"on.initial()")," property is fairly simple to do. If you are using Webpack and want to reduce your initial bundle size,"," ",l.default.createElement(o.InlineJS,null,"on.initial()")," is an easy way to accomplish this."),l.default.createElement("p",null,"Next, we will take a look at some related route properties in"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"loading"}},"the loading guide"),".")))}},110:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=i(n(0)),a=n(1),r=i(n(55)),o=n(2),u=n(4);function i(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"Curi side effects are permament observers of your router, but you can specify whether they should be run before or after observers that were setup using ",l.default.createElement(o.InlineJS,null,"router.respond()"),"."),l.default.createElement("p",null,"Whenever a new response is generated, all of the side effect functions will be called. They will be given two arguments: the new response object and an object with navigation information (the navigation action the previous response)."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"function logResponse({ response }) {\n  // call your logging API to record the response\n}"),l.default.createElement(u.Section,{title:"Adding Side Effects",id:"adding"},l.default.createElement("p",null,"Side effects are provided to your router with the ",l.default.createElement(o.InlineJS,null,"sideEffects")," ","property of the options object. This is an array of objects with an"," ",l.default.createElement(o.InlineJS,null,"effect")," observer function."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const router = curi(history, routes, {\n  sideEffects: [{ effect: logResponse }]\n});"),l.default.createElement("p",null,"Side effects can also have an ",l.default.createElement(o.InlineJS,null,"after")," property. By default, side effect functions will be called before any regular observer functions (the ones added with ",l.default.createElement(o.InlineJS,null,"router.respond()"),"). However, you might prefer for a side effect to be run after those observers. To do that, you just need to include ",l.default.createElement(o.InlineJS,null,"after: true")," in your side effect object. If you do no provide this property, this will default to"," ",l.default.createElement(o.InlineJS,null,"false"),"."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const router = curi(history, routes, {\n  sideEffects: [{ effect: logResponse, after: true }]\n});"),l.default.createElement(u.Subsection,{title:"Official Side Effects",id:"official"},l.default.createElement("p",null,'Curi has two "official" side effect packages:'),l.default.createElement("ul",null,l.default.createElement("li",null,l.default.createElement(a.Link,{to:"Package",params:{package:"side-effect-title"}},"@curi/side-effect-title")),l.default.createElement("li",null,l.default.createElement(a.Link,{to:"Package",params:{package:"side-effect-scroll"}},"@curi/side-effect-scroll"))))),l.default.createElement(u.Section,{title:"Creating Side Effects",id:"creating"},l.default.createElement("p",null,"Side effects are just simple functions that receive a response object and a navigation object and do something with them. One thing that they should not do, however, is to modify the response."),l.default.createElement("p",null,"Below is a side effect function that sets a modified property on the object."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"function mySideEffect({ response, navigation }) {\n  console.log('Navigating to', response.location);\n  console.log('Navigation action:', navigation.action);\n}\n\nconst router = curi(history, routes, {\n  sideEffects: [{ effect: mySideEffect }]\n});"),l.default.createElement("p",null,"You can write a side effect factory if you need to create a more customizable side effect."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"function AnalyticsLogger(options) {\n  // do some setup with the provided options\n  const logger = setupMyLogger(options);\n\n  // and return the actual side effect function\n  return sideEffect({ response }) {\n    logger(response);\n  }\n}"),l.default.createElement("p",null,"That really is all there is required to know in order to write your own side effects. You may want to review the"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"responses"},hash:"response-properties"},"response properties")," ","to know which properties you should expect a response to have, but other than that they are pretty simple.")),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Next we will take a closer look at how to add",l.default.createElement(a.Link,{to:"Guide",params:{slug:"code-splitting"}},"code-splitting")," ","to routes.")))}},111:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=i(n(0)),a=n(1),r=i(n(55)),o=n(2),u=n(4);function i(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"Route interactions let you interact with a registered route using its name."),l.default.createElement("p",null,"A registered route is generally any route that is in the array of routes that you used to create your router. However, some interactions only register routes that meet some criteria."),l.default.createElement("p",null,"Route interactions are defined using objects with four properties: name, register, get, and reset."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"{\n  // The string you will use to call the interaction.\n  name: 'my',\n\n  // A function used internally to register routes\n  // with the interaction. You only need to use this when\n  // writing your own interactions.\n  register: function(route, parentData) {...},\n\n  // This is the function that you will call. For example,\n  // with this interaction, the get function will be called\n  // when you call router.route.my('...')\n  get: function(route) {...},\n  reset: function() {...}\n}"),l.default.createElement("p",null,"Instead of importing the actual route interaction object, you typically import a factory function to create the object. This isn't absolutely necessary, but is useful for server-side rendering."),l.default.createElement(o.PrismBlock,{lang:"javascript"},'// interactions/my.js\nexport default function createMyInteraction() {\n  return {\n    name: "my",\n    register() {...},\n    get() {...},\n    reset() {...}\n  };\n}\n\n// index.js\nimport createMyInteraction from "./interactions/my";\n\nconst interaction = createMyInteraction();'),l.default.createElement(u.Section,{title:"Adding Interactions",id:"adding"},l.default.createElement("p",null,"Route interactions are provided to the router call as an array using the"," ",l.default.createElement(o.InlineJS,null,"route")," property of the options object (the third argument)."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const router = curi(history, routes, {\n  route: [createMyInteraction()]\n});"),l.default.createElement("p",null,"The route interaction will be added to the router's ",l.default.createElement(o.InlineJS,null,"route")," ","property. To call an interaction, you simply use its name."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const myValue = router.route.my('Some Route', ...);")),l.default.createElement(u.Section,{title:"Creating Route Interactions",id:"creating"},l.default.createElement("p",null,"There are just a few steps to creating your own route interactions."),l.default.createElement("p",null,"Remember to export a function that will create the interaction object, not the actual interaction object."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"// we'll create an interaction confirms a route is registered\nexport default function confirmInteraction() {\n  ...\n}"),l.default.createElement("p",null,"The function should return an object with four properties:"," ",l.default.createElement(o.InlineJS,null,"name"),", ",l.default.createElement(o.InlineJS,null,"register"),", ",l.default.createElement(o.InlineJS,null,"get"),", and"," ",l.default.createElement(o.InlineJS,null,"reset"),"."),l.default.createElement("ul",null,l.default.createElement("li",null,l.default.createElement(o.InlineJS,null,"name")," is a unique identifier for the route interaction."),l.default.createElement("li",null,l.default.createElement(o.InlineJS,null,"register")," is a function to internally store information about routes."),l.default.createElement("li",null,l.default.createElement(o.InlineJS,null,"get")," is a function that will receive a route's name (and possibly other arguments) and perform some task using the related route"),l.default.createElement("li",null,l.default.createElement(o.InlineJS,null,"reset")," is a function that will reset the interaction's internal state (this is used if you call"," ",l.default.createElement(o.InlineJS,null,"router.replaceRoutes()"),").")),l.default.createElement(o.PrismBlock,{lang:"javascript"},"export default function confirmInteraction() {\n  // maintain an object of known routes\n  let knownRoutes = {};\n  return {\n    name: 'confirm',\n    // when a route is registered, we store it using its name\n    register: route => {\n      knownRoutes[route.name] = true;\n    },\n    // get checks the known routes to see if one exists with\n    // the requested name\n    get: (name) => {\n      return knownRoutes[name] != null\n    },\n    // reset the known routes\n    reset: () => {\n      knownRoutes = {};\n    }\n  };\n}"),l.default.createElement("p",null,"In your application, you can import it, call the factory to create the interaction, and register the interaction when you create the router."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"import curi from '@curi/core';\nimport confirmFactory from './interactions/confirm'\n\nconst routes = [{ name: 'Home', path: '' }];\n\nconst router = curi(history, routes, {\n  route: [confirmFactory()]\n});\n\nrouter.route.confirm('Home'); // true\nrouter.route.confirm('Elsewhere'); // false"),l.default.createElement(u.Subsection,{title:"Slightly more advanced",id:"Slightly-more-advanced"},l.default.createElement("p",null,"You might want to write an interaction that uses data from parent routes when registering a route. For example, the built-in pathname interaction joins a route's path with it parent path(s)."),l.default.createElement("p",null,"The second argument passed to a router interaction's"," ",l.default.createElement(o.InlineJS,null,"register()")," function is a parent data object. For root routes, this will be ",l.default.createElement(o.InlineJS,null,"undefined"),". For nested routes, this is the value returned by the parent route's ",l.default.createElement(o.InlineJS,null,"register()")," ","function."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"function ParentFactory() {\n  let routeTree = {};\n  return {\n    name: 'routeParent',\n    register: (route, parent) => {\n      routeTree[route.name] = parent;\n      // we return route.name and any child routes will receive that\n      // as their parent value\n      return route.name;\n    },\n    get: (name) => {\n      return routeTree[name];\n    },\n    reset: () => {\n      routeTree = {};\n    }\n  }\n}"))),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Next on the list are side effects, which you can learn more about in the"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"side-effects"}},"Using Side Effects")," ","guide.")))}},112:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=i(n(0)),a=n(1),r=i(n(55)),o=n(2),u=(n(6),n(4));function i(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement(u.Section,{title:"The Properties of a Navigation Object",id:"navigation-properties"},l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"navigation")," object contains information about the previous navigation. It has two properties: ",l.default.createElement(o.InlineJS,null,"action")," and"," ",l.default.createElement(o.InlineJS,null,"previous"),"."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"{\n  // the type of navigation,\n  // either PUSH, REPLACE, or POP\n  action: 'PUSH',\n\n  // the previous response object\n  // or null for the initial response\n  previous: {\n    name: 'Home',\n    ...\n  }\n}")),l.default.createElement(u.Section,{title:"Usage",id:"usage"},l.default.createElement("p",null,"What is the point of the ",l.default.createElement(o.InlineJS,null,"navigation")," object? It is there to provide you information about a navigation that doesn't make sense to attach to a ",l.default.createElement(o.InlineJS,null,"response")," object."),l.default.createElement("p",null,"One usage of it would be to display a Pinterest/Twitter style modal. You could render the background using the previous response while rendering the modal using the new response."),l.default.createElement("p",null,"Another use case may be to determine how to transition between two locations, either using the ",l.default.createElement(o.InlineJS,null,"action")," to determine ",l.default.createElement("em",null,"how")," ","the application navigated or the ",l.default.createElement(o.InlineJS,null,"previous")," response to map between two routes.")),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Let's take a moment to go back to our router and look at what Curi's route interactions are for in the"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"route-interactions"}},"Route Interactions")," ","guide.")))}},113:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=s(n(0)),a=n(1),r=s(n(55)),o=n(2),u=n(6),i=n(4);function s(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"Response objects are created by the router to descibe the route that matches a location. Some of these properties are set automatically, while others can be modified using the object returned a route's"," ",l.default.createElement(o.InlineJS,null,"response()")," function."),l.default.createElement(u.Note,null,"You can review the response properties that can be modified in the"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"routes"},hash:"response"},"routes guide"),"."),l.default.createElement(i.Section,{title:"The Properties of a Response Object",id:"response-properties"},l.default.createElement("p",null,'There are two types of response properties. The "match" properties are set based on the route that matches a location. A response always has these proeprties. The "settable" properties are ones that are added by a matched route\'s ',l.default.createElement(o.InlineJS,null,"response()")," function. These only exist on the response when they are returned by ",l.default.createElement(o.InlineJS,null,"route.response()"),"."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"// match properties\n{\n  // The location object used to generate the response.\n  location: { pathname: '/photos/6789/12345', ... },\n\n  // The name of the best matching route\n  name: 'Photo',\n\n  // The name of ancestor routes that matched\n  // part of the location's pathname\n  partials: ['Album'],\n\n  // An object containing the values parsed\n  // from the pathname by path-to-regexp.\n  // This includes params from ancestor routes.\n  params: { photoID: 12345, albumID: 6789 },\n        }"),l.default.createElement(o.PrismBlock,{lang:"javascript"},"// settable properties\n{\n  // The body value is set using a route's response() return object.\n  // This is where you can attach component(s) to a route. The structure here\n  // is up to you, but each of your routes should have the same structure.\n  body: Photo,\n  // or maybe\n  body: {\n    menu: PhotoMenu,\n    main: Photo\n  },\n  // Please see below for more information about this property\n\n  // The status code for the response.\n  // This is mostly useful for server-side rendering\n  status: 200,\n\n  // This can be anything you want. It is set using\n  // a route's response() return object.\n  data: {...},\n\n  // The title string is set using a route's response() return object\n  title: 'Photo 12345',\n\n  // A value set by the route's response() return object.\n  error: undefined,\n\n  // A location to redirect to\n  redirectTo: {...}\n}"),l.default.createElement(i.Subsection,{title:"Redirect Response",id:"redirect-properties"},l.default.createElement("p",null,"When ",l.default.createElement(o.InlineJS,null,"route.response()")," returns an object with a"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"routes"},hash:"response"},l.default.createElement(o.InlineJS,null,"redirectTo")," property")," ","the router will turn this into a location object. Curi will automatically redirect to this location."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"{\n  // The redirectTo property provides information on\n  // where you should redirect to\n  redirectTo: { pathname: '/login' }\n}"),l.default.createElement("p",null,"You can choose whether or not you want responses with a"," ",l.default.createElement(o.InlineJS,null,"redirectTo")," property to be emitted. The default behavior is to emit them, but this also means that you have to render using the redirect response. The ",l.default.createElement(o.InlineJS,null,"{ emitRedirects: false }")," option prevents this."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const router = curi(history, routes, {\n  emitRedirects: false\n});"))),l.default.createElement(i.Section,{title:"The Body Property",id:"body-property"},l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"body")," property of a response is likely the most important property of a ",l.default.createElement(o.InlineJS,null,"response")," because it is what you will actually render. This value can be anything you want it to be, but it should usually be a function/component or an object containing functions/components."),l.default.createElement(o.PrismBlock,{lang:"javascript"},'{\n  name: "Home",\n  path: "",\n  response: () => {\n    // a function/component\n    return {\n      body: Home\n    };\n    // an object containing\n    // functions/componnets\n    return {\n      body: {\n        menu: HomeMenu,\n        main: Home\n      }\n    };\n  }\n}'),l.default.createElement(u.Note,null,"It is important that each route uses the same structure for setting the body. Mixing structures will make rendering more difficult.")),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Next, we'll take a look at"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"observers"}},"observers"),".")))}},114:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=s(n(0)),a=n(1),r=s(n(55)),o=n(2),u=n(6),i=n(4);function s(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"The Curi router uses an observer pattern. You give it an observer function and when a response is created, that function will be called."),l.default.createElement(i.Section,{title:"Observer Argument",id:"argument"},l.default.createElement("p",null,"Observers are passed an object with three properties:"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"core"},hash:"properties"},l.default.createElement(o.InlineJS,null,"router")),","," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"responses"}},l.default.createElement(o.InlineJS,null,"response")),", and"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"navigation-objects"}},l.default.createElement(o.InlineJS,null,"navigation")),". Which ones you use vary based on what the response handler is doing."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"function responseHandler({ router, response, navigation }) {\n  // ...\n}")),l.default.createElement(i.Section,{title:"Use Cases",id:"use-cases"},l.default.createElement("p",null,"When should you use observers?"),l.default.createElement(i.Subsection,{title:"Setup",id:"setup"},l.default.createElement("p",null,"If any of the routes in an application have ",l.default.createElement(o.InlineJS,null,"on.initial()")," or"," ",l.default.createElement(o.InlineJS,null,"on.every()")," functions, when those routes match the response will be emitted asynchronously. When the application first renders, if the router matches an async route, the response isn't immediately ready to use. To deal with this, you can use an observer to render once the initial response is ready."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"function setup({ router }) {\n  ReactDOM.render((\n    <CuriProvider router={router}>\n      {({ response }) => <response.body />}\n    </CuriProvider>\n  ), document.getElementById('root'));\n}"),l.default.createElement("p",null,"A setup function only needs to be called once, so you can call"," ",l.default.createElement(o.InlineJS,null,"router.respond()")," without any options."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"router.respond(setup);"),l.default.createElement(u.Note,null,"Setup is the only thing your application ",l.default.createElement("em",null,"should")," need to write an observer for.")),l.default.createElement(i.Subsection,{title:"Rendering",id:"rendering"},l.default.createElement("p",null,"You could manually re-render your application by using a response handler that observes the router for every response (by passing the"," ",l.default.createElement(o.InlineJS,null,"{ observe: true }")," option to ",l.default.createElement(o.InlineJS,null,"router.respond()"),")."),l.default.createElement("p",null,"If your application is using one of the provided Curi rendering packages (",l.default.createElement(a.Link,{to:"Package",params:{package:"react"}},l.default.createElement(o.InlineJS,null,"@curi/react")),","," ",l.default.createElement(a.Link,{to:"Package",params:{package:"react-native"}},l.default.createElement(o.InlineJS,null,"@curi/react-native")),","," ",l.default.createElement(a.Link,{to:"Package",params:{package:"vue"}},l.default.createElement(o.InlineJS,null,"@curi/vue")),", and"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"svelte"}},l.default.createElement(o.InlineJS,null,"@curi/svelte")),") you won't actually have to manually observe the router because those packages do that internally for you."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"function render({ response }) {\n  // render somehow\n}\n\nrouter.respond(render, { observe: true });")),l.default.createElement(i.Subsection,{title:"Side Effects",id:"side-effects"},l.default.createElement("p",null,"Side effects are observers that are provided to the router at creation instead of by calling ",l.default.createElement(o.InlineJS,null,"router.respond()"),". These can be useful for tasks that are not rendering related as well as for tasks that need to be performed after a render has completed."),l.default.createElement("p",null,"The"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"side-effect-title"}},l.default.createElement(o.InlineJS,null,"@curi/side-effect-title"))," ","package provides a side effect that will use ",l.default.createElement(o.InlineJS,null,"response.title")," ","to set the page's ",l.default.createElement(o.InlineJS,null,"document.title"),"."),l.default.createElement("p",null,"With single-page applications, clicking on links wish hashes won't always scroll to the matching element in the page. The"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"side-effect-scroll"}},l.default.createElement(o.InlineJS,null,"@curi/side-effect-scroll"))," ","package adds this behavior by scrolling the page to the element that matches the new response's hash (",l.default.createElement(o.InlineJS,null,"response.location.hash"),") after the new response has rendered."),l.default.createElement("p",null,"If you need to add logging to your application, you could write your own observer to do this. Your observer can either be added as a side effect when the router is constructed or later using"," ",l.default.createElement(o.InlineJS,null,"router.respond()"),"."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"function logger({ response }) {\n  loggingAPI.add(response.location);\n}\n\n// as a side-effect\nconst router = curi(history, routes, {\n  sideEffects: [{ fn: logger }]\n});\n\n// with respond\nrouter.respond(logger, { observe: true });"))),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Next, we will cover"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"navigation-objects"}},"navigation objects"),".")))}},115:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=s(n(0)),a=n(1),r=s(n(55)),o=n(2),u=n(6),i=n(4);function s(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"Routes are JavaScript objects with two required props—",l.default.createElement(o.InlineJS,null,"name")," and"," ",l.default.createElement(o.InlineJS,null,"path"),"—and a number of optional properties."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"{\n  name: 'Home',\n  path: ''\n};"),l.default.createElement(i.Section,{title:"Route properties",id:"route-properties"},l.default.createElement(i.Subsection,{title:"route.name",id:"name"},l.default.createElement("p",null,"A string, this must be unique for every route."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"[\n  { name: 'Home' },\n  { name: 'Album' },\n  { name: 'Not Found' }\n];")),l.default.createElement(i.Subsection,{title:"route.path",id:"path"},l.default.createElement("p",null,"A string to describe what the route matches. Curi uses"," ",l.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp#parameters"},l.default.createElement(o.InlineJS,null,"path-to-regexp"))," ","for matching the route to a location's ",l.default.createElement(o.InlineJS,null,"pathname"),"."," ",l.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp#parameters"},"Path parameters")," ","will be captured so that they can be parsed from a location's"," ",l.default.createElement(o.InlineJS,null,"pathname")," when the route matches."),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"path")," strings should ",l.default.createElement("strong",null,"not")," have a leading slash"),l.default.createElement(o.PrismBlock,{lang:"javascript"},"[\n  { name: 'Home', path: '' },\n  { name: 'Album', path: 'a/:albumID' },\n  { name: 'Not Found', path: '(.*)' }\n];\n// don't do this\n// { name: 'Home', path: '/' }"),l.default.createElement(u.Warning,null,l.default.createElement(o.InlineJS,null,"path-to-regexp")," supports arrays and RegExps, but Curi only supports string paths. This is because Curi needs to generate pathnames given a route name and ",l.default.createElement(o.InlineJS,null,"path-to-regexp")," can only do that from strings.")),l.default.createElement(i.Subsection,{title:"route.on",id:"on"},l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"on")," object groups functions that will be called when the route matches. A route with an ",l.default.createElement(o.InlineJS,null,"on.initial()")," or"," ",l.default.createElement(o.InlineJS,null,"on.every()")," function is async."),l.default.createElement(i.Subsection,{tag:"h5",title:"on.initial()",id:"initial"},l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"on.initial()")," is called the first time that a route matches. Its return value will be re-used on subsequent matches. It should return a Promise."),l.default.createElement("p",null,"This can be used for loading resources that don't change based on"," ",l.default.createElement(o.InlineJS,null,"params"),". For example, if you are doing code splitting with Webpack using ",l.default.createElement(o.InlineJS,null,"import()"),", you can load the modules in"," ",l.default.createElement(o.InlineJS,null,"on.initial()"),"."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"initial")," function will be passed an object with the matched route properties: ",l.default.createElement(o.InlineJS,null,"name"),", ",l.default.createElement(o.InlineJS,null,"params"),","," ",l.default.createElement(o.InlineJS,null,"partials"),", ",l.default.createElement(o.InlineJS,null,"location"),", and ",l.default.createElement(o.InlineJS,null,"key"),"."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const about = {\n  name: 'About',\n  path: 'about',\n  on: {\n    initial: () => import('./components/About')\n  }\n};")),l.default.createElement(i.Subsection,{tag:"h5",title:"on.every()",id:"every"},l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"on.every()")," will be called every time a route matches. This can be useful for data fetching. Like ",l.default.createElement(o.InlineJS,null,"on.initial()"),","," ",l.default.createElement(o.InlineJS,null,"on.every()")," should return a Promise."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"every")," function will be passed an object with the matched route properties: ",l.default.createElement(o.InlineJS,null,"name"),", ",l.default.createElement(o.InlineJS,null,"params"),","," ",l.default.createElement(o.InlineJS,null,"partials"),", ",l.default.createElement(o.InlineJS,null,"location"),", and ",l.default.createElement(o.InlineJS,null,"key"),"."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"// fetch user data\nconst user = {\n  name: 'User',\n  path: ':id',\n  on: {\n    every: ({ params, location }) =>\n      fetch(`/api/users/${params.id}`)\n        .then(resp => JSON.parse(resp))\n  }\n}"),l.default.createElement(u.Note,null,"You should not perform side effects (e.g. passing the loaded data to a Redux store) in ",l.default.createElement(o.InlineJS,null,"on.every()")," because it is possible that navigating to the route might be cancelled. If you must perform side effects, you should do so in ",l.default.createElement(o.InlineJS,null,"response()"),"."))),l.default.createElement(i.Subsection,{title:"route.response()",id:"response"},l.default.createElement("p",null,'A function for modifying the response object. This returns an object whose properties will be merged with the matched route properties to create the "final" response.'),l.default.createElement("p",null,"Only valid properties will be merged onto the response; everything else will be ignored. The valid properties are:"),l.default.createElement("ol",null,l.default.createElement("li",null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"body")," - This is usually what you will render."),l.default.createElement(o.PrismBlock,{lang:"javascript"},'import Home from "./components/Home";\nconst routes = [\n  {\n    name: "Home",\n    path: "",\n    response: () => ({\n      body: Home\n    })\n  },\n  // ...\n];\n// response = { body: Home, ... }')),l.default.createElement("li",null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"status")," - A number. This is useful for redirects or locations caught by your catch-all route while using server-side rendering. The default status value is ",l.default.createElement(o.InlineJS,null,"200"),"."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"{\n  response: () => ({\n    status: 301,\n    redirectTo: {...}\n  })\n}\n// response = { status: 301, ... }")),l.default.createElement("li",null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"error")," - If an error occurs with the route's"," ",l.default.createElement(o.InlineJS,null,"on")," methods, you might want to attach an error message to the response."),l.default.createElement(o.PrismBlock,{lang:"javascript"},'{\n  on: {\n    initial: () => Promise.reject("woops!")\n  },\n  response: ({ error }) => ({\n    error\n  })\n}\n// response = { error: "woops!", ... }')),l.default.createElement("li",null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"data")," - Anything you want it to be."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"{\n  response = () => ({\n    data: Math.random();\n  })\n}\n// response = { data: 0.8651606708109429, ... }")),l.default.createElement("li",null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"title")," - This can be used with"," ",l.default.createElement(o.InlineJS,null,"@curi/side-effect-title")," to update the page's"," ",l.default.createElement(o.InlineJS,null,"document.title"),"."),l.default.createElement(o.PrismBlock,{lang:"javascript"},'{\n  response: ({ params }) => ({\n    title: `User ${params.id}`\n  })\n}\n// when visting /user/2\n// response = { title: "User 2", ... }')),l.default.createElement("li",null,l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"redirectTo")," - An object with the ",l.default.createElement(o.InlineJS,null,"name")," of the route to redirect to, ",l.default.createElement(o.InlineJS,null,"params")," (if required), and optional ",l.default.createElement(o.InlineJS,null,"hash"),", ",l.default.createElement(o.InlineJS,null,"query"),", and ",l.default.createElement(o.InlineJS,null,"state")," ","properties."),l.default.createElement("p",null,"The other values are copied directly, but ",l.default.createElement(o.InlineJS,null,"redirectTo")," ","will be turned into a location object using the object's"," ",l.default.createElement(o.InlineJS,null,"name")," (and ",l.default.createElement(o.InlineJS,null,"params")," if required)."),l.default.createElement(o.PrismBlock,{lang:"javascript"},'[\n  {\n    name: "Old Photo",\n    path: "photo/:id",\n    response = ({ params }) => ({\n      redirectTo: { name: "Photo", params }\n    })\n  },\n  {\n    name: "New Photo",\n    path: "p/:id"\n  }\n]\n// when the user navigates to /photo/1:\n// response = { redirectTo: { pathname: "/p/1", ... }, ... }'))),l.default.createElement("p",null,"This function is passed an object with a number of properties that can be useful for modifying the response."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"{\n  response: ({ match, resolved }) => {\n    // ...\n  }\n}"),l.default.createElement("ul",null,l.default.createElement(i.Subsection,{tag:"li",title:"match",id:"response-match"},l.default.createElement("p",null,"An object with the matched route properties of a response."),l.default.createElement("table",null,l.default.createElement("thead",null,l.default.createElement("tr",null,l.default.createElement("th",null,"property"),l.default.createElement("th",null,"description"))),l.default.createElement("tbody",null,l.default.createElement("tr",null,l.default.createElement("td",null,"name"),l.default.createElement("td",null,"the name of the matched route")),l.default.createElement("tr",null,l.default.createElement("td",null,"params"),l.default.createElement("td",null,"route parameters parsed from the location")),l.default.createElement("tr",null,l.default.createElement("td",null,"partials"),l.default.createElement("td",null,"the names of any ancestor routes of the matched route")),l.default.createElement("tr",null,l.default.createElement("td",null,"location"),l.default.createElement("td",null,"the location that was used to match the route")),l.default.createElement("tr",null,l.default.createElement("td",null,"key"),l.default.createElement("td",null,"the location's ",l.default.createElement(o.InlineJS,null,"key"),", which is a unique identifier"))))),l.default.createElement(i.Subsection,{tag:"li",title:"resolved",id:"response-resolved"},l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"resolved")," is an object with the values resolved by the"," ",l.default.createElement(o.InlineJS,null,"on.initial()")," and ",l.default.createElement(o.InlineJS,null,"on.every()")," functions."),l.default.createElement("table",null,l.default.createElement("thead",null,l.default.createElement("tr",null,l.default.createElement("th",null,"property"),l.default.createElement("th",null,"description"))),l.default.createElement("tbody",null,l.default.createElement("tr",null,l.default.createElement("td",null,"error"),l.default.createElement("td",null,"if either ",l.default.createElement(o.InlineJS,null,"on.initial()")," or ",l.default.createElement(o.InlineJS,null,"on.every()")," ","throw and the error is not caught, it will be available here")),l.default.createElement("tr",null,l.default.createElement("td",null,"initial"),l.default.createElement("td",null,"the value resolved by ",l.default.createElement(o.InlineJS,null,"on.initial()"))),l.default.createElement("tr",null,l.default.createElement("td",null,"every"),l.default.createElement("td",null,"the value resolved by ",l.default.createElement(o.InlineJS,null,"on.every()"))))),l.default.createElement("p",null,"If a route isn't async, ",l.default.createElement(o.InlineJS,null,"resolved")," will be"," ",l.default.createElement(o.InlineJS,null,"null"),"."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"// attach resolved data to the response\nconst user = {\n  name: 'User',\n  path: ':id',\n  response: ({ resolved }) => {\n    const modifiers = {};\n    if (resolved.error) {\n      modifiers.error = resolved.error;\n    } else {\n      modifiers.data = resolved.every;\n    }\n    return modifiers;\n  },\n  on: {\n    every: ({ params, location }) => (\n      fetch(`/api/users/${params.id}`)\n        .then(resp => JSON.parse(resp))\n    ),\n  }\n}")))),l.default.createElement(i.Subsection,{title:"children",id:"children"},l.default.createElement("p",null,"An optional array of route objects for creating nested routes. Any child routes will be matched relative to their parent route's"," ",l.default.createElement(o.InlineJS,null,"path"),". This means that if a parent route's ",l.default.createElement(o.InlineJS,null,"path")," ","string is ",l.default.createElement(o.InlineJS,null,"'one'")," and a child route's ",l.default.createElement(o.InlineJS,null,"path")," string is ",l.default.createElement(o.InlineJS,null,"'two'"),", the child will match when the pathname is"," ",l.default.createElement(o.InlineJS,null,"'one/two'"),"."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"// '/a/Coloring+Book/All+Night' will be matched\n// by the \"Song\" route, with the params\n// { album: 'Coloring+Book', title: 'All+Night' }\n{\n  name: 'Album',\n  path: 'a/:album',\n  children: [\n    {\n      name: 'Song',\n      path: ':title'\n    }\n  ]\n}")),l.default.createElement(i.Subsection,{title:"params",id:"params"},l.default.createElement("p",null,"When ",l.default.createElement(o.InlineJS,null,"path-to-regexp")," matches your paths, all parameters are extracted as strings. However, you might prefer for some route params to be other types. You can provide functions to transform params using the ",l.default.createElement(o.InlineJS,null,"route.params")," object."),l.default.createElement("p",null,"Properties of the ",l.default.createElement(o.InlineJS,null,"route.params")," object are the names of params to be parsed. The paired value should be a function that takes a string (the value from the ",l.default.createElement(o.InlineJS,null,"pathname"),") and returns a new value (transformed however you want)."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    name: 'Number',\n    path: 'number/:num',\n    params: {\n      num: n => parseInt(n, 10)\n    }\n  }\n]\n// when the user visits /number/1,\n// response.params will be { num: 1 } instead of { num: \"1\" }")),l.default.createElement(i.Subsection,{title:"pathOptions",id:"pathOptions"},l.default.createElement("p",null,"If you need to provide different path options than"," ",l.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp#usage"},"the defaults")," ","used by ",l.default.createElement(o.InlineJS,null,"path-to-regexp"),", you can provide them with a"," ",l.default.createElement(o.InlineJS,null,"pathOptions")," object."),l.default.createElement(u.Note,null,"If a route has a children array property, it will"," ",l.default.createElement("strong",null,"always")," have the ",l.default.createElement(o.InlineJS,null,"end")," path option set to false.")),l.default.createElement(i.Subsection,{title:"extra",id:"extra"},l.default.createElement("p",null,"If you have any additional properties that you want attached to a route, use the ",l.default.createElement(o.InlineJS,null,"extra")," property. You will be able to use"," ",l.default.createElement(o.InlineJS,null,"route.extra")," in any custom route interactions."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    name: 'A Route',\n    path: 'a-route',\n    extra: {\n      transition: 'fade'\n    }\n  },\n  {\n    name: 'B Route',\n    path: 'b-route',\n    extra: {\n      enter: 'slide-right'\n    }\n  }\n];"))),l.default.createElement(i.Section,{title:"Matching Routes",id:"matching-routes"},l.default.createElement("p",null,"Whenever Curi receives a new location, it will determine which route has a ",l.default.createElement(o.InlineJS,null,"path")," that matches the new location's ",l.default.createElement(o.InlineJS,null,"pathname")," by walking over the route objects in the order that they are defined in the array. If a route has ",l.default.createElement(o.InlineJS,null,"children"),", those will be checked before moving to the route's nest sibling."),l.default.createElement("p",null,"We'll use this simple route setup to demonstrate how this works."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    name: 'Home',\n    path: '',\n  },\n  {\n    name: 'Album',\n    path: 'a/:album'\n  },\n  {\n    name: 'Not Found',\n    path: '(.*)' // this matches EVERY pathname\n  }\n];"),l.default.createElement("p",null,"Curi's default matching behavior looks for exact matches. This means that when the route only matches part of the pathname, it does not count as a match. If the user navigates to a location with the pathname"," ",l.default.createElement(o.InlineJS,null,'"/a/red/yellow"'),", the ",l.default.createElement(o.InlineJS,null,"Album")," route will only partially match, so Curi will move on to the next route,"," ",l.default.createElement(o.InlineJS,null,"Not Found"),", which has a catch all ",l.default.createElement(o.InlineJS,null,"path")," that matches every pathname."),l.default.createElement("p",null,"However, if a route has children, then Curi will check if any of those routes form a complete match before moving on to the next route in the routes array."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"// when the pathname is '/a/Coloring+Book/All+Night',\n// the Album route will partially match the pathname. Then,\n// its child route Song will be tested and fully match the pathname.\n{\n  name: 'Album',\n  path: 'a/:album',\n  children: [\n    {\n      name: 'Song',\n      path: ':title'\n    }\n  ]\n}"),l.default.createElement("p",null,"You can control whether a route does exact or partial matching with"," ",l.default.createElement(a.Link,{hash:"pathOptions"},l.default.createElement(o.InlineJS,null,"pathOptions"))," ","property. If you set ",l.default.createElement(o.InlineJS,null,"{ end: false }"),", a route that partially matches will consider itself matched."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"// when the pathname is '/a/Good+Kid,+M.A.A.D+City/Poetic+Justice',\n// the Album route will partially match. However, because it sets\n// end to false, the partial match will be used.\n{\n  name: 'Album',\n  path: 'a/:albumID',\n  pathOptions: {\n    end: false\n  }\n}"),l.default.createElement(i.Subsection,{title:"No Matching Route",id:"catch-all"},l.default.createElement(u.Warning,null,l.default.createElement("p",null,"If none of your routes match a location, Curi will do nothing! You need to set a catch-all route to match these locations yourself. The best way to do this is to add a route to the end of your routes array with a ",l.default.createElement(o.InlineJS,null,"path")," of ",l.default.createElement(o.InlineJS,null,'"(.*)"'),", which will match every pathname."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"{\n  name: 'Not Found',\n  path: '(.*)',\n}")))),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Now that you know how to setup your routes, we will take a look at"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"responses"}},"responses"),".")))}},116:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=s(n(0)),a=n(1),r=s(n(55)),o=n(2),u=n(4),i=n(6);function s(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"There are a few concepts that you should know about Curi."),l.default.createElement(u.Section,{title:"The Router",id:"router-object"},l.default.createElement("p",null,"A Curi router is created using the default export function from the"," ",l.default.createElement(o.InlineJS,null,"@curi/core")," package. This function takes a ",l.default.createElement(o.InlineJS,null,"history")," ","object and a ",l.default.createElement(o.InlineJS,null,"routes")," array."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"import curi from '@curi/core';\nimport Browser from '@hickory/browser';\nimport routes from './routes';\n\nconst history = Browser();\nconst router = curi(history, routes);"),l.default.createElement(i.Note,null,"This function also accepts an ",l.default.createElement(o.InlineJS,null,"options")," object. You can read about its properties in the"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"core"},hash:"options"},l.default.createElement(o.InlineJS,null,"@curi/core"))," ","documentation.")),l.default.createElement(u.Section,{title:"The History Object",id:"history-object"},l.default.createElement("p",null,"A router facilitates navigation between locations. Curi does this using a ",l.default.createElement(o.InlineJS,null,"history")," object, which comes from the"," ",l.default.createElement("a",{href:"https://github.com/pshrmn/hickory"},"Hickory")," library. There are a few different types of history objects that you can make; which one you should use depends on where your application will be running and how you are serving the application."),l.default.createElement("p",null,"If you are unsure about how to serve a single-page application,"," ",l.default.createElement("a",{href:"https://medium.com/@pshrmn/single-page-applications-and-the-server-32a23d67936"},"this article")," ","should help."),l.default.createElement("ul",null,l.default.createElement("li",null,l.default.createElement("p",null,l.default.createElement("strong",null,"Browser History")," - If you are building a website that will be hosted on a server that can handle dynamic requests, you should use the ",l.default.createElement(o.InlineJS,null,"@hickory/browser")," package."),l.default.createElement(o.PrismBlock,{lang:"bash"},"npm install @hickory/browser"),l.default.createElement(o.PrismBlock,{lang:"javascript"},"import Browser from '@hickory/browser';\nconst browserHistory = Browser();")),l.default.createElement("li",null,l.default.createElement("p",null,l.default.createElement("strong",null,"Hash History")," - If you are building a website that will be hosted on a static file host, you will need to use the"," ",l.default.createElement(o.InlineJS,null,"@hickory/hash")," package. The paths for your routes will be encoded in the ",l.default.createElement(o.InlineJS,null,"hash"),' section of the URL. This isn\'t as "pretty" as the paths you get with ',l.default.createElement(o.InlineJS,null,"@hickory/browser"),", but is a necessary solution for statically hosted websites."),l.default.createElement(o.PrismBlock,{lang:"bash"},"npm install @hickory/hash"),l.default.createElement(o.PrismBlock,{lang:"javascript"},"import Hash from '@hickory/hash';\nconst hashHistory = Hash();")),l.default.createElement("li",null,l.default.createElement("p",null,l.default.createElement("strong",null,"In Memory History")," - If your application is not running in a browser, you should use an in-memory history. This is what you would use when building a mobile application with React Native, writing a NodeJS backend for your server, or when writing tests that run in NodeJS."),l.default.createElement(o.PrismBlock,{lang:"bash"},"npm install @hickory/in-memory"),l.default.createElement(o.PrismBlock,{lang:"javascript"},"import InMemory from '@hickory/in-memory';\nconst memoryHistory = InMemory();")))),l.default.createElement(u.Section,{title:"The Routes Array",id:"routes-array"},l.default.createElement("p",null,"Routes are objects with two required properties: a ",l.default.createElement(o.InlineJS,null,"name")," ","string and a ",l.default.createElement(o.InlineJS,null,"path")," string."),l.default.createElement(i.Note,null,"Paths can be any valid"," ",l.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp"},"path-to-regexp")," ","string. It is just important that you do not begin the string with a forward slash (",l.default.createElement(o.InlineJS,null,"/"),"). Forward slashes are fine anywhere else in the path. (",l.default.createElement(o.InlineJS,null,"this/is/fine"),", but ",l.default.createElement(o.InlineJS,null,"/this/is/not"),")."),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    name: 'Home',\n    path: '', // matches  '/'\n    // ...\n  },\n  // ...\n]"),l.default.createElement("p",null,"Curi creates URLs for you; you just need to know the name of the route to link to. This means that all routes must have unique names."),l.default.createElement(o.PrismBlock,{lang:"javascript"},'router.navigate({ name: "Home" }); // navigates to "/"'),l.default.createElement("p",null,"The"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"routes"}},"All About Routes")," ","guide provides a more in-depth explanation of how route matching works and the other route properties.")),l.default.createElement(u.Section,{title:"Responses"},l.default.createElement("p",null,"Whenever the user navigates in the app, Curi will create a"," ",l.default.createElement(o.InlineJS,null,"response")," object, which provides data about the route that it matched. The property values of the response object can be modified through the matching route's ",l.default.createElement(o.InlineJS,null,"response()")," function."),l.default.createElement("p",null,"The response object is used to render your application. The response's"," ",l.default.createElement(o.InlineJS,null,"body")," property provides a convenient way to specify what you should render."),l.default.createElement(o.PrismBlock,{lang:"jsx"},"// React\nimport Home from './components/Home';\n\nconst routes = [\n  {\n    name: 'Home',\n    path: '',\n    response() {\n      // set response.body to be the imported\n      // Home component\n      return {\n        body: Home\n      };\n    }\n  }\n];\n\nReactDOM.render((\n  <CuriProvider router={router}>\n    {({ response }) => {\n      // when response.body === Home, this is the same as <Home />\n      return <response.body />;\n    }}\n  </CuriProvider>\n), document.getElementById('root'));")),l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Curi can match routes synchronously or asynchronously. The"," ",l.default.createElement(a.Link,{to:"Guide",params:{slug:"sync-or-async"}},"Sync or Async Guide")," ","covers how this works and what it means for your application."))}},117:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=o(n(0)),a=o(n(12)),r=o(n(3));function o(e){return e&&e.__esModule?e:{default:e}}var u=function(e){var t=e.guides;return l.default.createElement("ul",{className:"link-list"},t.map(function(e){return l.default.createElement("li",{key:e.name,className:"solo"},l.default.createElement(r.default,{to:"Guide",params:{slug:e.slug}},e.name))}))};t.default=function(){var e=a.default.grouped();return l.default.createElement("ul",null,Object.keys(e).map(function(t){return l.default.createElement("li",{className:"link-group",key:t},l.default.createElement("h3",null,t),l.default.createElement(u,{guides:e[t]}))}))}},118:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=i(n(0)),a=n(1),r=i(n(55)),o=n(2),u=n(4);function i(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"The core Curi package to install is ",l.default.createElement(o.InlineJS,null,"@curi/core"),"."),l.default.createElement("p",null,"The router will also need a Hickory package (",l.default.createElement(o.InlineJS,null,"@hickory/browser"),","," ",l.default.createElement(o.InlineJS,null,"@hickory/hash"),", or ",l.default.createElement(o.InlineJS,null,"@hickory/in-memory"),"). Which Hickory package you need depends on the application, but the browser package is best for most websites."),l.default.createElement(o.PrismBlock,{lang:"bash"},"npm install @hickory/browser @curi/core"),l.default.createElement("p",null,"These packages can also be loaded from"," ",l.default.createElement("a",{href:"https://unpkg.com"},"Unpkg"),"."),l.default.createElement(o.PrismBlock,{lang:"markup"},'<script src="https://unpkg.com/@hickory/browser/dist/hickory-browser.min.js"><\/script>\n<script src="https://unpkg.com/@curi/core/dist/curi.min.js"><\/script>'),l.default.createElement(u.Section,{title:"Promises",id:"promises"},l.default.createElement("p",null,"Curi uses Promises, so you may need to include a polyfill to add Promise support for older browsers (including IE 11)."),l.default.createElement("p",null,"If you need a general ES2015 polyfill, you can check out the one provided by Babel's"," ",l.default.createElement("a",{href:"https://babeljs.io/docs/usage/polyfill/#usage-in-browser"},"babel-polyfill")," ","package. If you only need a Promise polyfill, then you should check out the"," ",l.default.createElement("a",{href:"https://github.com/stefanpenner/es6-promise"},"es6-promise")," ","package or ",l.default.createElement("a",{href:"https://polyfill.io/v2/docs/"},"polyfill.io"),".")),l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,l.default.createElement(a.Link,{to:"Guide",params:{slug:"getting-started"}},"Get started")," ","with Curi."))}},119:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=y(n(118)),a=y(n(116)),r=y(n(115)),o=y(n(114)),u=y(n(113)),i=y(n(112)),s=y(n(111)),c=y(n(110)),d=y(n(109)),m=y(n(108)),h=y(n(107)),f=y(n(106)),p=y(n(105)),E=y(n(104));function y(e){return e&&e.__esModule?e:{default:e}}var g={installation:l.default,"getting-started":a.default,"sync-or-async":E.default,routes:r.default,observers:o.default,responses:u.default,"navigation-objects":i.default,"route-interactions":s.default,"side-effects":c.default,"code-splitting":d.default,loading:m.default,react:h.default,"react-native":f.default,"migrate-rrv3":p.default};t.default=g},51:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=r(n(0)),a=r(n(119));function r(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.params,n=e.data;if(!n)return l.default.createElement("div",null,"The requested guide could not be found.");var r=a.default[t.slug];return l.default.createElement(r,{name:n.name})}},55:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=r(n(0)),a=r(n(117));function r(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){var t=e.children;return l.default.createElement("div",{className:"guide"},l.default.createElement("div",{className:"content"},t||null),l.default.createElement("div",{className:"sidebar"},l.default.createElement("h2",null,"Guides"),l.default.createElement(a.default,null)))}}}]);