(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{74:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return s});var a=n(0),o=n.n(a),l=(n(2),n(9)),i=n(17),r=n(10),u=n(6);function s(){return o.a.createElement(o.a.Fragment,null,o.a.createElement(r.a,{title:"Hot Module Replacement",id:"hmr"},o.a.createElement(u.b,null,o.a.createElement("p",null,"Hot module replacement (HMR) can make development more convenient by automatically updating page content without refreshing the page. With Webpack, there are only a few steps required to get this working with Curi."),o.a.createElement("p",null,"The first step is to get your Webpack configuration setup for hot module replacement. Webpack's"," ",o.a.createElement("a",{href:"https://webpack.js.org/guides/hot-module-replacement/"},"hot module replacement guide")," ","is a good resource to learn how to do this.")),o.a.createElement(u.b,null,o.a.createElement("p",null,"The next step is identifying what file(s) you want to watch. A watched file will be notified when it, any of its dependencies, or any dependencies depndencies (and so on down the line) are updated. The best way to do this with a Curi application is to watch the file where your routes are defined."),o.a.createElement("p",null,"The ",o.a.createElement(l.b,null,"router")," has a ",o.a.createElement(l.b,null,"refresh()")," method that is used for providing new routes to the router. When it is called, it will also generate and emit a new response."),o.a.createElement("p",null,o.a.createElement(l.b,null,"module.hot.accept()")," is used for watching a file and calling a callback when that files or any files in its dependency chain are updated. In the callback, we can re-import the routes and pass them to the router's ",o.a.createElement(l.b,null,"refresh()")," method. This will in turn emit a new response, which will automatically be rendered."),o.a.createElement("p",null,"With that, your application should be setup to support hot module replacement.")),o.a.createElement(u.a,{"data-line":"9-14"},'// index.js\nimport { curi } from "@curi/core";\nimport Browser from "@hickory/browser";\nimport routes from "./routes";\n\nconst history = Browser();\nconst router = curi(history, routes);\n\nif (module.hot) {\n  module.hot.accept("./routes.js", function() {\n    const nextRoutes = require("./routes").default;\n    router.refresh(nextRoutes);\n  });\n}'),o.a.createElement(u.b,null,o.a.createElement(i.a,null,o.a.createElement("p",null,'This approach does not automatically work with code splitting because the "main" module cannot be hot reloaded. Using a single bundle in development is one way to fix that.'),o.a.createElement("p",null,"If you are using code splitting (importing module with"," ",o.a.createElement(l.b,null,"import()"),") and compiling with Babel using the"," ",o.a.createElement(l.b,null,"@babel/plugin-syntax-dynamic-import")," plugin, you will want to use the ",o.a.createElement(l.b,null,"dynamic-import-node")," in development instead. This will produce a single bundle (no actual code splitting), so it should only be used in development."))),o.a.createElement(u.a,null,'// .babelrc.js\n\n// you will need to set the NODE_ENV to "production"\n// for your production build\nconst __DEV__ = process.env.NODE_ENV !== "production";\n\nmodule.exports = {\n  plugins: [\n    __DEV__\n      ? "dynamic-import-node"\n      : "@babel/plugin-syntax-dynamic-import"\n  ]\n};')))}}}]);