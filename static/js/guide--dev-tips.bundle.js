(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{118:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return l.default.createElement(l.default.Fragment,null,l.default.createElement(i.Section,{title:"Hot Module Replacement",id:"hmr"},l.default.createElement(r.Explanation,null,l.default.createElement("p",null,"Hot module replacement (HMR) can make development more convenient by automatically updating page content without refreshing the page. With Webpack, there are only a few steps required to get this working with Curi."),l.default.createElement("p",null,"The first step is to get your Webpack configuration setup for hot module replacement. Webpack's"," ",l.default.createElement("a",{href:"https://webpack.js.org/guides/hot-module-replacement/"},"hot module replacement guide")," ","is a good resource to learn how to do this.")),l.default.createElement(r.Explanation,null,l.default.createElement("p",null,"The next step is identifying what file(s) you want to watch. A watched file will be notified when it, any of its dependencies, or any dependencies depndencies (and so on down the line) are updated. The best way to do this with a Curi application is to watch the file where your routes are defined."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineJS,null,"router")," has a ",l.default.createElement(o.InlineJS,null,"refresh()")," method that is used for providing new routes to the router. When it is called, it will also generate and emit a new response."),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"module.hot.accept()")," is used for watching a file and calling a callback when that files or any files in its dependency chain are updated. In the callback, we can re-import the routes and pass them to the router's ",l.default.createElement(o.InlineJS,null,"refresh()")," method. This will in turn emit a new response, which will automatically be rendered."),l.default.createElement("p",null,"With that, your application should be setup to support hot module replacement.")),l.default.createElement(r.CodeBlock,{"data-line":"9-14"},'// index.js\nimport { curi } from "@curi/core";\nimport Browser from "@hickory/browser";\nimport routes from "./routes";\n\nconst history = Browser();\nconst router = curi(history, routes);\n\nif (module.hot) {\n  module.hot.accept("./routes.js", function() {\n    const nextRoutes = require("./routes").default;\n    router.refresh(nextRoutes);\n  });\n}'),l.default.createElement(r.Explanation,null,l.default.createElement(a.Note,null,l.default.createElement("p",null,'This approach does not automatically work with code splitting because the "main" module cannot be hot reloaded. Using a single bundle in development is one way to fix that.'),l.default.createElement("p",null,"If you are using code splitting (importing module with"," ",l.default.createElement(o.InlineJS,null,"import()"),") and compiling with Babel using the"," ",l.default.createElement(o.InlineJS,null,"@babel/plugin-syntax-dynamic-import")," plugin, you will want to use the ",l.default.createElement(o.InlineJS,null,"dynamic-import-node")," in development instead. This will produce a single bundle (no actual code splitting), so it should only be used in development."))),l.default.createElement(r.CodeBlock,null,'// .babelrc.js\n\n// you will need to set the NODE_ENV to "production"\n// for your production build\nconst __DEV__ = process.env.NODE_ENV !== "production";\n\nmodule.exports = {\n  plugins: [\n    __DEV__\n      ? "dynamic-import-node"\n      : "@babel/plugin-syntax-dynamic-import"\n  ]\n};')))};var l=function(e){return e&&e.__esModule?e:{default:e}}(n(0)),o=(n(1),n(6)),a=n(11),i=n(10),r=n(7)}}]);