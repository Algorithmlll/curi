(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{120:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return l.default.createElement(l.default.Fragment,null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"React Router v4 isn't like most other routers because it lacks a centralized configuration. Migrating to Curi mostly involves re-centralizing your routes to simplify route management.")),l.default.createElement(u.Section,{title:"Routes",id:"routes"},l.default.createElement("p",null,"Let’s get started with setting up our routes."),l.default.createElement(u.Subsection,{title:"With React Router",id:"routes-with-react-router"},l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"With React Router v4, ",l.default.createElement(o.InlineComponent,null,"Route"),"s are defined in components. They are usually grouped together under a ",l.default.createElement(o.InlineComponent,null,"Switch")," so that only a single route from a group renders. Nested routes are rendered inside of the compnent rendered by the parent"," ",l.default.createElement(o.InlineComponent,null,"Route"))),l.default.createElement(i.CodeBlock,{lang:"jsx"},'import { Route, Switch } from "react-router-dom";\n            \nconst App = () => (\n  <Switch>\n    <Route exact path="/" component={Home} />\n    <Route path="/inbox" component={Inbox} />\n  </Switch>                 \n);\n\n// the <Inbox> matches nested routes (and includes\n// a <Route> for "exact" /inbox matches)\nconst Inbox = ({ match }) => (\n  <Switch>\n    <Route\n      exact\n      path={match.path}\n      component={Messages}\n    />\n    <Route\n      exact\n      path={`${match.path}/:message`}\n      component={Message}\n    />\n  </Switch>\n);')),l.default.createElement(u.Subsection,{title:"With Curi",id:"routes-with-curi"},l.default.createElement(i.Explanation,null,l.default.createElement("p",null,'Routes in Curi are JavaScript objects. They are grouped together in an array of "top-level" routes. Nested routes are grouped under their parent route\'s ',l.default.createElement(o.InlineJS,null,"children")," property."),l.default.createElement("p",null,"First, we will define the names and paths for our routes."),l.default.createElement("p",null,"Each route must have a unique name. A route's name will be used for interacting with it. For example, to navigate to a route, you only have to know its name, not its URL."),l.default.createElement("p",null,"The biggest difference between the Curi paths and the React Router paths is that with Curi, you never include a forward slash at the beginning of the path. This means that while the root path for React Router is ",l.default.createElement(o.InlineJS,null,"'/'"),", the root path for Curi is"," ",l.default.createElement(o.InlineJS,null,"''"),".")),l.default.createElement(i.CodeBlock,null,"const routes = [\n  {\n    name: 'Home',\n    path: ''\n  },\n  {\n    name: 'Inbox',\n    path: 'inbox',\n    children: [\n      {\n        name: 'Message',\n        path: ':message'\n      }\n    ]\n  }\n];"),l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Next, we should add our components to each route."),l.default.createElement("p",null,"Curi routes can have a ",l.default.createElement(o.InlineJS,null,"response()")," property, which is a function that returns an object of properties to merge onto the response that we will be using to render. For this React application, we want a response's ",l.default.createElement(o.InlineJS,null,"body")," property to be the React component associated with each route.")),l.default.createElement(i.CodeBlock,null,"import Home from './pages/Home';\nimport Inbox from './pages/Inbox';\nimport Mesage from './pages/Message';\n\nconst routes = [\n  {\n    name: 'Home',\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    name: 'Inbox',\n    path: 'inbox',\n    response: () => {\n      return {\n        body: Inbox\n      };\n    },\n    children: [\n      {\n        name: 'Message',\n        path: ':message',\n        response: () => {\n          return {\n            body: Message\n          };\n        }\n      }\n    ]\n  }\n];"),l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"With React Router v4, a component's lifecycle methods are used for loading data, code splitting, and other non-rendering tasks. With Curi, routes can have functions that are called when they match the new location. These are grouped under the route's"," ",l.default.createElement(o.InlineJS,null,"resolve")," object. The ",l.default.createElement(o.InlineJS,null,"resolve")," functions are called every time that a route matches a location."),l.default.createElement("p",null,"The"," ",l.default.createElement(a.Link,{to:"Package",params:{package:"router"},hash:"route-properties"},l.default.createElement(o.InlineJS,null,"@curi/router")," route API documentation")," ","covers all of the route properties.")),l.default.createElement(i.CodeBlock,null,"const routes = [\n  {\n    path: '',\n    response: () => {\n      return {\n        body: Home\n      };\n    }\n  },\n  {\n    path: 'inbox',\n    response: () => {\n      return {\n        body: Inbox\n      };\n    },\n    children: [\n      {\n        path: ':message',\n        response: () => {\n          return {\n            body: Message\n          };\n        },\n        resolve: {\n          body: (route) => { return ... },\n        }\n      }\n    ]\n  }\n];")),l.default.createElement("p",null,"Once your routes have been defined, you can move on to creating your Curi router.")),l.default.createElement(u.Section,{title:"Creating the router",id:"creating-the-router"},l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"With React Router, you create your router by rendering a"," ",l.default.createElement(o.InlineComponent,null,"Router")," component. This may be a ",l.default.createElement(o.InlineComponent,null,"BrowserRouter"),", a ",l.default.createElement(o.InlineComponent,null,"HashRouter"),", a ",l.default.createElement(o.InlineComponent,null,"MemoryRouter"),", or a plain"," ",l.default.createElement(o.InlineComponent,null,"Router")," that you pass your own ",l.default.createElement(o.InlineJS,null,"history")," instance to. The ",l.default.createElement(o.InlineComponent,null,"___Router")," components create a ",l.default.createElement(o.InlineJS,null,"history")," ","instance for you using props passed to the component.")),l.default.createElement(i.CodeBlock,{lang:"jsx"},"import { BrowserRouter } from 'react-router-dom';\n\nReactDOM.render((\n  <BrowserRouter>\n    <App />\n  </BrowserRouter>\n), holder);"),l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"With Curi, the router is created prior to rendering. It takes a Hickory history object, your routes array, and possibly an options object. ",l.default.createElement("a",{href:"https://github.com/pshrmn/hickory"},"Hickory")," is similar to the ",l.default.createElement(o.InlineJS,null,"history")," package used by React Router, but has a slight modified API (easier navigation blocking and navigation that imitates how anchors work) and more convenient location objects (you can use a ",l.default.createElement(o.InlineJS,null,"query")," object instead of having to manually create a ",l.default.createElement(o.InlineJS,null,"search")," string).")),l.default.createElement(i.CodeBlock,null,"import { curi } from '@curi/router';\nimport Browser from '@hickory/browser';\nconst history = Browser();\nconst routes = [...];\nconst router = curi(history, routes);")),l.default.createElement(u.Section,{title:"Rendering",id:"rendering"},l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"We will walk through the rendering differences between React Router and Curi by looking at what happens in each when we navigate to the URL with the pathname ",l.default.createElement(o.InlineJS,null,"/inbox/test-message-please-ignore"),".")),l.default.createElement(u.Subsection,{title:"React Router",id:"rendering-react-router"},l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"React Router matches routes while it renders. It uses the"," ",l.default.createElement(o.InlineComponent,null,"Router")," component to listen for location changes. Each time that the location changes, the application re-renders."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineComponent,null,"Switch")," will iterate over its children"," ",l.default.createElement(o.InlineComponent,null,"Route"),"s. The first route, ",l.default.createElement(o.InlineJS,null,'"/"')," has an"," ",l.default.createElement(o.InlineJS,null,"exact")," prop, so it only matches when the pathname is"," ",l.default.createElement(o.InlineJS,null,'"/"'),". Since it is not, the next ",l.default.createElement(o.InlineComponent,null,"Route")," will be checked. The next route, ",l.default.createElement(o.InlineJS,null,'"/inbox"')," matches the beginning of the pathname ",l.default.createElement(o.InlineJS,null,'"/inbox/test-message-please-ignore"'),". It is not an exact match, but that route does not do exact matching, so React Router will render its component, ",l.default.createElement(o.InlineComponent,null,"Inbox"),"."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineComponent,null,"Inbox")," has its own ",l.default.createElement(o.InlineComponent,null,"Switch")," to iterate over. Its first route only matches ",l.default.createElement(o.InlineJS,null,'"/inbox"')," exactly, so it moves on to the next route, which has a ",l.default.createElement(o.InlineJS,null,"message")," ","route param. This route matches and stores"," ",l.default.createElement(o.InlineJS,null,'"test-message-please-ignore"')," as"," ",l.default.createElement(o.InlineJS,null,"match.params.message"),". The ",l.default.createElement(o.InlineComponent,null,"Message")," component will then be rendered, which has access to the ",l.default.createElement(o.InlineJS,null,"message")," ","param.")),l.default.createElement(i.CodeBlock,{lang:"jsx"},'ReactDOM.render((\n  <BrowserRouter>\n    <App />\n  </BrowserRouter>\n), holder);\n\nconst App = () => (\n  <Switch>\n    <Route exact path="/" component={Home} />\n    <Route path="/inbox" component={Inbox} />\n  </Switch>                 \n);\n\nconst Inbox = ({ match }) => (\n  <Switch>\n    <Route\n      exact\n      path={match.path}\n      component={Messages}\n    />\n    <Route\n      exact\n      path={`${match.path}/:message`}\n      component={Message}\n    />\n  </Switch>\n);\n\n/*\n<BrowserRouter>\n  <App>\n    <Inbox>\n      <Message>\n    </Inbox>\n  </App>\n</BrowserRouter>\n*/')),l.default.createElement(u.Subsection,{title:"Curi",id:"rendering-with-curi"},l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"With Curi, we also need to re-render our application every time that the location changes. We will do this by creating a root Curi component by calling the ",l.default.createElement(o.InlineJS,null,"curiProvider()")," function, which comes from the ",l.default.createElement(o.InlineJS,null,"@curi/react-dom")," package, and passing it our Curi router. While the name of this component is entirely up to you, we will refer to it as the ",l.default.createElement(o.InlineComponent,null,"Router")," here."),l.default.createElement("p",null,"The ",l.default.createElement(o.InlineComponent,null,"Router")," will setup an observer on the provided router so that it can re-render your application whenever there is a new ",l.default.createElement(o.InlineJS,null,"response"),". The ",l.default.createElement(o.InlineComponent,null,"Router")," expects a function as its ",l.default.createElement(o.InlineJS,null,"children")," prop (a render-invoked function). This function renders the application using the"," ",l.default.createElement(o.InlineJS,null,"response"),"."),l.default.createElement("p",null,"When the ",l.default.createElement(o.InlineComponent,null,"Router"),"'s ",l.default.createElement(o.InlineJS,null,"children()")," function is called, it will receive an object with three properties:"),l.default.createElement("ol",null,l.default.createElement("li",null,l.default.createElement(o.InlineJS,null,"response")," is the new response object"),l.default.createElement("li",null,l.default.createElement(o.InlineJS,null,"navigation")," is an object with additional information about the navigation"),l.default.createElement("li",null,l.default.createElement(o.InlineJS,null,"router")," is your Curi router (mostly useful if the function is defined in a separate file)")),l.default.createElement("p",null,"Above, we added ",l.default.createElement(o.InlineJS,null,"response()")," functions to each route. The functions set React components as the ",l.default.createElement(o.InlineJS,null,"body")," property of responses. We can now use ",l.default.createElement(o.InlineJS,null,"response.body")," to render those components."),l.default.createElement("p",null,"In the React Router section, we had three components that were rendered: ",l.default.createElement(o.InlineComponent,null,"App"),",",l.default.createElement(o.InlineComponent,null,"Inbox"),", and ",l.default.createElement(o.InlineComponent,null,"Message"),". With Curi, only the most accurately matched route actually matches. That means that for the URL ",l.default.createElement(o.InlineJS,null,"/inbox/test-message-please-ignore"),", the"," ",l.default.createElement(o.InlineJS,null,'"Message"')," route will match, but its parent route,"," ",l.default.createElement(o.InlineJS,null,'"Inbox"')," will not, so ",l.default.createElement(o.InlineJS,null,"response.body")," will be the ",l.default.createElement(o.InlineComponent,null,"Message")," component. Unlike React Router, we don’t render ",l.default.createElement(o.InlineComponent,null,"Inbox")," because we did not match the"," ",l.default.createElement(o.InlineJS,null,"inbox")," route.")),l.default.createElement(i.CodeBlock,{lang:"jsx"},'import { curiProvider } from "@curi/react-dom";\n\nconst router = curi(history, routes);            \nconst Router = curiProvider(router);\n\nReactDOM.render((\n  <Router>\n    {({ response }) => {\n      const { body:Body } = response;\n      return <Body />;\n    }}\n  </Router>\n), holder);\n\n/*\n  <Router>\n    <Message />\n  </Router>\n*/'),l.default.createElement(i.Explanation,null,l.default.createElement(r.Note,null,"Wildcard routes (",l.default.createElement(o.InlineJS,null,"{ path: '(.*)' }"),") can be used to easily display a not found page for any location not matched by other routes.")),l.default.createElement(i.CodeBlock,null,'const routes = [\n  // ...,\n  {\n    name: "Not Found",\n    path: "(.*)",\n    response() {\n      return { body: NotFound };\n    }\n  }\n];'),l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"It was mentioned above that there is no need for the"," ",l.default.createElement(o.InlineComponent,null,"App")," component with Curi. If you want to have an"," ",l.default.createElement(o.InlineComponent,null,"App")," component, you can render it either inside of the"," ",l.default.createElement(o.InlineJS,null,"children()")," function or as a parent of your"," ",l.default.createElement(o.InlineComponent,null,"Router"),". This can be useful for rendering content that is unrelated to specific routes, like a page header or menu."),l.default.createElement("p",null,"Rendering the ",l.default.createElement(o.InlineComponent,null,"App")," inside of the ",l.default.createElement(o.InlineJS,null,"children()")," ","function is necessary if any of the components rendered by the"," ",l.default.createElement(o.InlineComponent,null,"App")," are location aware components, since they need to access the Curi router (through React’s context, which the"," ",l.default.createElement(o.InlineComponent,null,"Router")," provides)")),l.default.createElement(i.CodeBlock,{lang:"jsx"},"function render({ response }) {\n  const { body:Body } = response;\n  return (\n    <App>\n      <Body />\n    </App>\n  );\n}\n// or\nfunction render({ response }) {\n  const { body:Body } = response;\n  return (\n    <div>\n      <Header />\n      <Body />\n      <Footer />\n    </div>\n  );\n}"),l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"What about props that you want to send to your route components? Pass them to the ",l.default.createElement(o.InlineComponent,null,"Body")," component that you render. Props can be passed individually, but passing the whole"," ",l.default.createElement(o.InlineJS,null,"response")," object is recommended.")),l.default.createElement(i.CodeBlock,{lang:"jsx"},"function render({ response }) {\n  const { body:Body } = response;\n  return <Body response={response} />;\n}"))),l.default.createElement(u.Section,{title:"Links",id:"links"},l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"You will want to be able to navigate between routes in your application. React Router provides a ",l.default.createElement(o.InlineComponent,null,"Link")," component to do this, and so does Curi (through the ",l.default.createElement(o.InlineJS,null,"@curi/react-dom")," ","package). There are a few differences to note between these two components:")),l.default.createElement("ul",null,l.default.createElement("li",null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"React Router expects you to generate the pathname yourself, while Curi expects you to pass the name of the route that you want to navigate to. Any path parameters are passed to Curi’s"," ",l.default.createElement(o.InlineComponent,null,"Link")," using the ",l.default.createElement(o.InlineJS,null,"params")," prop.")),l.default.createElement(i.CodeBlock,{lang:"jsx"},"// React Router\n<Link to='/'>Home</Link>\n<Link to={`/inbox/${message}`}>Hello</Link>\n\n// Curi\n<Link to='Home'>Home</Link>\n<Link to='Message' params={{ message }}>Hello</Link>")),l.default.createElement("li",null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"With React Router, any additional location properties are passed to the ",l.default.createElement(o.InlineComponent,null,"Link")," using the ",l.default.createElement(o.InlineJS,null,"to")," object. With Curi, these properties are passed using the prop name (",l.default.createElement(o.InlineJS,null,"hash"),", ",l.default.createElement(o.InlineJS,null,"query")," &",l.default.createElement(o.InlineJS,null,"state"),").")),l.default.createElement(i.CodeBlock,{lang:"jsx"},"// React Router\n<Link to={{ pathname: '/inbox', hash: '#test' }}>\n  Inbox\n</Link>\n\n// Curi\n<Link to='Inbox' hash='test'>Inbox</Link>")),l.default.createElement("li",null,l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"Active detection with Curi uses an ",l.default.createElement(o.InlineComponent,null,"Active")," component."," ",l.default.createElement(o.InlineComponent,null,"Active"),"'s ",l.default.createElement(o.InlineJS,null,"children")," prop is a render-invoked function that receives a boolean ",l.default.createElement(o.InlineJS,null,"true")," when the named route is active and ",l.default.createElement(o.InlineJS,null,"false")," when it is not. You can also pass ",l.default.createElement(o.InlineJS,null,"partial={true}")," to partial matches (ancestor routes) be considered active (the opposite of React Router's ",l.default.createElement(o.InlineJS,null,"onlyActiveOnIndex"),").")),l.default.createElement(i.CodeBlock,{lang:"jsx"},"// React Router\n<Link\n  to='/'\n  onlyActiveOnIndex\n  activeClassName='active'\n>\n  Home\n</Link>\n\n// Curi\n// You need to add @curi/route-active\n// to your router object\nimport active from '@curi/route-active';\nconst router = curi(history, routes, {\n  route: [active()]\n});\n\n// The <Active> component determines if a route is active\n// and passes true/false to the render-invoked children\n// function\n<Active name=\"Home\">\n  {active => (\n    <Link\n      to='Home'\n      className={active ? \"active\" : \"\"}\n    >Home</Link>\n  )}\n</Active>")))),l.default.createElement(u.Section,{title:"Accessing router props from nested components",id:"router-props"},l.default.createElement(i.Explanation,null,l.default.createElement("p",null,"React Router provides a ",l.default.createElement(o.InlineJS,null,"withRouter")," higher-order component that will inject router props into the wrapped component."),l.default.createElement("p",null,"Curi provides similar functionality with the ",l.default.createElement(o.InlineJS,null,"Curious")," ","component."),l.default.createElement("p",null,l.default.createElement(o.InlineJS,null,"Curious")," has a render-invoked ",l.default.createElement(o.InlineJS,null,"children")," ","function, which you can use to inject the Curi ",l.default.createElement(o.InlineJS,null,"router"),", the current ",l.default.createElement(o.InlineJS,null,"response"),", and the current"," ",l.default.createElement(o.InlineJS,null,"navigation")," object into components.")),l.default.createElement(i.CodeBlock,null,"// React Router\nexport default withRouter(SomeComponent);\n\n// Curi\nexport default () => (\n  <Curious>\n    {({ response }) => (\n      <SomeComponent response={response} />\n    )}\n  </Curious>\n);")),l.default.createElement("p",null,"At this point, hopefully you are comfortable with migrating from React Router v4 to Curi. If there are any concepts not covered here that you think should be, please feel free to open up an issue"," ",l.default.createElement("a",{href:"https://github.com/pshrmn/curi/issues"},"on GitHub"),"."))};var l=function(e){return e&&e.__esModule?e:{default:e}}(n(0)),a=n(1),o=n(6),r=n(11),u=n(10),i=n(7)}}]);