webpackJsonp([2],{54:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),o=a(n(65)),r=function(e){var t=e.params,n=o.default[t.name];return n?l.default.createElement(n,null):l.default.createElement("div",null,"The requested tutorial could not be found.")};t.default=r},58:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var a=function(e){return e&&e.__esModule?e:{default:e}}(n(0)),l=function(e){var t=e.id;return a.default.createElement("div",{className:"demo"},a.default.createElement("iframe",{src:"https://codesandbox.io/embed/".concat(t),width:"100%",height:"600px",sandbox:"allow-modals allow-forms allow-popups allow-scripts allow-same-origin"}),a.default.createElement("p",null,"Use the three buttons at the top of the Sandbox to toggle view modes. Clicking the menu button in the top left corner opens a menu that allows you to switch between files."))},o=l;t.default=o},60:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),o=a(n(16)),r=function(e){var t=e.children;return l.default.createElement("div",{className:"tutorial"},l.default.createElement("div",{className:"content"},t||null),l.default.createElement("div",{className:"sidebar"},l.default.createElement("h2",null,"Tutorials"),l.default.createElement(o.default,null)))};t.default=r},64:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Outline=t.CompleteBranch=t.TutorialBranches=t.TutorialBranch=void 0;var a=function(e){return e&&e.__esModule?e:{default:e}}(n(0)),l=n(2),o=function(e){var t=e.name;return a.default.createElement("div",{className:"tutorial-branch"},a.default.createElement("p",null,"If you are following along using the"," ",a.default.createElement("a",{href:"https://github.com/pshrmn/curi-tutorial"},"tutorial repo"),", please checkout the ",a.default.createElement(l.InlineJS,null,t)," branch."),a.default.createElement(l.PrismBlock,{lang:"bash"},"git checkout ".concat(t)))};t.TutorialBranch=o;var r=function(e){var t=e.names;return a.default.createElement("div",{className:"tutorial-branch"},a.default.createElement("p",null,"If you are following along using the"," ",a.default.createElement("a",{href:"https://github.com/pshrmn/curi-tutorial"},"tutorial repo"),", please checkout the appropriate branch for your rendering framework."),a.default.createElement(l.PrismBlock,{lang:"bash"},t.map(function(e){return"git checkout ".concat(e)}).join("\n")))};t.TutorialBranches=r;var i=function(e){var t=e.name;return a.default.createElement("div",{className:"tutorial-branch"},a.default.createElement("p",null,"You can view the completed source code for this tutorial"," ",a.default.createElement("a",{href:"https://github.com/pshrmn/curi-tutorial/tree/".concat(t)},"on GitHub"),"."))};t.CompleteBranch=i;var u=function(e){var t=e.children;return a.default.createElement("div",{className:"tutorial-outline"},a.default.createElement("p",null,"In this tutorial, we will be doing the following:"),t)};t.Outline=u},65:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(66)),o=a(n(67)),r=a(n(68)),i=a(n(69)),u=a(n(70)),s=a(n(71)),c=a(n(72)),d=a(n(73)),m=a(n(74)),h=a(n(75)),p=a(n(76)),f=a(n(77)),b={"01-setup":l.default,"02-routes":o.default,"03-hickory":r.default,"04-router":i.default,"05-pages-react":u.default,"05-pages-vue":s.default,"06-loading-data":c.default,"07-render-data-react":d.default,"07-render-data-vue":m.default,"08-nav-react":h.default,"08-nav-vue":p.default,"09-now-what":f.default};t.default=b},66:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),o=n(1),r=a(n(60)),i=n(64),u=n(2),s=n(9),c=n(8),d=function(){return l.default.createElement(r.default,null,l.default.createElement("h1",null,"Part 1: Setting up Curi"),l.default.createElement("p",null,"Setup is never exciting, but a little bit of it is necessary."),l.default.createElement(i.Outline,null,l.default.createElement("ul",null,l.default.createElement("li",null,"Initializing our project and installing the packages (from NPM) that are necessary to get started."),l.default.createElement("li",null,"Creating directories for our source and public files, as well as adding some empty files for future use."),l.default.createElement("li",null,"Setting up a simple Express server to serve our website contents."),l.default.createElement("li",null,"Setting up Babel/Webpack."))),l.default.createElement(i.TutorialBranch,{name:"01-setup"}),l.default.createElement(c.Section,{title:"The Basics",id:"basics"},l.default.createElement("p",null,"In the terminal, navigate to the parent directory where you want to keep the code for your website and create a new directory for the website. We can then navigate into our new directory."),l.default.createElement(u.PrismBlock,{lang:"bash"},"# if you're using the tutorial repo, you should skip\n# this because you'll be using the repo folder\nmkdir curi-bookstore\ncd curi-bookstore"),l.default.createElement("p",null,"Inside of the directory, run ",l.default.createElement(u.InlineJS,null,"npm init")," to generate a"," ",l.default.createElement(u.InlineJS,null,"package.json")," file. Then, we can install the most important package for Curi: ",l.default.createElement(u.InlineJS,null,"@curi/core"),". We should also install"," ",l.default.createElement(u.InlineJS,null,"@hickory/browser"),", which we'll cover later on."),l.default.createElement(u.PrismBlock,{lang:"bash"},"npm init\nnpm install @curi/core @hickory/browser")),l.default.createElement(c.Section,{title:"File Structure",id:"structure"},l.default.createElement("p",null,"We should also get some of the directories/files for our website setup. You can restructure your application however you want, but the approach used in this project can serve as a good starting point."),l.default.createElement(u.PrismBlock,{lang:"bash"},"mkdir src\ntouch src/index.js src/routes.js\nmkdir -p public/js\ntouch public/index.html"),l.default.createElement("p",null,"The above commands will leave us with the following project structure:"),l.default.createElement(u.PrismBlock,null,"curi-bookstore/\n+- src/\n|  +- index.js\n|  +- routes.js\n+- public/\n|  +- index.html\n|  +- js/\n+- package.json")),l.default.createElement(c.Section,{title:"Building the Site",id:"building"},l.default.createElement("p",null,"We will be using Babel/Webpack to build our project. We won't be diving into the details of how these work, but will provide the code necessary to get this setup."),l.default.createElement("p",null,"We can start by installing the necessary packages as well as adding configuration files for both Babel and Webpack. We will be using Babel 7, so we can use a JavaScript file instead of JSON for our Babel router."),l.default.createElement("p",null,"We will also be using ",l.default.createElement(u.InlineJS,null,"webpack-dev-server")," in place of setting up a server. This allows us to have live reloading in development."),l.default.createElement(u.PrismBlock,{lang:"bash"},"touch .babelrc.js webpack.router.js\nnpm install -D webpack webpack-dev-server @babel/core\n  @babel/preset-env babel-loader@next"),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// .babelrc.js\nmodule.exports = {\n  presets: [\n    ['@babel/env',{\n      modules: false\n    }]\n  ]\n};"),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// webpack.router.js\nconst path = require('path');\n\nconst router = {\n  context: path.resolve(__dirname, 'src'),\n  entry: './index.js',\n  output: {\n    path: path.resolve(__dirname, 'public'),\n    filename: 'js/bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /.js$/,\n        use: 'babel-loader'\n      }\n    ]\n  },\n  devServer: {\n    contentBase: path.resolve(__dirname, 'public'),\n    historyApiFallback: true\n  }\n}\n\nmodule.exports = router;"),l.default.createElement("p",null,"We also need to create the ",l.default.createElement(u.InlineJS,null,"index.html")," file. This just needs to include the DOM element that we will render our application in and a"," ",l.default.createElement(u.InlineComponent,null,"script")," that loads our bundled application. You can copy the code below into your ",l.default.createElement(u.InlineJS,null,"public/index.html")," file."),l.default.createElement(u.PrismBlock,{lang:"html"},'// public/index.html\n           <!doctype html>\n<html>\n  <head>\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n  </head>\n  <body>\n    <div id="root"></div>\n    <script src="/js/bundle.js"><\/script>\n  </body>\n</html>'),l.default.createElement("p",null,"Finally, we just need to add a script to our ",l.default.createElement(u.InlineJS,null,"package.json")," ","file in order to build our bundle."),l.default.createElement(u.PrismBlock,{lang:"javascript"},'// package.json\n{\n  // ...,\n  "scripts": {\n    "dev": "webpack-dev-server"\n  }\n}'),l.default.createElement(s.Note,null,"If you're building this from scratch, you should also add a"," ",l.default.createElement(u.InlineJS,null,".gitignore")," file and ignore the ",l.default.createElement(u.InlineJS,null,"node_modules/")," ","directory.")),l.default.createElement(c.Section,{title:"Review",id:"review"},l.default.createElement(i.CompleteBranch,{name:"02-routes"})),l.default.createElement(c.Section,{title:"Next",id:"next"},l.default.createElement("p",null,"With our project setup, we are now ready to continue the tutorial with"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"02-routes"}},"Part 2: Routes"),".")))};t.default=d},67:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),o=n(1),r=a(n(60)),i=n(64),u=n(2),s=n(9),c=n(8),d=function(){return l.default.createElement(r.default,null,l.default.createElement("h1",null,"Part 2: Curi Routes"),l.default.createElement("p",null,"Now that we have our project setup, it is time to start thinking about the route structure of our website."),l.default.createElement(i.Outline,null,l.default.createElement("ul",null,l.default.createElement("li",null,"Deciding what pages our website will contain."),l.default.createElement("li",null,"Learning about basic route properties."),l.default.createElement("li",null,"Creating route objects for each of our website's pages."))),l.default.createElement(i.TutorialBranch,{name:"02-routes"}),l.default.createElement(c.Section,{title:"Pages",id:"pages"},l.default.createElement("p",null,"We should start by identifying the pages that we want to have in our website. This can always be modified later, but it is a good idea to know what pages you are going to need to create."),l.default.createElement("p",null,"For this website, we will be creating the following pages:"),l.default.createElement("ol",null,l.default.createElement("li",null,"Home - the landing page for the website"),l.default.createElement("li",null,"Contact - a listing of how to contact the site's creators"),l.default.createElement("li",null,"Book list - a list of all of the books available for purchase"),l.default.createElement("li",null,"Book - a page for each book"),l.default.createElement("li",null,'Checkout - a page to "buy" books that have been added to the shopping cart')),l.default.createElement("p",null,"Additionally, we should have a 404 page that is displayed when the user visits a location that has no matching route."),l.default.createElement("p",null,"Each page in our website must have a pathname associated with it. These may either be static (literal) or dynamic (include parts that change, like IDs)."),l.default.createElement("ol",null,l.default.createElement("li",null,"Home - ",l.default.createElement(u.InlineJS,null,"/")),l.default.createElement("li",null,"Contact - ",l.default.createElement(u.InlineJS,null,"/contact")),l.default.createElement("li",null,"Book list - ",l.default.createElement(u.InlineJS,null,"/books")),l.default.createElement("li",null,"Book - ",l.default.createElement(u.InlineJS,null,"/books/<book id>")," e.g. ",l.default.createElement(u.InlineJS,null,"/books/2468")),l.default.createElement("li",null,"Checkout - ",l.default.createElement(u.InlineJS,null,"/checkout")))),l.default.createElement(c.Section,{title:"Routes",id:"routes"},l.default.createElement("p",null,"At their core, routes are a way to describe the valid pathnames for our website. With Curi, routes are simply JavaScript objects with some known properties. The two most important properties of a route object are"," ",l.default.createElement(u.InlineJS,null,"name")," and ",l.default.createElement(u.InlineJS,null,"path"),". The ",l.default.createElement(u.InlineJS,null,"name")," is a"," ",l.default.createElement("strong",null,"unique")," string that you will use to identify a particular route. The ",l.default.createElement(u.InlineJS,null,"path")," is a"," ",l.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp"},l.default.createElement(u.InlineJS,null,"path-to-regexp"))," ","formatted string."),l.default.createElement(s.Note,null,l.default.createElement(u.InlineJS,null,"path-to-regexp")," provides pathname matching. You give it a path string (possibly with special formatting) and it returns a regular expression that can be used for matching routes. The regular expression matching will be handled internally by Curi, so you only have to care about formatting path strings. Further along in this tutorial, we will cover the basics of how to do this. However, for advanced usage, you should check out the documention in the"," ",l.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp"},l.default.createElement(u.InlineJS,null,"path-to-regexp"))," ","GitHub repo."),l.default.createElement("p",null,"All of the base routes of our application should be placed in an array. Nested routes will be defined using a property of their parent route."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/routes.js\n        const routes = [];"),l.default.createElement("p",null,"The first route that we will define is for our homepage. We can name it anything we want, but we'll just call it \"Home\". For the home page's"," ",l.default.createElement(u.InlineJS,null,"path"),", we will use an empty string (",l.default.createElement(u.InlineJS,null,"''"),")."),l.default.createElement("p",null,'Up above, we said that the pathname for our "Home" route is ',l.default.createElement(u.InlineJS,null,"/"),". However, with Curi, ",l.default.createElement(u.InlineJS,null,"path")," strings never begin with a forward slash. For all of the pathnames for pages that are listed above, we just need to strip off the leading slash."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"const routes = [\n  { name: 'Home', path: '' }\n];"),l.default.createElement("p",null,'That is simple enough, yes? Let\'s go ahead and add our "Contact" and "Checkout" routes. They should look just like our "Home" route.'),l.default.createElement(u.PrismBlock,{lang:"javascript"},"const routes = [\n  { name: 'Home', path: '' },\n  { name: 'Contact', path: 'contact' },\n  { name: 'Checkout', path: 'checkout' }\n];"),l.default.createElement("p",null,"Now, if a user visits"," ",l.default.createElement(u.InlineJS,null,"https://<our website domain>/checkout"),", our checkout page will match (and likewise for ",l.default.createElement(u.InlineJS,null,"/contact")," and our contact page)."),l.default.createElement("p",null,"We still have more routes to define, but there are two concepts to introduce first: path params and the ",l.default.createElement(u.InlineJS,null,"children")," property of route objects."),l.default.createElement(c.Subsection,{title:"Path Params",id:"path-params",type:"aside"},l.default.createElement("p",null,"With ",l.default.createElement(u.InlineJS,null,"path-to-regexp"),", when you create a path string, it is normally interpreted literally. That means that the the path"," ",l.default.createElement(u.InlineJS,null,"'products/hat'")," will only match the location whose pathname is ",l.default.createElement(u.InlineJS,null,"/products/hat"),". What if we also have a shirt? And socks? And shorts? Do you want to define a path for each individual product? Of course not. Instead, ",l.default.createElement(u.InlineJS,null,"path-to-regexp"),' allows us to define dynamic parts of pathnames using "params".'),l.default.createElement("p",null,"What is a param? It is a way to tell ",l.default.createElement(u.InlineJS,null,"path-to-regexp")," to capture part of the pathname at a particular point and store its value using the param's name. The param starts with a colon and then specifies the param's name."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"{ path: 'product/:name' }"),l.default.createElement("p",null,"Using the above path, we will capture the portion of the pathname that comes after ",l.default.createElement(u.InlineJS,null,"product/"),' and store it in an object using the key "name". When you visit ',l.default.createElement(u.InlineJS,null,"'/products/hat'"),","," ",l.default.createElement(u.InlineJS,null,"path-to-regexp")," will match and return the params object"," ",l.default.createElement(u.InlineJS,null,"{ name: 'hat' }"),". Likewise, ",l.default.createElement(u.InlineJS,null,"'/products/shirt'")," ","and ",l.default.createElement(u.InlineJS,null,"'/products/shorts'"),' will capture "shirt" and "shorts" as the name param.'),l.default.createElement("p",null,"By default, a param will match all characters up until the next forward slash or the end of the string. You can also perform more specific matching, but that is outside of the scope of this tutorial.")),l.default.createElement(c.Subsection,{title:"Route Children",id:"children",type:"aside"},l.default.createElement("p",null,"Sometimes, you will have routes whose ",l.default.createElement(u.InlineJS,null,"path")," extends the path of another route. For example, you might have a route whose path is"," ",l.default.createElement(u.InlineJS,null,"'parent'")," and a child route with the path"," ",l.default.createElement(u.InlineJS,null,"'parent/child'"),"."),l.default.createElement("p",null,"Using the ",l.default.createElement(u.InlineJS,null,"children")," property of route objects, you can attach an array of child routes to a parent route. The ",l.default.createElement(u.InlineJS,null,"path")," ","of each child route will extend the parent route's ",l.default.createElement(u.InlineJS,null,"path"),". That means that using the parent/child paths from above, we can define the parent route to have the path ",l.default.createElement(u.InlineJS,null,"'parent'")," and a child route whose path is ",l.default.createElement(u.InlineJS,null,"'child'"),". Curi will treat that child route as if its path is ",l.default.createElement(u.InlineJS,null,"'parent/child'"),"."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"{\n  name: 'Parent',\n  path: 'parent',\n  children: [\n    {\n      name: 'Child',\n      path: 'child' // will match the pathname /parent/child\n    }\n  ]\n}")),l.default.createElement("p",null,"Now, we can go ahead and use path params and route children to define our book list/book routes."),l.default.createElement("p",null,"For this tutorial, we will identify books from a pathname using their"," ",l.default.createElement(u.InlineJS,null,"id"),'. We can name this anything we want, but "id" is simple and to the point.'),l.default.createElement(u.PrismBlock,{lang:"javascript"},"const routes = [\n  { name: 'Home', path: '' },\n  { name: 'Contact', path: 'contact' },\n  { name: 'Checkout', path: 'checkout' },\n  {\n    name: 'Book List',\n    path: 'books',\n    children: [\n      {\n        name: 'Book',\n        path: ':id'\n      }\n    ]\n  }\n];"),l.default.createElement(c.Subsection,{title:"route.match",id:"route-match"},l.default.createElement("p",null,"We don't need it quite yet, but we should quickly cover another one of the properties of a route: ",l.default.createElement(u.InlineJS,null,"match"),". The ",l.default.createElement(u.InlineJS,null,"match")," ","property is where we can provide functions that will be called when the route matches. There are three valid functions: ",l.default.createElement(u.InlineJS,null,"initial"),","," ",l.default.createElement(u.InlineJS,null,"every"),", and ",l.default.createElement(u.InlineJS,null,"response"),"."),l.default.createElement("p",null,"We won't be using the ",l.default.createElement(u.InlineJS,null,"initial")," function, but you can read more about it in the"," ",l.default.createElement(o.Link,{to:"Guide",params:{slug:"code-splitting"}},"Code Splitting")," ","guide. The ",l.default.createElement(u.InlineJS,null,"every")," function will be used later on, but for now, we only care about the ",l.default.createElement(u.InlineJS,null,"response")," function."),l.default.createElement("p",null,"The ",l.default.createElement(u.InlineJS,null,"response")," function gives us an opportunity to set some properties on the response object before it is emitted."," ",l.default.createElement(u.InlineJS,null,"response")," receives an object with are a bunch of properties (which you can read about"," ",l.default.createElement(o.Link,{to:"Guide",params:{slug:"routes"},details:{hash:"response"}},"here"),"), but right now we only care about the ",l.default.createElement(u.InlineJS,null,"set")," object."),l.default.createElement("p",null,"The ",l.default.createElement(u.InlineJS,null,"set")," object has functions that can be called to modify the response object. For example, calling ",l.default.createElement(u.InlineJS,null,"set.body('Hi!')")," ","will set the ",l.default.createElement(u.InlineJS,null,"body"),' property of the response to "Hi!". Let\'s go ahead and add ',l.default.createElement(u.InlineJS,null,"match.response")," functions to each of our routes. We don't really have anything to set as the body, so we'll just use the route's name as a placeholder."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    name: 'Home',\n    path: '',\n    match: {\n      response: ({ set }) => {\n        set.body('Home');\n      }\n    }\n  },\n  {\n    name: 'Contact',\n    path: 'contact',\n    match: {\n      response: ({ set }) => {\n        set.body('Contact');\n      }\n    }\n  },\n  {\n    name: 'Checkout',\n    path: 'checkout',\n    match: {\n      response: ({ set }) => {\n        set.body('Checkout');\n      }\n    }\n  },\n  {\n    name: 'Book List',\n    path: 'books',\n    match: {\n      response: ({ set }) => {\n        set.body('Book List');\n      }\n    },\n    children: [\n      {\n        name: 'Book',\n        path: ':id',\n        match: {\n          response: ({ set }) => {\n            set.body('Book');\n          }\n        }\n      }\n    ]\n  }\n];"),l.default.createElement("p",null,"Now, if a user visits the ",l.default.createElement(u.InlineJS,null,"/books")," page, the response object will include a ",l.default.createElement(u.InlineJS,null,"body"),' property whose value is "Book List".')),l.default.createElement(c.Subsection,{title:"Wildcard Routes",id:"wildcard"},l.default.createElement("p",null,"We have one last \"route\" to define. This isn't really a route, just a catch all that we can use to identify locations that we don't have a route defined for. ",l.default.createElement(u.InlineJS,null,"path-to-regexp")," allows us to capture everything using the path string ",l.default.createElement(u.InlineJS,null,"(.*)"),"."),l.default.createElement(s.Note,null,l.default.createElement(u.InlineJS,null,"(.*)")," uses another of the special ",l.default.createElement(u.InlineJS,null,"path-to-regexp")," ","formats. If you provide a regular expression within parentheses,"," ",l.default.createElement(u.InlineJS,null,"path-to-regexp")," will only match content that is matched by the regular expression. This can also be paired with a named path param (e.g. ",l.default.createElement(u.InlineJS,null,":id(\\d{4})"),"), but is not necessary."),l.default.createElement("p",null,"Since the regular expression ",l.default.createElement(u.InlineJS,null,".*")," matches everything, we can use this to match all possible pathnames that someone using the website might navigate to."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"const routes = [\n  // ...,\n  {\n    name: 'Not Found',\n    path: '(.*)',\n    match: {\n      response: ({ set }) => {\n        set.body('Not Found');\n      }\n    }\n  }\n];\n// don't forget to export the routes\nexport default routes;")),l.default.createElement(c.Subsection,{title:"Route Order",id:"order"},l.default.createElement("p",null,"One last thing to note about routes is that their order in the routes array is important. Curi will iterate over them in (depth-first) order. This means that with the above router, Curi will first check if"," ",l.default.createElement(u.InlineJS,null,"''")," matches the pathname, if it does not, it will move on to"," ",l.default.createElement(u.InlineJS,null,"'contact'"),', so on and so forth. If no other routes match, then we know that our "Not Found" route will.'),l.default.createElement("p",null,"Curi will only attempt to match children routes if their parent route (partially) matches the location's pathname. That means that when the pathname is ",l.default.createElement(u.InlineJS,null,"'/somewhere'"),', because our "Book List" route does not match, Curi will not attempt to match our "Book" route.'))),l.default.createElement(c.Section,{title:"Review",id:"review"},l.default.createElement(i.CompleteBranch,{name:"03-hickory"})),l.default.createElement(c.Section,{title:"Next",id:"next"},l.default.createElement("p",null,"Now that our routes are defined, it is time to talk about history in"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"03-hickory"}},"Part 3: Hickory"))))};t.default=d},68:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),o=n(1),r=a(n(60)),i=n(64),u=n(2),s=(n(9),n(8)),c=function(){return l.default.createElement(r.default,null,l.default.createElement("h1",null,"Part 3: Hickory"),l.default.createElement("p",null,"One thing that all modern JavaScript routers have in common is that they use the"," ",l.default.createElement("a",{href:"https://developer.mozilla.org/en-US/docs/Web/API/History_API"},"History API")," ","to perform in-app navigation. Curi uses a package called"," ",l.default.createElement("a",{href:"https://github.com/pshrmn/hickory"},"Hickory"),", which will interact with the History API for us."),l.default.createElement(i.Outline,null,l.default.createElement("ul",null,l.default.createElement("li",null,"Learning about the Hickory package and location objects."),l.default.createElement("li",null,"Creating the Hickory history object for our website."))),l.default.createElement(i.TutorialBranch,{name:"03-hickory"}),l.default.createElement(s.Section,{title:"About Hickory",id:"about"},l.default.createElement("p",null,'Hickory creates "history" objects that allow you to navigate between locations within your application. It interacts with the browser for you so that when you navigate to a new location, the URI in the address bar is also updated. Hickory also detects and updates when you use the browser\'s forward and back buttons.'),l.default.createElement("p",null,"Hickory uses a single-subscriber model so that whenever navigation to a new location happens, the subscribed method will be called. Curi will subscribe to your history object to create new responses whenever the location changes.")),l.default.createElement(s.Section,{title:"Choose your own Hickory",id:"choose"},l.default.createElement("p",null,"Hickory is split into three packages: ",l.default.createElement(u.InlineJS,null,"@hickory/browser"),","," ",l.default.createElement(u.InlineJS,null,"@hickory/hash"),", and ",l.default.createElement(u.InlineJS,null,"@hickory/in-memory"),". You can read about the differences between them and figure out which is right for you in this"," ",l.default.createElement("a",{href:"https://github.com/pshrmn/hickory/blob/master/docs/about/choosing.md"},"Choosing Your History Type")," ","guide."),l.default.createElement("p",null,"We will be using the browser history (",l.default.createElement(u.InlineJS,null,"@hickory/browser"),"). This is because 1. our application will run in the browser and 2. our site is backed by a server that can handle dynamic requests.")),l.default.createElement(s.Section,{title:"Installation",id:"installation"},l.default.createElement("p",null,"If you have following along with these tutorials since the"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"01-setup"}},"setup tutorial"),", then you should already have the ",l.default.createElement(u.InlineJS,null,"@hickory/browser")," ","package installed. If not, you should install it now."),l.default.createElement(u.PrismBlock,{lang:"bash"},"npm install @hickory/browser")),l.default.createElement(s.Section,{title:"Making History",id:"making-history"},l.default.createElement("p",null,"In order to use Hickory in our application, we just need to import it and call the imported function. There are a number of configuration options that you can provide, but we don't need any of those right now. If you want to learn more about those, please check out the"," ",l.default.createElement("a",{href:"https://github.com/pshrmn/hickory/tree/master/docs"},"Hickory documentation"),"."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/index.js\n          import Browser from '@hickory/browser';\nconst history = Browser();")),l.default.createElement(s.Section,{title:"Location",id:"hickory-location",type:"aside"},l.default.createElement("p",null,"Hickory (and Curi in turn) use location objects for navigation and route matching. These are simply JavaScript objects with a few properties to identify a location."),l.default.createElement("p",null,"When you load a page, Hickory will parse the URI to generate a location's ",l.default.createElement(u.InlineJS,null,"pathname"),", ",l.default.createElement(u.InlineJS,null,"query"),", and ",l.default.createElement(u.InlineJS,null,"hash")," ","properties. The pathname property of a location is the only thing that"," ",l.default.createElement(u.InlineJS,null,"path-to-regexp")," uses for matching locations."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// uri = '/products/socks?color=black#description'\n{\n pathname: '/products/socks',\n query: 'color=black',\n hash: 'description',\n key: '1.0',\n rawPathname: '/products/socks'\n}"),l.default.createElement("p",null,"Besides the properties parsed from the URI, locations also have a"," ",l.default.createElement(u.InlineJS,null,"key")," property that can be used to uniquely identify a location, a ",l.default.createElement(u.InlineJS,null,"rawPathname")," property (you probably won't need this, but it is useful when dealing with pathnames that contain encoded characters), and sometimes ",l.default.createElement(u.InlineJS,null,"state")," which is data tied to a location but not part of the URI."),l.default.createElement("p",null,"Hickory actually navigates between locations, not URIs. The only time that Curi/Hickory uses URIs is to set the ",l.default.createElement(u.InlineJS,null,"href")," attribute of anchors and to update the string displayed in the address bar (using the History API)."),l.default.createElement("p",null,"For now, that will cover all that you need to know about Hickory. For basic usage, you should never have to think about it except for creating your history object.")),l.default.createElement(s.Section,{title:"Review",id:"review"},l.default.createElement(i.CompleteBranch,{name:"04-router"})),l.default.createElement(s.Section,{title:"Next",id:"next"},l.default.createElement("p",null,"With both our routes and history object, we are now ready for"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"04-router"}},"Part 4"),", where we will create the core of Curi, our router.")))};t.default=c},69:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),o=n(1),r=a(n(60)),i=n(64),u=n(2),s=(n(9),n(8)),c=function(){return l.default.createElement(r.default,null,l.default.createElement("h1",null,"Part 4: The Curi Router"),l.default.createElement("p",null,"Curi uses a centralized router to handle routing. Essentially, whenever the location changes (and when your application first loads), the router will iterate over your routes to find one that matches the location. Then, it will use that route to generate a response object. This response contains a bunch of properties that are useful for rendering your application."),l.default.createElement(i.Outline,null,l.default.createElement("ul",null,l.default.createElement("li",null,"Creating a Curi router using our routes and history object."),l.default.createElement("li",null,"Learning about some of the properties of the router and how Curi works."))),l.default.createElement(i.TutorialBranch,{name:"04-router"}),l.default.createElement(s.Section,{title:"Installation",id:"installation",type:"aside"},l.default.createElement("p",null,"If you skipped the setup, you should install ",l.default.createElement(u.InlineJS,null,"@curi/core")," now."),l.default.createElement(u.PrismBlock,{lang:"bash"},"npm install @curi/core")),l.default.createElement(s.Section,{title:"Creating our router",id:"create"},l.default.createElement("p",null,l.default.createElement(u.InlineJS,null,"@curi/core")," only has a single, default export, which is a function that will create a router. In this tutorial, we will import it as ",l.default.createElement(u.InlineJS,null,"curi")," (of course, you can name it whatever you like)."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"import curi from '@curi/core';"),l.default.createElement("p",null,l.default.createElement(u.InlineJS,null,"curi")," can take three arguments; the first two arguments are required while the third is not."),l.default.createElement("ol",null,l.default.createElement("li",null,l.default.createElement(u.InlineJS,null,"history")," - The first argument to pass to ",l.default.createElement(u.InlineJS,null,"curi")," is a Hickory history object."),l.default.createElement("li",null,l.default.createElement(u.InlineJS,null,"routes")," - The second argument is an array of route objects."),l.default.createElement("li",null,l.default.createElement(u.InlineJS,null,"options")," - The third argument is an object that contains additional configuration options. We will not be using this object in this tutorial.")),l.default.createElement("p",null,"Using the routes that we defined in the"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"02-routes"}},"Routes Tutorial")," ","and the"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"03-hickory"}},"Hickory history object"),", we are ready to create our router."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/index.js\n          import curi from '@curi/core';\nimport Browser from '@hickory/browser';\n\nimport routes from './routes';\n\nconst history = Browser();\nconst router = curi(history, routes);")),l.default.createElement(s.Section,{title:"Subscriber Model",id:"subscriber",type:"aside"},l.default.createElement("p",null,"In order to let your application know about location changes, Curi uses a subscriber model. Whenever a location change happens, Curi will create a new response and then emit this response to all of its subscribed functions. These subscribed functions are called response handlers since they handle the new respond. Using ",l.default.createElement(u.InlineJS,null,"router.respond"),", we can give Curi a response handler to call when a new response has been created."),l.default.createElement("p",null,"What does a response handler function look like? It can take two arguments. The first will be the ",l.default.createElement(u.InlineJS,null,"response")," object generated for the new location. The second is the ",l.default.createElement(u.InlineJS,null,"navigation")," object, which has properties related to the last navigation (the navigation's"," ",l.default.createElement(u.InlineJS,null,"action")," string and the ",l.default.createElement(u.InlineJS,null,"previous")," response object)."),l.default.createElement(u.PrismBlock,{lang:"javascript"},'function responseLogger(response, navigation) {\n  console.log("RESPONSE:", response);\n  console.log("NAVIGATION", navigation)\n}\nrouter.respond(responseLogger);'),l.default.createElement("p",null,l.default.createElement(u.InlineJS,null,"curi.respond")," will return a function that you can use to stop responding to new responses."),l.default.createElement(u.PrismBlock,{lang:"javascript"},'function responseLogger(response, navigation) {\n  console.log("I will be called for every response until I unsubscribe");\n}\nconst stopResponding = router.respond(responseLogger);\n// any navigation that happens now will be logged\n// ...\nstopResponding();\n// after unsubscribing, any new navigation will not be logged'),l.default.createElement("p",null,'While most response handlers should be subscribers (that is to say, you want them to be called every time a new response is generated), you might sometimes want to only call a response handler once. For example, a response handler might be a "ready" function that you only want called once you know that a response exists. To do that, you can use the second argument to ',l.default.createElement(u.InlineJS,null,"router.respond"),", which is an options object. When the ",l.default.createElement(u.InlineJS,null,"once")," object is ",l.default.createElement(u.InlineJS,null,"true"),", then that response handler will only be called one time."),l.default.createElement(u.PrismBlock,{lang:"javascript"},'function responseLogger(response, navigation) {\n  console.log("I will only be called once");\n}\nrouter.respond(responseLogger, { once: true });')),l.default.createElement(s.Section,{title:"Review",id:"review"},l.default.createElement("p",null,"If you are following the React path:"),l.default.createElement(i.CompleteBranch,{name:"05-pages-react"}),l.default.createElement("p",null,"If you are following the Vue path:"),l.default.createElement(i.CompleteBranch,{name:"05-pages-vue"})),l.default.createElement(s.Section,{title:"Next",id:"next"},l.default.createElement("p",null,"With our router created, we are finally ready to render. Now, we are at a bit of a fork in the road. While most of the tutorials apply to everyone, the next tutorial is framework specific."),l.default.createElement("p",null,"If you are following along using React, continue on to"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"05-pages-react"}},"Part 6: React Pages")),l.default.createElement("p",null,"If you are following along using Vue, you instead you should go to"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"05-pages-vue"}},"Part 6: Vue Pages"))))};t.default=c},70:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),o=n(1),r=a(n(60)),i=n(64),u=n(2),s=n(9),c=n(8),d=a(n(58)),m=function(){return l.default.createElement(r.default,null,l.default.createElement("h1",null,"Part 5: React Pages"),l.default.createElement("p",null,"Now that we have our router ready to go, we can think about what our pages should look like. This tutorial will be rendering our website using React. If you prefer to use Vue, you should check out the"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"05-pages-vue"}},"Part 5: Vue Pages")," ","tutorial."),l.default.createElement(i.Outline,null,l.default.createElement("ul",null,l.default.createElement("li",null,"Modifying our Babel configuration to support React."),l.default.createElement("li",null,"Installing the ",l.default.createElement(u.InlineJS,null,"@curi/react")," package and learning about some of the components it provides (",l.default.createElement(u.InlineComponent,null,"CuriBase")," and ",l.default.createElement(u.InlineComponent,null,"Link"),")."),l.default.createElement("li",null,"Defining the ",l.default.createElement(u.InlineJS,null,"render")," function that will render the contents of the website."),l.default.createElement("li",null,"Creating page components for each of the routes."),l.default.createElement("li",null,"Adding links so that users can navigate between locations in the website."))),l.default.createElement(i.TutorialBranch,{name:"05-pages-react"}),l.default.createElement(c.Section,{title:"Babel",id:"babel"},l.default.createElement("p",null,"Before we dive in, let's make sure that our build scripts can handle React. To do this, we just need to install Babel's React preset and add it to our Babel configuration file."),l.default.createElement(u.PrismBlock,{lang:"bash"},"npm install --save-dev @babel/preset-react"),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// .babelrc.js\nmodule.exports = {\n  presets: [\n    ['@babel/env',{\n      modules: false\n    }],\n    '@babel/react'\n  ]\n};")),l.default.createElement(c.Section,{title:l.default.createElement("span",null,"The ",l.default.createElement(u.InlineJS,null,"@curi/react")," Package"),id:"package"},l.default.createElement("p",null,"The ",l.default.createElement(u.InlineJS,null,"@curi/react")," package provides React components that know how to interact with Curi. For this tutorial, we will only be using two:"," ",l.default.createElement(u.InlineComponent,null,"CuriBase")," and ",l.default.createElement(u.InlineComponent,null,"Link"),". However, there are a number of other ones that you might find useful. You can read more about them in the"," ",l.default.createElement(o.Link,{to:"Package",params:{package:"react"},details:{hash:"API"}},l.default.createElement(u.InlineJS,null,"@curi/react")," documentation"),"."),l.default.createElement(c.Subsection,{title:"Installation",id:"installation"},l.default.createElement("p",null,"Let's start by installing the ",l.default.createElement(u.InlineJS,null,"@curi/react")," package. If you haven't already, you should also install the ",l.default.createElement(u.InlineJS,null,"react")," and"," ",l.default.createElement(u.InlineJS,null,"react-dom")," packages."),l.default.createElement(u.PrismBlock,{lang:"bash"},"npm install @curi/react react react-dom")),l.default.createElement(c.Subsection,{title:l.default.createElement("span",null,"The ",l.default.createElement(u.InlineComponent,null,"CuriBase")," Component"),id:"CuriBase"},l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/index.js\n            import { CuriBase } from '@curi/react';"),l.default.createElement("p",null,"The ",l.default.createElement(u.InlineComponent,null,"CuriBase")," is responsible for rendering the website whenever the location changes. It can take four props:"," ",l.default.createElement(u.InlineJS,null,"response"),", ",l.default.createElement(u.InlineJS,null,"navigation"),",",l.default.createElement(u.InlineJS,null,"router"),", and ",l.default.createElement(u.InlineJS,null,"render"),"."),l.default.createElement("ol",null,l.default.createElement("li",null,l.default.createElement(u.InlineJS,null,"response")," is a Curi response object."),l.default.createElement("li",null,l.default.createElement(u.InlineJS,null,"navigation")," is an object with data about the latest navigation."),l.default.createElement("li",null,l.default.createElement(u.InlineJS,null,"router")," is our Curi router."),l.default.createElement("li",null,l.default.createElement(u.InlineJS,null,"render")," is a function that will be called whenever a new response is emitted (and during the initial render) and returns the React element(s) that make up your website. It will receive three arguments: the new ",l.default.createElement(u.InlineJS,null,"response")," object, the"," ",l.default.createElement(u.InlineJS,null,"navigation")," and the Curi router object. The second two can be useful occasionally, but the ",l.default.createElement(u.InlineJS,null,"response")," is what we really need for rendering.")),l.default.createElement("p",null,"In order to set the ",l.default.createElement(u.InlineJS,null,"response")," prop, we need to subscribe to our Curi router. That will allow us to always have the latest response object."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { CuriBase } from '@curi/react';\n\n// ...\n\nrouter.respond((response, navigation) => {\n  ReactDOM.render((\n    <CuriBase\n      router={router}\n      response={response}\n      navigation={navigation}\n      render={response => {\n        return null;\n      }}\n    />\n  ), document.getElementById('root'));\n});"),l.default.createElement("p",null,"The ",l.default.createElement(u.InlineComponent,null,"CuriBase")," also adds a ",l.default.createElement(u.InlineJS,null,"curi")," object to React's context. This object has ",l.default.createElement(u.InlineJS,null,"router"),", ",l.default.createElement(u.InlineJS,null,"response"),", and"," ",l.default.createElement(u.InlineJS,null,"navigation")," properties. A number of the other components exported by ",l.default.createElement(u.InlineJS,null,"@curi/react")," rely on these variables to render/function."),l.default.createElement("p",null,"The above ",l.default.createElement(u.InlineJS,null,"render")," function isn't very interesting because our application is rendering nothing (",l.default.createElement(u.InlineJS,null,"null"),"). We'll come back to that in a minute, but first we should learn about the other React component that we'll be using.")),l.default.createElement(c.Subsection,{title:l.default.createElement("span",null,"The ",l.default.createElement(u.InlineComponent,null,"Link")," Component"),id:"Link"},l.default.createElement(u.PrismBlock,{lang:"javascript"},"import { Link } from '@curi/react';"),l.default.createElement("p",null,"The ",l.default.createElement(u.InlineComponent,null,"Link")," component renders anchor (",l.default.createElement(u.InlineComponent,null,"a"),") elements. However, unlike an anchor, we don't actually have to write the URI that we want to navigate to (the ",l.default.createElement(u.InlineJS,null,"href"),"). Instead, you use the ",l.default.createElement(u.InlineJS,null,"to")," prop to pass the name of the route that you want to navigate to."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"<Link to='Home'>Home</Link>\n// <a href='/'>Home</a>"),l.default.createElement("p",null,"If the route that you are navigating to has any params, you pass them using the ",l.default.createElement(u.InlineJS,null,"params")," prop."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"{ name: 'Book', path: ':id' }\n// (inherits 'books' path from parent route)\n<Link to='Book' params={{ id: 1357 }}>\n  Some Book\n</Link>\n// <a href='/books/1357'>Some Book</a>"),l.default.createElement("p",null,"If you need to pass any other location properties (",l.default.createElement(u.InlineJS,null,"query"),","," ",l.default.createElement(u.InlineJS,null,"hash"),", or ",l.default.createElement(u.InlineJS,null,"state"),"), you can provide them using the"," ",l.default.createElement(u.InlineJS,null,"details")," prop."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"<Link to='Contact' details={{ hash: 'email' }}>\n  Contact by Email\n</Link>\n// <a href='/contact#email>Contact by Email</a>"),l.default.createElement(s.Note,null,"If you want to navigate outside of the application, use an anchor not a ",l.default.createElement(u.InlineComponent,null,"Link"),".",l.default.createElement(u.PrismBlock,{lang:"jsx"},"// interal\n<Link to='Contact'>Contact</Link>\n// external\n<a href=\"https://github.com\">GitHub</a>")))),l.default.createElement(c.Section,{title:"The render function",id:"render-function"},l.default.createElement("p",null,"Let's go back to that ",l.default.createElement(u.InlineJS,null,"render")," function that we pass to the"," ",l.default.createElement(u.InlineComponent,null,"CuriBase"),". In the sample code above, we just returned"," ",l.default.createElement(u.InlineJS,null,"null"),". Of course, for our website we want to return the actual elements that make up a page. How should we do this? Let's take a look at the properties of our response object."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"function render(response) {\n  console.log('response:', response);\n  return null;\n}\n/*\nresponse: {\n body: undefined,\n data: undefined,\n error: undefined,\n key: '1.0',\n location: { pathname: '/', ... },\n name: 'Home',\n params: {},\n partials: [],\n status: 200\n}\n*/"),l.default.createElement(s.Note,null,"The"," ",l.default.createElement(o.Link,{to:"Guide",params:{slug:"responses"},details:{hash:"properties"}},"Rendering with Responses")," ","guide goes into more detail about each of the properties of a response object."),l.default.createElement("p",null,"In"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"02-routes"}},"Part 3")," ","of this tutorial, we added ",l.default.createElement(u.InlineJS,null,"match.response")," functions that set the ",l.default.createElement(u.InlineJS,null,"body")," property for each of our routes. There, we just used a placeholder string, but now we can actually set the component for each route. Instead of returning a string, what if ",l.default.createElement(u.InlineJS,null,"set.body")," set the ",l.default.createElement(u.InlineJS,null,"body")," to be a React component? Then, our render function can use the ",l.default.createElement(u.InlineJS,null,"body")," property of our response object to render our website. We'll expand on that later on, but for now, let's go ahead and define the components for each of our routes.")),l.default.createElement(c.Section,{title:"The Route Components",id:"route-components"},l.default.createElement("p",null,'To refresh your memory, we have "Home", "Contact", "Book List", "Book", "Checkout", and "Not Found" pages that we will need to create components for. We can write some barebones components and add some more content later on.'),l.default.createElement("p",null,"Let's create a ",l.default.createElement(u.InlineJS,null,"components")," directory inside of our"," ",l.default.createElement(u.InlineJS,null,"src")," directory. Then, we can add files for each route in there."),l.default.createElement(u.PrismBlock,{lang:"bash"},"mkdir -p src/components"),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/components/Home.js\nimport React from 'react';\nconst Home = () => (\n  <div className='home'>\n    Welcome to our book store!\n  </div>\n);\nexport default Home;"),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/components/Contact.js\nimport React from 'react';\nconst Contact = () => (\n  <div className='contact'>\n    You can contact us by fax at 1-206-555-0123.\n  </div>\n);\nexport default Contact;"),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/components/BookList.js\nimport React from 'react';\nconst BookList = () => (\n  <div className='book-list'>\n    Available Books\n  </div>\n);\nexport default BookList;"),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/components/Book.js\nimport React from 'react';\nconst Book = () => (\n  <div className='book'>\n    Book\n  </div>\n);\nexport default Book;"),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/components/Checkout.js\nimport React from 'react';\nconst Checkout = () => (\n  <div className='checkout'>\n    Checkout\n  </div>\n);\nexport default Checkout;"),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/components/NotFound.js\nimport React from 'react';\nconst NotFound = () => (\n  <div className='not-found'>\n    Page not found\n  </div>\n);\nexport default NotFound;"),l.default.createElement("p",null,"All of these components should be imported in our ",l.default.createElement(u.InlineJS,null,"routes.js"),". We can now update our ",l.default.createElement(u.InlineJS,null,"set.body()")," calls to set the actual components as the ",l.default.createElement(u.InlineJS,null,"body")," property of responses."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/routes.js\nimport Home from './components/Home';\nimport Contact from './components/Contact';\nimport BookList from './components/BookList';\nimport Book from './components/Book';\nimport Checkout from './components/Checkout';\nimport NotFound from './components/NotFound';\n\nconst routes = [\n  {\n    name: 'Home',\n    path: '',\n    match: {\n      response: ({ set }) => {\n        set.body(Home);\n      }\n    }\n  },\n  {\n    name: 'Contact',\n    path: 'contact',\n    match: {\n      response: ({ set }) => {\n        set.body(Contact);\n      }\n    }\n  },\n  {\n    name: 'Checkout',\n    path: 'checkout',\n    match: {\n      response: ({ set }) => {\n        set.body(Checkout);\n      }\n    }\n  },\n  {\n    name: 'Book List',\n    path: 'books',\n    match: {\n      response: ({ set }) => {\n        set.body(BookList);\n      }\n    },\n    children: [\n      {\n        name: 'Book',\n        path: ':id',\n        match: {\n          response: ({ set }) => {\n            set.body(Book);\n          }\n        }\n      }\n    ]\n  },\n  {\n    name: 'Not Found',\n    path: '(.*)',\n    match: {\n      response: ({ set }) => {\n        set.body(NotFound);\n      }\n    }\n  }\n];\n\nexport default routes;"),l.default.createElement("p",null,"Our ",l.default.createElement(u.InlineJS,null,"render")," function is now able to use"," ",l.default.createElement(u.InlineJS,null,"response.body"),". This is also a good time to separate the render function from the component. This isn't absolutely necessary, but can help keep the code cleaner."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/index.js\nimport renderFunction from './render';\n\nlet root = document.getElementById('root');\nrouter.respond((response, navigation) => {\n  ReactDOM.render((\n    <CuriBase\n      router={router}\n      response={response}\n      navigation={navigation}\n      render={renderFunction}\n    />\n  ), root);\n});\n\n// render.js\nexport default function(response) {\n  return <response.body />;\n}"),l.default.createElement("p",null,"Now, if we load up our application, we will render our home page (the"," ",l.default.createElement(u.InlineJS,null,"Home")," component). Unfortunately, there is no way to navigate to any of our other pages. In order to do this, we will need to add some"," ",l.default.createElement(u.InlineComponent,null,"Link"),"s to our application.")),l.default.createElement(c.Section,{title:"A Navigation Menu",id:"nav-menu"},l.default.createElement("p",null,"We can write a simple ",l.default.createElement(u.InlineComponent,null,"NavLinks"),' menu component to add navigation to our application. From this menu, we only need to be able to navigate to our "Home", "Contact", "Book List", and "Checkout" routes. Navigation to individual books will be done from the book list page.'),l.default.createElement("p",null,"We will use a ",l.default.createElement(u.InlineComponent,null,"nav")," element as the parent for our"," ",l.default.createElement(u.InlineComponent,null,"NavLinks"),". Inside of that is a ",l.default.createElement(u.InlineComponent,null,"ul")," and then each of our routes will be ",l.default.createElement(u.InlineComponent,null,"Link"),"s wrapped in ",l.default.createElement(u.InlineComponent,null,"li"),"s."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/components/NavLinks.js\nimport React from 'react';\nimport { Link } from '@curi/react';\n\nconst NavLinks = () => (\n  <nav>\n    <ul>\n      <li>\n        <Link to='Home'>Home</Link>\n      </li>\n      <li>\n        <Link to='Contact'>Contact Us</Link>\n      </li>\n      <li>\n        <Link to='Book List'>Books for Sale</Link>\n      </li>\n      <li>\n        <Link to='Checkout'>Checkout</Link>\n      </li>\n    </ul>\n  </nav>\n);\nexport default NavLinks;"),l.default.createElement("p",null,"That is simple enough, but where should we render this? Our"," ",l.default.createElement(u.InlineComponent,null,"Link")," components rely on the context variables that are provided by the ",l.default.createElement(u.InlineComponent,null,"CuriBase"),". This means that our"," ",l.default.createElement(u.InlineComponent,null,"NavLinks")," needs to be a child of the ",l.default.createElement(u.InlineComponent,null,"CuriBase"),"."),l.default.createElement("p",null,"The easiest way for us to do that would be to modify our"," ",l.default.createElement(u.InlineJS,null,"render")," function. Instead of just returning the"," ",l.default.createElement(u.InlineJS,null,"response.body")," component, we can return a ",l.default.createElement(u.InlineComponent,null,"div")," that wraps both ",l.default.createElement(u.InlineJS,null,"response.body")," and our ",l.default.createElement(u.InlineComponent,null,"NavLinks")," ","component."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/render.js\nimport NavLinks from './components/NavLinks.js';\n\nexport default function(response) {\n  const { body: Body } = response;\n  return (\n    <div>\n      <header>\n        <NavLinks />\n      </header>\n      <main>\n        <Body />\n      </main>\n    </div>\n  );\n}"),l.default.createElement("p",null,"With the ",l.default.createElement(u.InlineComponent,null,"NavLink"),"s, we can navigate between most of our routes. However, we still need to add navigation to our individual books.")),l.default.createElement(c.Section,{title:"Navigating to Our Books",id:"param-navigation"},l.default.createElement("p",null,'Our "Book" route is different than all of our other routes because the book path includes an ',l.default.createElement(u.InlineJS,null,"id"),' param. This means that we need to actually have "id" values to pass to our ',l.default.createElement(u.InlineComponent,null,"Link"),"s. Later on, we'll generate some better data, but for now we can just generate a placeholder list in a module called ",l.default.createElement(u.InlineJS,null,"books.js"),"."),l.default.createElement(u.PrismBlock,{lang:"jsx"}," // src/books.js\nconst books = [\n  { id: 0 },\n  { id: 1 },\n  { id: 2 },\n  { id: 3 }\n];\nexport default books;"),l.default.createElement("p",null,"In the ",l.default.createElement(u.InlineComponent,null,"BookList")," component we can iterate over this list to generate links to our books."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/components/BookList.js\nimport { Link } from '@curi/react';\n\nimport books from '../books';\n\nconst BookList = () => (\n  <div className='book-list'>\n    <h1>Available Books</h1>\n    <div className='books'>\n      { books.map(b => (\n        <div className='book-item' key={b.id}>\n          <Link to='Book' params={{ id: b.id }}>\n            Book {b.id}\n          </Link>\n        </div>\n      )) }\n    </div>\n  </div>\n);")),l.default.createElement(c.Section,{title:"Book Props",id:"book-props"},l.default.createElement("p",null,"The ",l.default.createElement(u.InlineComponent,null,"Link"),"s above allow us to navigate to our books, but we don't actually have any information about which book we are supposed to be seeing. It would really help if our ",l.default.createElement(u.InlineComponent,null,"Book")," was able to access the parsed params so that it can render the information for the correct book."),l.default.createElement("p",null,"The ",l.default.createElement(u.InlineJS,null,"params")," object is a property of our response object. That means that if we pass our response object as a prop to the"," ",l.default.createElement(u.InlineComponent,null,"Body"),", we can access these params in our route components."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/render.js\nexport default function(response) {\n  const { body: Body } = response;\n  return (\n    <div>\n      <header>\n        <NavLinks />\n      </header>\n      <main>\n        <Body response={response} />\n      </main>\n    </div>\n  );\n}"),l.default.createElement(s.Note,null,"There are a number of ways that you can decide to pass props to your route components. The one thing to keep in mind is that ",l.default.createElement("em",null,"all")," of your route components will receive the same set of props. You can either be very specific and only pass the props that are necessary (e.g."," ",l.default.createElement(u.InlineComponent,null,"Body params=","{params}"),") or you can just pass the entire response object (e.g. ",l.default.createElement(u.InlineComponent,null,"Body response=","{response}"),") so you don't have to worry about updating this every time one of your route components needs another prop from the response."),l.default.createElement("p",null,"Next, we just need to update our ",l.default.createElement(u.InlineComponent,null,"Book")," component so that it can access its ",l.default.createElement(u.InlineJS,null,"params")," prop and figure out which book to render content for."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/components/Book.js\nconst Book = ({ response }) => (\n  <div className='book'>\n    Book {response.params.id}\n  </div>\n);")),l.default.createElement(c.Section,{title:"Review",id:"review"},l.default.createElement("p",null,"After completing this tutorial, we now have a semi-functional website that renders basic content for each of our pages."),l.default.createElement(i.CompleteBranch,{name:"06-loading-data-react"}),l.default.createElement(d.default,{id:"github/pshrmn/curi-tutorial/tree/06-loading-data-react"})),l.default.createElement(c.Section,{title:"Next",id:"next"},l.default.createElement("p",null,"At this point, we have a website with a number of pages. It isn't particularly useful yet, but at least we can navigate between pages. Next we will take a step back from React and learn how to implement data loading with"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"06-loading-data"}},"Part 6: Loading Data"),".")))};t.default=m},71:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),o=n(1),r=a(n(60)),i=n(64),u=n(2),s=n(9),c=n(8),d=a(n(58)),m=function(){return l.default.createElement(r.default,null,l.default.createElement("h1",null,"Part 5: Vue Pages"),l.default.createElement("p",null,"Now that we have our router ready to go, we can think about what our pages should look like. This tutorial will be rendering our website using Vue. If you prefer to use React, you should check out the"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"05-pages-react"}},"Part 5: React Pages")," ","tutorial."),l.default.createElement(i.Outline,null,l.default.createElement("ul",null,l.default.createElement("li",null,"Modifying our Webpack configuration to support Vue."),l.default.createElement("li",null,"Installing the ",l.default.createElement(u.InlineJS,null,"@curi/vue")," package, learning about the"," ",l.default.createElement(u.InlineJS,null,"CuriPlugin")," and one of the components it provides (",l.default.createElement(u.InlineComponent,null,"curi-link"),")."),l.default.createElement("li",null,"Using the response object emitted by Curi to render our website."),l.default.createElement("li",null,"Defining page components for each of the routes."),l.default.createElement("li",null,"Adding links so that users can navigate between locations in the website."))),l.default.createElement(i.TutorialBranch,{name:"05-pages-vue"}),l.default.createElement(c.Section,{title:"Webpack",id:"webpack"},l.default.createElement("p",null,"Before we dive in, let's make sure that our build scripts can handle Vue. To do this, we just need to install Webpack's Vue loader and add support for ",l.default.createElement(u.InlineJS,null,".vue")," files to our Webpack configuration."),l.default.createElement(u.PrismBlock,{lang:"bash"},"npm install --save-dev vue-loader vue-template-compiler"),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// webpack.router.js\nconst router = {\n  // ...,\n  resolve: {\n    extensions: ['.js', '.vue'],\n    alias: {\n      vue: 'vue/dist/vue.js'\n    }\n  },\n  module: {\n    rules: [\n      // ...\n      {\n        test: /.vue$/,\n        loader: 'vue-loader'\n      }\n    ]\n  }\n};")),l.default.createElement(c.Section,{title:l.default.createElement("span",null,"The ",l.default.createElement(u.InlineJS,null,"@curi/vue")," Package"),id:"package"},l.default.createElement("p",null,"The ",l.default.createElement(u.InlineJS,null,"@curi/vue")," package exports a Vue plugin, which provides components that know how to interact with Curi. For this tutorial, we will only be using one: ",l.default.createElement(u.InlineComponent,null,"curi-link"),". You can read more about the package in the"," ",l.default.createElement(o.Link,{to:"Package",params:{package:"vue"},details:{hash:"API"}},l.default.createElement(u.InlineJS,null,"@curi/vue")," documentation"),"."),l.default.createElement(c.Subsection,{title:"Installation",id:"installation"},l.default.createElement("p",null,"Let's start by installing the ",l.default.createElement(u.InlineJS,null,"@curi/vue")," package as well as Vue."),l.default.createElement(u.PrismBlock,{lang:"bash"},"npm install @curi/vue vue")),l.default.createElement(c.Subsection,{title:"The Plugin",id:"plugin"},l.default.createElement("p",null,"The ",l.default.createElement(u.InlineJS,null,"CuriPlugin")," exported by ",l.default.createElement(u.InlineJS,null,"@curi/vue"),", should be registered with Vue after the Curi router has been created. The plugin does a couple things. First, it will make your Curi router and new responses/navigations accessible to every component. The router will be accessible as ",l.default.createElement(u.InlineJS,null,"this.$router")," while through the"," ",l.default.createElement(u.InlineJS,null,"response")," and ",l.default.createElement(u.InlineJS,null,"navigation")," are grouped under the"," ",l.default.createElement(u.InlineJS,null,"this.$curi")," object. Second, it will register Curi specific components. For this tutorial, the only component that we care about is ",l.default.createElement(u.InlineComponent,null,"curi-link"),"."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/index.js\nimport Vue from 'vue';\nimport { CuriPlugin } from '@curi/vue';\n\nconst router = curi(history, routes);\nVue.use(CuriPlugin, { router });")),l.default.createElement(c.Subsection,{title:l.default.createElement("span",null,"The ",l.default.createElement(u.InlineComponent,null,"curi-link")," Component"),id:"Link"},l.default.createElement("p",null,"The ",l.default.createElement(u.InlineComponent,null,"curi-link")," component renders anchor (",l.default.createElement(u.InlineComponent,null,"a"),") elements. However, unlike an anchor, we don't actually have to write the URI that we want to navigate to (the ",l.default.createElement(u.InlineJS,null,"href"),"). Instead, you use the ",l.default.createElement(u.InlineJS,null,"to")," prop to pass the name of the route that you want to navigate to."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"<curi-link to='Home'>Home</curi-link>\n// <a href='/'>Home</a>"),l.default.createElement("p",null,"If the route that you are navigating to has any params, you pass them using the ",l.default.createElement(u.InlineJS,null,"params")," prop."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// { name: 'Book', path: ':id' }\n// (inherits 'books' path from parent route)\n<curi-link to='Book' params={{ id: 1357 }}>\n  Some Book\n</curi-link>\n// <a href='/books/1357'>Some Book</a>"),l.default.createElement("p",null,"If you need to pass any other location properties (",l.default.createElement(u.InlineJS,null,"query"),",",l.default.createElement(u.InlineJS,null,"hash"),", or ",l.default.createElement(u.InlineJS,null,"state"),"), you can provide them using the"," ",l.default.createElement(u.InlineJS,null,"details")," prop."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"<curi-link to='Contact' details={{ hash: 'email' }}>\n  Contact by Email\n</curi-link>\n// <a href='/contact#email>Contact by Email</a>"),l.default.createElement(s.Note,null,"If you want to navigate outside of the application, use an anchor not a ",l.default.createElement(u.InlineComponent,null,"curi-link"),".",l.default.createElement(u.PrismBlock,{lang:"jsx"},"// interal\n<curi-link to='Contact'>Contact</curi-link>\n// external\n<a href=\"https://github.com\">GitHub</a>")))),l.default.createElement(c.Section,{title:"The Response",id:"response"},l.default.createElement("p",null,"Being able to access the Curi router is nice, but what we really need is to access the response objects that are emitted by Curi whenever the location changes. We ",l.default.createElement("em",null,"could")," use the ",l.default.createElement(u.InlineJS,null,"router.respond")," ","method that we covered in the"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"04-router"}},"router")," ","tutorial, but the ",l.default.createElement(u.InlineJS,null,"CuriPlugin")," takes care of that step for us."," ",l.default.createElement(u.InlineJS,null,"CuriPlugin")," calls ",l.default.createElement(u.InlineJS,null,"router.respond")," and in the response handler, it updates the reactive ",l.default.createElement(u.InlineJS,null,"response")," and"," ",l.default.createElement(u.InlineJS,null,"navigation")," properties of ",l.default.createElement(u.InlineJS,null,"this.$curi")," whenever a new response is emitted."),l.default.createElement("p",null,"While we do not have to manually subscribe to all responses, we do need to listen for the first response to be emitted so that we can render the application. The second argument to ",l.default.createElement(u.InlineJS,null,"router.respond")," is an options object. If we pass the options ",l.default.createElement(u.InlineJS,null,"{ once: true }"),", then that function will only be called after the initial response is emitted."),l.default.createElement("p",null,"Inside of the response handler function, we just need to render our root application component. All of our Curi related data will be available through ",l.default.createElement(u.InlineJS,null,"this.$curi"),", so we don't have to attach any data to the Vue instance."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/index.js\nimport app from './components/app';\n\nrouter.respond(response => {\n  const vm = new Vue({\n    el: '#root',\n    template: '<app />',\n    components: { app }\n  });\n}, { once: true });")),l.default.createElement(c.Section,{title:"The App",id:"app"},l.default.createElement("p",null,"At this point we have the ability to access our router throughout our components and we are passing response objects to some ",l.default.createElement(u.InlineComponent,null,"app")," ","component that we haven't actually written yet. We should write those components now."),l.default.createElement("p",null,"Our ",l.default.createElement(u.InlineComponent,null,"app")," component will be responsible for rendering our website based on the response object. To start, let's add a"," ",l.default.createElement(u.InlineJS,null,"components")," directory to our ",l.default.createElement(u.InlineJS,null,"src")," directory."),l.default.createElement(u.PrismBlock,{lang:"bash"},"mkdir -p src/components"),l.default.createElement("p",null,"From up above, we know that our ",l.default.createElement(u.InlineComponent,null,"app")," will be receiving the response object as a prop. What should it render, though?"),l.default.createElement(u.PrismBlock,{lang:"html"},"\x3c!-- components/App.vue --\x3e\n<template>\n</template>\n\n<script>\n  export default {\n    name: 'app'\n  };\n<\/script>"),l.default.createElement("p",null,"Let's take a look at the properties of our response object to see which of its properties would be helpful for rendering our website."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"{\n body: undefined,\n data: undefined,\n error: undefined,\n key: '1.0',\n location: { pathname: '/', ... },\n name: 'Home',\n params: {},\n partials: [],\n status: 200\n}"),l.default.createElement(s.Note,null,"The"," ",l.default.createElement(o.Link,{to:"Guide",params:{slug:"responses"},details:{hash:"properties"}},"Rendering with Responses")," ","guide goes into more detail about each of the properties of a response object."),l.default.createElement("p",null,"In"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"02-routes"}},"Part 3")," ","of this tutorial, we added ",l.default.createElement(u.InlineJS,null,"match.response")," functions that set the ",l.default.createElement(u.InlineJS,null,"body")," property for each of our routes. There, we just used a placeholder string, but now we can actually set the component for each route. Instead of returning a string, what if ",l.default.createElement(u.InlineJS,null,"set.body")," set the ",l.default.createElement(u.InlineJS,null,"body")," to be a Vue component? Then, our render function can use the ",l.default.createElement(u.InlineJS,null,"body")," property of our response object to render our website."),l.default.createElement(u.PrismBlock,{lang:"html"},"\x3c!-- components/App.vue --\x3e\n<template>\n  <component :is=\"$curi.response.body\" />\n</template>\n\n<script>\nexport default {\n  name: 'app'\n};\n<\/script>"),l.default.createElement("p",null,"We'll expand on that later on, but for now, let's go ahead and define the components for each of our routes.")),l.default.createElement(c.Section,{title:"The Route Components",id:"route-components"},l.default.createElement("p",null,'To refresh your memory, we have "Home", "Contact", "Book List", "Book", "Checkout", and "Not Found" pages that we will need to create components for. We can write some barebones components and add some more content later on.'),l.default.createElement(u.PrismBlock,{lang:"html"},"\x3c!-- src/components/Home.vue --\x3e\n<template>\n  <div class='home'>\n    Welcome to our book store!\n  </div>\n</template>"),l.default.createElement(u.PrismBlock,{lang:"html"},"\x3c!-- src/components/Contact.vue --\x3e\n<template>\n  <div class='contact'>\n    You can contact us by fax at 1-206-555-0123.\n  </div>\n</template>"),l.default.createElement(u.PrismBlock,{lang:"html"},"\x3c!-- src/components/BookList.vue --\x3e\n<template>\n  <div class='book-list'>\n    Available Books\n  </div>\n</template>"),l.default.createElement(u.PrismBlock,{lang:"html"},"\x3c!-- src/components/Book.vue --\x3e\n<template>\n  <div class='book'>\n    Book\n  </div>\n</template>"),l.default.createElement(u.PrismBlock,{lang:"html"},"\x3c!-- src/components/Checkout.vue --\x3e\n<template>\n  <div class='checkout'>\n    Checkout\n  </div>\n</template>"),l.default.createElement(u.PrismBlock,{lang:"html"},"\x3c!-- src/components/NotFound.vue --\x3e\n<template>\n  <div class='not-found'>\n    Page not found\n  </div>\n</template>"),l.default.createElement("p",null,"All of these components should be imported in our ",l.default.createElement(u.InlineJS,null,"routes.js")," ","and set using ",l.default.createElement(u.InlineJS,null,"set.body")," in their respective"," ",l.default.createElement(u.InlineJS,null,"match.response")," functions."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/routes.js\nimport Home from './components/Home';\nimport Contact from './components/Contact';\nimport BookList from './components/BookList';\nimport Book from './components/Book';\nimport Checkout from './components/Checkout';\nimport NotFound from './components/NotFound';\n\nconst routes = [\n  {\n    name: 'Home',\n    path: '',\n    match: {\n      response: ({ set }) => {\n        set.body(Home);\n      }\n    }\n  },\n  {\n    name: 'Contact',\n    path: 'contact',\n    match: {\n      response: ({ set }) => {\n        set.body(Contact);\n      }\n    }\n  },\n  {\n    name: 'Checkout',\n    path: 'checkout',\n    match: {\n      response: ({ set }) => {\n        set.body(Checkout);\n      }\n    }\n  },\n  {\n    name: 'Book List',\n    path: 'books',\n    match: {\n      response: ({ set }) => {\n        set.body(BookList);\n      }\n    },\n    children: [\n      {\n        name: 'Book',\n        path: ':id',\n        match: {\n          response: ({ set }) => {\n            set.body(Book);\n          }\n        }\n      }\n    ]\n  },\n  {\n    name: 'Not Found',\n    path: '(.*)',\n    match: {\n      response: ({ set }) => {\n        set.body(NotFound);\n      }\n    }\n  }\n];\n\nexport default routes;"),l.default.createElement("p",null,"Now, if we load up our application, we will render our home page. Unfortunately, there is no way to navigate to any of our other pages. We will need to add some ",l.default.createElement(u.InlineComponent,null,"curi-link"),"s to our application.")),l.default.createElement(c.Section,{title:"A Navigation Menu",id:"nav-menu"},l.default.createElement("p",null,"We can write a simple ",l.default.createElement(u.InlineComponent,null,"NavLinks"),' menu component to add navigation to our application. From this menu, we only need to be able to navigate to our "Home", "Contact", "Book List", and "Checkout" routes. Navigation to individual books will be done from the book list page.'),l.default.createElement("p",null,"We will use a ",l.default.createElement(u.InlineComponent,null,"nav")," element as the parent for our"," ",l.default.createElement(u.InlineComponent,null,"NavLinks"),". Inside of that is a ",l.default.createElement(u.InlineComponent,null,"ul")," and then each of our routes will be ",l.default.createElement(u.InlineComponent,null,"Link"),"s wrapped in ",l.default.createElement(u.InlineComponent,null,"li"),"s."),l.default.createElement(u.PrismBlock,{lang:"html"},"\x3c!-- src/components/NavLinks.vue --\x3e\n<template>\n  <nav>\n    <ul>\n      <li>\n        <curi-link to='Home'>Home</curi-link>\n      </li>\n      <li>\n        <curi-link to='Contact'>Contact Us</curi-link>\n      </li>\n      <li>\n        <curi-link to='Book List'>Books for Sale</curi-link>\n      </li>\n      <li>\n        <curi-link to='Checkout'>Checkout</curi-link>\n      </li>\n    </ul>\n  </nav>\n</template>"),l.default.createElement("p",null,"Let's import and render that the ",l.default.createElement(u.InlineComponent,null,"NavLinks")," in our"," ",l.default.createElement(u.InlineComponent,null,"app"),". We'll also add some wrapper elements to keep our content organized."),l.default.createElement(u.PrismBlock,{lang:"html"},"\x3c!-- src/components/App.vue --\x3e\n<template>\n  <div>\n    <header>\n      <NavLinks />\n    </header>\n    <main>\n      <component :is=\"$curi.response.body\" />\n    </main>\n  </div>\n</template>\n\n<script>\n  import NavLinks from './NavLinks';\n\n  export default {\n    name: 'app',\n    components: { NavLinks }\n  };\n<\/script>"),l.default.createElement("p",null,"At this point, we can navigate between most of our routes. However, we still need to add navigation to our books.")),l.default.createElement(c.Section,{title:"Navigating to Our Books",id:"param-navigation"},l.default.createElement("p",null,'Our "Book" route is different than all of our other routes because the book path includes an ',l.default.createElement(u.InlineJS,null,"id"),' param. This means that we need to actually have "id" values to pass to our ',l.default.createElement(u.InlineComponent,null,"curi-link"),"s. Later on, we'll generate some better data, but for now we can just generate a placeholder list in a module called ",l.default.createElement(u.InlineJS,null,"books.js"),"."),l.default.createElement(u.PrismBlock,{lang:"jsx"}," // src/books.js\nconst books = [\n  { id: 0 },\n  { id: 1 },\n  { id: 2 },\n  { id: 3 }\n];\nexport default books;"),l.default.createElement("p",null,"Then, in ",l.default.createElement(u.InlineComponent,null,"BookList")," we can iterate over this list to generate links to our books."),l.default.createElement(u.PrismBlock,{lang:"html"},"\x3c!-- src/components/BookList.vue --\x3e\n<template>\n  <div class='book-list'>\n    <h1>Available Books</h1>\n    <div class='books'>\n      <div v-for=\"book in books\" :key=\"book.id\" class='book-item'>\n        <curi-link to='Book' :params=\"{ id: book.id }\">\n          Book {{book.id}}\n        </curi-link>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\n  import books from '../books';\n  export default {\n    data: function() {\n      return { books };\n    }\n  };\n<\/script>\n")),l.default.createElement(c.Section,{title:"Book Props",id:"book-props"},l.default.createElement("p",null,"The ",l.default.createElement(u.InlineComponent,null,"curi-link"),"s above allow us to navigate to our books, but we don't actually have any information about which book we are supposed to be seeing. It would really help if our ",l.default.createElement(u.InlineComponent,null,"Book")," was able to access the parsed params so that it can render the information for the correct book."),l.default.createElement("p",null,"The ",l.default.createElement(u.InlineJS,null,"params")," object is a property of our response object. We can access the response in our components using"," ",l.default.createElement(u.InlineJS,null,"this.$curi.response"),", so we don't actually have to manually pass it as a prop."),l.default.createElement("p",null,"Next, we just need to update our ",l.default.createElement(u.InlineComponent,null,"Book")," component to access the"," ",l.default.createElement(u.InlineJS,null,"params")," object and figure out which book to render content for."),l.default.createElement(u.PrismBlock,{lang:"html"},"\x3c!-- src/components/Book.vue --\x3e\n<template>\n  <div class='book'>\n    Book {{$curi.response.params.id}}\n  </div>\n</template>")),l.default.createElement(c.Section,{title:"Review",id:"review"},l.default.createElement("p",null,"After completing this tutorial, we now have a semi-functional website that renders basic content for each of our pages."),l.default.createElement(i.CompleteBranch,{name:"06-loading-data-vue"}),l.default.createElement(d.default,{id:"github/pshrmn/curi-tutorial/tree/06-loading-data-vue"})),l.default.createElement(c.Section,{title:"Next",id:"next"},l.default.createElement("p",null,"At this point, we have a website with a number of pages. It isn't particularly useful yet, but at least we can navigate between pages. Next we will take a step back from Vue and look at how we can implement data loading with with"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"06-loading-data"}},"Part 6: Loading Data"),".")))};t.default=m},72:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),o=n(1),r=a(n(60)),i=n(64),u=n(2),s=n(9),c=n(8),d=function(){return l.default.createElement(r.default,null,l.default.createElement("h1",null,"Part 6: Loading Data"),l.default.createElement("p",null,"In the previous tutorial, we wrote mocked book data in ",l.default.createElement(u.InlineJS,null,"books.js")," ",'to have some data to load, but it was just filler. We imported the data as an array, whereas in a "real" website, we would most likely make a request to our server which would return our data.'),l.default.createElement(i.Outline,null,l.default.createElement("ul",null,l.default.createElement("li",null,"Writing a fake API to simulate data requests."),l.default.createElement("li",null,"Adding ",l.default.createElement(u.InlineJS,null,"match.every"),' functions to our "Book List" and "Book" routes and updating their ',l.default.createElement(u.InlineJS,null,"match.response")," functions."))),l.default.createElement(i.TutorialBranches,{names:["06-loading-data-react","06-loading-data-vue"]}),l.default.createElement(c.Section,{title:"Fake API",id:"api"},l.default.createElement("p",null,"There are a number of ways that we might make a request to the server, but in this tutorial we will simulate using the"," ",l.default.createElement("a",{href:"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"},"Fetch API"),". The ",l.default.createElement(u.InlineJS,null,"fetch")," function makes a request to the server and returns a Promise that will resolve with the server's response."),l.default.createElement("p",null,"Let's create an ",l.default.createElement(u.InlineJS,null,"api")," directory and start writing our fake fetch functions."),l.default.createElement(u.PrismBlock,{lang:"bash"},"mkdir -p src/api\ntouch src/api/books.js"),l.default.createElement("p",null,"We'll need to write two functions. The first will fetch all of our books and the second will fetch a specific book given an ",l.default.createElement(u.InlineJS,null,"id"),". Since we are emulating how ",l.default.createElement(u.InlineJS,null,"fetch")," works, both of our functions should return a Promise."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/api/books.js\nexport function fetchAllBooks() {\n  return new Promise((resolve, reject) => {\n\n  });\n}\n\nexport function fetchBook(id) {\n  return new Promise((resolve, reject) => {\n\n  });\n}"),l.default.createElement("p",null,"We need some actual data for our fetch functions to return, so let's write an array of book objects. You can make up your own data or just copy the list from below."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/api/books.js\nconst books = [\n  {\n    id: 0,\n    title: 'Harry Potter and the Deathly Hollows',\n    author: 'J.K. Rowling',\n    published: '2007',\n    pages: 759\n  },\n  {\n    id: 1,\n    title: 'The Name of the Wind',\n    author: 'Patrick Rothfuss',\n    published: '2007',\n    pages: 662\n  },\n  {\n    id: 2,\n    title: \"The Wise Man's Fear\",\n    author: 'Patrick Rothfuss',\n    published: '2011',\n    pages: 994\n  },\n  {\n    id: 3,\n    title: 'The Way of Kings',\n    author: 'Brandon Sanderson',\n    published: '2010',\n    pages: 1007\n  },\n  {\n    id: 4,\n    title: 'A Storm of Swords',\n    author: 'George R.R. Martin',\n    published: '2003',\n    pages: 1177\n  },\n  {\n    id: 5,\n    title: 'Clockwork Princess',\n    author: 'Cassandra Clare',\n    published: '2013',\n    pages: 567\n  },\n  {\n    id: 6,\n    title: 'Words of Radiance',\n    author: 'Brandon Sanderson',\n    published: '2014',\n    pages: 1087\n  },\n  {\n    id: 7,\n    title: 'Collected Fictions',\n    author: 'Jorge Luis Borges',\n    published: '1999',\n    pages: 565\n  },\n  {\n    id: 8,\n    title: 'Heir of Fire',\n    author: 'Sarah J. Maas',\n    published: '2014',\n    pages: 565\n  },\n  {\n    id: 9,\n    title: 'The House of Hades',\n    author: 'Rick Riordan',\n    published: '2013',\n    pages: 597\n  }\n];"),l.default.createElement("p",null,"With this data, we can now finish our data fetching functions. Our"," ",l.default.createElement(u.InlineJS,null,"fetchAllBooks")," function should just resolve with the books array. ",l.default.createElement(u.InlineJS,null,"fetchBook")," should search the books array for the book with the requested id. If it finds a matching book object, the function should resolve with that book object. If the requested book is not found, it should reject with an error message."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/api/books.js\nconst books = [...];\n\nexport function fetchAllBooks() {\n  return new Promise((resolve, reject) => {\n    resolve(books);\n  });\n}\n\nexport function fetchBook(id) {\n  return new Promise((resolve, reject) => {\n    const book = books.find(book => book.id === id);\n    if (book) {\n      resolve(book);\n    } else {\n      reject(`Could not find the requested book: ${id}`);\n    }\n  });\n}")),l.default.createElement(c.Section,{title:"match",id:"match"},l.default.createElement("p",null,"Do you remember before when we said that Curi is an asynchronous router? Now is the time that we finally will see why. We have already added"," ",l.default.createElement(u.InlineJS,null,"match")," properties to each of our route objects, but"," ",l.default.createElement(u.InlineJS,null,"match.response")," is a synchronous function."," ",l.default.createElement(u.InlineJS,null,"match.every"),", on the other hand, is an asynchronous function."),l.default.createElement(c.Subsection,{title:"every",id:"every"},l.default.createElement("p",null,l.default.createElement(u.InlineJS,null,"match.every")," is a function that can perform data loading related to a route prior to emitting a response. The function will be passed route related props (the ",l.default.createElement(u.InlineJS,null,"params")," object, the"," ",l.default.createElement(u.InlineJS,null,"location"),", and the ",l.default.createElement(u.InlineJS,null,"name")," of the matched route), which it can use to formulate any API calls. Each time that a route matches, its ",l.default.createElement(u.InlineJS,null,"match.every")," function will be called."),l.default.createElement("p",null,l.default.createElement(u.InlineJS,null,"match.every")," functions are expected to return a Promise. Curi uses ",l.default.createElement(u.InlineJS,null,"Promise.all")," to wait for your"," ",l.default.createElement(u.InlineJS,null,"match.every")," and"," ",l.default.createElement(o.Link,{to:"Guide",params:{slug:"routes"},details:{hash:"initial"}},l.default.createElement(u.InlineJS,null,"match.initial")," functions")," ","to resolve before it emits a response. Technically speaking, these functions don't have to return a Promise, but it is recommended."),l.default.createElement("p",null,'We have two routes that we need to load data in: "Book List" and "Book". Let\'s start by adding ',l.default.createElement(u.InlineJS,null,"match.every")," functions to each one, calling their respective API functions that we defined above."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/routes.js\nimport { fetchAllBooks, fetchBook } from './api/books';\nconst routes = [\n  // ...,\n  {\n    name: 'Book List',\n    path: 'books',\n    match: {\n      every: () => fetchAllBooks(),\n      response: ({ set }) => {\n        set.body(BookList);\n      }\n    },\n    children: [\n      {\n        name: 'Book',\n        path: ':id',\n        params: { id: n => parseInt(n, 10) },\n        match: {\n          every: ({ params }) => fetchBook(params.id),\n          response: ({ set }) => {\n            set.body(Book);\n          }\n        }\n      }\n    ]\n  }\n  // ...\n];"),l.default.createElement(s.Note,null,'In the above "Book" route, we introduce the ',l.default.createElement(u.InlineJS,null,"route.params")," ","property. This is an object whose keys are path param names and whose values are functions that will parse the param string to return a new value. For example, the above function takes the input string and returns that string parsed as an integer.")),l.default.createElement(c.Subsection,{title:"response",id:"response"},l.default.createElement("p",null,"While we have already used ",l.default.createElement(u.InlineJS,null,"match.response"),", we have only used the ",l.default.createElement(u.InlineJS,null,"set.body")," function so far. If you need to review them, you can view all of the properties passed to the"," ",l.default.createElement(u.InlineJS,null,"response")," function in the"," ",l.default.createElement(o.Link,{to:"Guide",params:{slug:"routes"},details:{hash:"response"}},"All About Routes")," ","guide. We want to attach our loaded data to the response, so we will use ",l.default.createElement(u.InlineJS,null,"resolved.every")," to access the data from our"," ",l.default.createElement(u.InlineJS,null,"every")," function and ",l.default.createElement(u.InlineJS,null,"set.data")," to attach the data to the response object. It is also possible that someone might request a book that does not exist, to deal with that, we will use the"," ",l.default.createElement(u.InlineJS,null,"error")," property and the ",l.default.createElement(u.InlineJS,null,"set.error")," function."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/routes.js\nimport { fetchAllBooks, fetchBook } from './api/books';\nconst routes = [\n// ...,\n{\n  name: 'Book List',\n  path: 'books',\n  match: {\n    every: () => fetchAllBooks(),\n    response: ({ resolved, set }) => {\n      set.body(BookList);\n      set.data({ books: resolved.every });\n    }\n  },\n  children: [\n    {\n      name: 'Book',\n      path: ':id',\n      params: { id: n => parseInt(n, 10) },\n      match: {\n        every: ({ params }) => fetchBook(params.id),\n        response: ({ error, resolved, set }) => {\n          set.body(Book);\n          if (error) {\n            set.error(error);\n          } else {\n            set.data({ book: resolved.every });\n          }\n        }\n      }\n    }\n  ]\n}\n// ...\n];"),l.default.createElement(s.Note,null,"If you do not catch errors in your ",l.default.createElement(u.InlineJS,null,"every")," function, you still get the opportunity to deal with them using the ",l.default.createElement(u.InlineJS,null,"error")," ","property passed to ",l.default.createElement(u.InlineJS,null,"match.response"),". However, if you do not handle the error there, you may end up with unexpected errors in your website.")),l.default.createElement("p",null,"Now, when a user visits ",l.default.createElement(u.InlineJS,null,"/books"),", the response generated by Curi will look like this:"),l.default.createElement(u.PrismBlock,{lang:"javascript"},"{\n  name: 'Book List',\n  data: {\n    books: [/*...*/]\n  },\n  // ...\n}"),l.default.createElement("p",null,"Likewise, visiting ",l.default.createElement(u.InlineJS,null,"/books/0")," will generate a response whose"," ",l.default.createElement(u.InlineJS,null,"data")," property is a book object."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"{\n  name: 'Book',\n  params: { id: 0 }\n  data: {\n    book: { title: '...', /*...*/ }\n  },\n  // ...\n}")),l.default.createElement(c.Section,{title:"Review",id:"review"},l.default.createElement("p",null,"If you are following the React path:"),l.default.createElement(i.CompleteBranch,{name:"07-render-data-react"}),l.default.createElement("p",null,"If you are following the Vue path:"),l.default.createElement(i.CompleteBranch,{name:"07-render-data-vue"})),l.default.createElement(c.Section,{title:"Next",id:"next"},l.default.createElement("p",null,'Now that we are loading data for our routes, we should modify our "Book List" and "Book" pages to render using this data. Once again, we will break this down for React and Vue users.'),l.default.createElement("p",null,"If you are using React, continue with"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"07-render-data-react"}},"Part 7: Rendering Data with React"),"."),l.default.createElement("p",null,"If you are using Vue, continue with"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"07-render-data-vue"}},"Part 7: Rendering Data with Vue"),".")))};t.default=d},73:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),o=n(1),r=a(n(60)),i=n(64),u=n(2),s=n(9),c=n(8),d=a(n(58)),m=function(){return l.default.createElement(r.default,null,l.default.createElement("h1",null,"Part 7: Rendering Data with React"),l.default.createElement("p",null,"Now that our responses have ",l.default.createElement(u.InlineJS,null,"data"),", we should update our"," ",l.default.createElement(u.InlineComponent,null,"BookList")," and ",l.default.createElement(u.InlineComponent,null,"Book")," components to use that. Accessing the ",l.default.createElement(u.InlineJS,null,"data")," is really easy because it is a property of our"," ",l.default.createElement(u.InlineJS,null,"response")," object."),l.default.createElement(i.Outline,null,l.default.createElement("ul",null,l.default.createElement("li",null,"Updating our ",l.default.createElement(u.InlineComponent,null,"BookList")," and ",l.default.createElement(u.InlineComponent,null,"Book")," components to render using ",l.default.createElement(u.InlineJS,null,"response.data"),"."))),l.default.createElement(i.TutorialBranch,{name:"07-render-data-react"}),l.default.createElement(c.Section,{title:"Using Data with the Book List",id:"book-list"},l.default.createElement("p",null,"Currently, in our ",l.default.createElement(u.InlineJS,null,"BookList.js")," file, we are importing the books from a file. Now, we can remove that import and instead use the"," ",l.default.createElement(u.InlineJS,null,"response")," prop to access our data. Since we also have better data, we can now use each book's title for the link text."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/components/BookList.js\nconst BookList = ({ response }) => (\n  <div className='book-list'>\n    <h1>Available Books</h1>\n    <div className='books'>\n      { response.data.books.map(b => (\n        <div key={b.id} className='book-item'>\n          <Link to='Book' params={{ id: b.id }}>\n            {b.title}\n          </Link>\n        </div>\n      )) }\n    </div>\n  </div>\n);"),l.default.createElement(s.Note,null,"If our ",l.default.createElement(u.InlineJS,null,"render")," function (passed to the ",l.default.createElement(u.InlineComponent,null,"CuriBase"),") had just passed the ",l.default.createElement(u.InlineJS,null,"params")," instead of the whole"," ",l.default.createElement(u.InlineJS,null,"response"),", we would have to modify that function to also pass along the ",l.default.createElement(u.InlineJS,null,"data"),". Since we pass the entire ",l.default.createElement(u.InlineJS,null,"response"),", we do not have to worry about updating that function.")),l.default.createElement(c.Section,{title:"Using Data with the Book",id:"book"},l.default.createElement("p",null,"We are already using the ",l.default.createElement(u.InlineJS,null,"response")," prop in ",l.default.createElement(u.InlineComponent,null,"Book"),". Now, instead of using ",l.default.createElement(u.InlineJS,null,"params"),", we will switch to using"," ",l.default.createElement(u.InlineJS,null,"data"),". We can also take advantage of the ",l.default.createElement(u.InlineJS,null,"data.book")," ","properties to expand on our ",l.default.createElement(u.InlineComponent,null,"Book")," implementation."),l.default.createElement("p",null,"We also have a special case that we need to consider: what should we do when there is no matching book? In the sample data, we have books with ids that range from 0-9. What if the user navigates to"," ",l.default.createElement(u.InlineJS,null,"/books/123"),"? Our ",l.default.createElement(u.InlineJS,null,"fetchBook")," call will reject and"," ",l.default.createElement(u.InlineJS,null,"response.data")," will be ",l.default.createElement(u.InlineJS,null,"undefined"),". For now, we can just detect when ",l.default.createElement(u.InlineJS,null,"response.data")," is ",l.default.createElement(u.InlineJS,null,"undefined")," and render a simple message stating that the requested book does not exist."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/components/Book.js\nconst Book = (props) => {\n  const { data } = props.response;\n  if (!data) {\n    return (\n      <div className='book'>\n        The requested book does not exist\n      </div>\n    );\n  }\n  const { book } = data;\n  return (\n    <div className='book'>\n      <h2>{book.title}</h2>\n      <p>By {book.author}</p>\n      <p>Published in {book.published}</p>\n      <p>This book is {book.pages} pages</p>\n    </div>\n  );\n};")),l.default.createElement("p",null,"Now that we are using ",l.default.createElement(u.InlineJS,null,"response.data")," in both the"," ",l.default.createElement(u.InlineComponent,null,"BookList")," and ",l.default.createElement(u.InlineComponent,null,"Book")," components, we can remove the"," ",l.default.createElement(u.InlineJS,null,"books.js")," file."),l.default.createElement(u.PrismBlock,{lang:"bash"},"git rm src/books.js"),l.default.createElement(c.Section,{title:"Review",id:"review"},l.default.createElement("p",null,'Our "Book List" and "Book" pages are now rendered using data from'," ",l.default.createElement(u.InlineJS,null,"response.data"),"."),l.default.createElement(i.CompleteBranch,{name:"08-nav-react"}),l.default.createElement(d.default,{id:"github/pshrmn/curi-tutorial/tree/08-nav-react"})),l.default.createElement(c.Section,{title:"Next",id:"next"},l.default.createElement("p",null,'Our book component still isn\'t complete. We are building a book store after all, so we should really provide the user a way to actually "buy" a book. In'," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"08-nav-react"}},"Part 8: Forms & Navigation"),', we will add the ability to add books to a shopping cart and "purchase" them from our "Checkout" route.')))};t.default=m},74:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),o=n(1),r=a(n(60)),i=n(64),u=n(2),s=(n(9),n(8)),c=a(n(58)),d=function(){return l.default.createElement(r.default,null,l.default.createElement("h1",null,"Part 7: Rendering Data with Vue"),l.default.createElement("p",null,"Now that our responses have ",l.default.createElement(u.InlineJS,null,"data"),", we should update our"," ",l.default.createElement(u.InlineComponent,null,"BookList")," and ",l.default.createElement(u.InlineComponent,null,"Book")," components to use that. Accessing the ",l.default.createElement(u.InlineJS,null,"data")," is really easy because it is a property of our"," ",l.default.createElement(u.InlineJS,null,"response")," object."),l.default.createElement(i.Outline,null,l.default.createElement("ul",null,l.default.createElement("li",null,"Updating our ",l.default.createElement(u.InlineComponent,null,"BookList")," and ",l.default.createElement(u.InlineComponent,null,"Book")," components to render using ",l.default.createElement(u.InlineJS,null,"response.data"),"."))),l.default.createElement(i.TutorialBranch,{name:"07-render-data-vue"}),l.default.createElement(s.Section,{title:"Using Data with the Book List",id:"book-list"},l.default.createElement("p",null,"Currently, in our ",l.default.createElement(u.InlineJS,null,"BookList.vue")," file, we are importing the books from a file. Now, we can remove that import and instead use the"," ",l.default.createElement(u.InlineJS,null,"response")," prop to access our data. Since we also have better data, we can now use each book's title for the link text."),l.default.createElement(u.PrismBlock,{lang:"html"},"\x3c!-- src/components/BookList.vue --\x3e\n<template>\n  <div class='book-list'>\n    <h1>Available Books</h1>\n    <div class='books'>\n      <div\n        v-for=\"book in $curi.response.data.books\"\n        :key=\"book.id\"\n        class='book-item'\n      >\n        <curi-link to='Book' :params=\"{ id: book.id }\">\n          {{book.title}}\n        </curi-link>\n      </div>\n    </div>\n  </div>\n</template>")),l.default.createElement(s.Section,{title:"Using Data with the Book",id:"book"},l.default.createElement("p",null,"We are already using the ",l.default.createElement(u.InlineJS,null,"response")," prop in ",l.default.createElement(u.InlineComponent,null,"Book"),". Now, instead of using ",l.default.createElement(u.InlineJS,null,"params"),", we will switch to using"," ",l.default.createElement(u.InlineJS,null,"data"),". We can also take advantage of the ",l.default.createElement(u.InlineJS,null,"data.book")," ","properties to expand on our ",l.default.createElement(u.InlineComponent,null,"Book")," implementation."),l.default.createElement("p",null,"We also have a special case that we need to consider: what should we do when there is no matching book? In the sample data, we have books with ids that range from 0-9. What if the user navigates to"," ",l.default.createElement(u.InlineJS,null,"/books/123"),"? Our ",l.default.createElement(u.InlineJS,null,"fetchBook")," call will reject and"," ",l.default.createElement(u.InlineJS,null,"response.data")," will be ",l.default.createElement(u.InlineJS,null,"undefined"),". For now, we should detect that and render a simple message stating that the requested book does not exist."),l.default.createElement(u.PrismBlock,{lang:"html"},"\x3c!-- src/components/Book.vue --\x3e\n<template>\n  <div v-if=\"$curi.response.error\" class='book'>\n    {{error}}\n  </div>\n  <div v-else class='book'>\n    <h2>{{book.title}}</h2>\n    <p>By {{book.author}}</p>\n    <p>Published in {{book.published}}</p>\n    <p>This book is {{book.pages}} pages</p>\n  </div>\n</template>\n\n<script>\n  export default {\n    computed: {\n      book: function() {\n        const { response } = this.$curi;\n        return !response.error && response.data.book;\n      }\n    }\n  };\n<\/script>")),l.default.createElement("p",null,"Now that we are using ",l.default.createElement(u.InlineJS,null,"response.data")," in both the"," ",l.default.createElement(u.InlineComponent,null,"BookList")," and ",l.default.createElement(u.InlineComponent,null,"Book")," components, we can remove the"," ",l.default.createElement(u.InlineJS,null,"books.js")," file."),l.default.createElement(u.PrismBlock,{lang:"bash"},"git rm src/books.js"),l.default.createElement(s.Section,{title:"Review",id:"review"},l.default.createElement("p",null,'Our "Book List" and "Book" pages are now rendered using data from'," ",l.default.createElement(u.InlineJS,null,"response.data"),"."),l.default.createElement(i.CompleteBranch,{name:"08-nav-vue"}),l.default.createElement(c.default,{id:"github/pshrmn/curi-tutorial/tree/08-nav-vue"})),l.default.createElement(s.Section,{title:"Next",id:"next"},l.default.createElement("p",null,'Our book component still isn\'t complete. We are building a book store after all, so we should really provide the user a way to actually "buy" a book. In'," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"08-nav-vue"}},"Part 8: Forms & Navigation"),', we will add the ability to add books to a shopping cart and "purchase" them from our "Checkout" route.')))};t.default=d},75:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),o=n(1),r=a(n(60)),i=n(64),u=n(2),s=n(9),c=n(8),d=a(n(58)),m=function(){return l.default.createElement(r.default,null,l.default.createElement("h1",null,"Part 8: Forms & Programmatic Navigation"),l.default.createElement("p",null,"In this tutorial, we are going to be using another property of our Curi router: ",l.default.createElement(u.InlineJS,null,"history"),". This property is our Hickory history instance. We will use it to perform navigation between pages in our website."),l.default.createElement(i.Outline,null,l.default.createElement("ul",null,l.default.createElement("li",null,"Creating another fake API, this time for getting/setting items in our shopping cart."),l.default.createElement("li",null,'Adding the ability to add books to the shopping cart from the "Book" page.'),l.default.createElement("li",null,'Displaying books in the shopping cart from the "Checkout" page and allowing users to "purchase" their selected books.'),l.default.createElement("li",null,"Performing programmatic navigation to automatically navigate to another location."))),l.default.createElement(i.TutorialBranch,{name:"08-nav-react"}),l.default.createElement(c.Section,{id:"A Little Babel",title:"babel"},l.default.createElement("p",null,"Up until now, we have used stateless functional React components. In this tutorial, we will be using classes (extending"," ",l.default.createElement(u.InlineJS,null,"React.Component"),"). To help us, we will be taking advantage of some class properties, so we need to install the propert Babel plugin to support this and add it to our Babel configuration."),l.default.createElement(u.PrismBlock,{lang:"bash"},"npm install --save-dev @babel/plugin-proposal-class-properties"),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// .babelrc.js\nmodule.exports = {\n  // ...,\n  plugins: ['@babel/proposal-class-properties']\n};\n")),l.default.createElement(c.Section,{title:"The (Fake) API",id:"API"},l.default.createElement("p",null,"Since we do not have a backend to store the books that a user wants to purchase, we will simulate this using ",l.default.createElement(u.InlineJS,null,"localStorage"),". This will be done by maintaining an object whose keys are book ",l.default.createElement(u.InlineJS,null,"id"),"s and whose values is how many of that book should be purchased."),l.default.createElement("p",null,"Our API should export three methods: the first will get the current state of the shopping cart, the second will update the shopping cart, and the third will reset the shopping cart."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/api/shoppingCart.js\nfunction saveCart(cart) {\n  localStorage.setItem('cart', JSON.stringify(cart));\n}\n\n// read from localStorage and parse the value\nexport function getCart() {\n  let cart = JSON.parse(localStorage.getItem('cart'));\n  // initialize cart if it doesn't already exist\n  if (cart == null) {\n    cart = {};\n    saveCart(cart);\n  }\n  return Promise.resolve(cart);\n}\n\n// add the book and count to the cart\nexport function updateCart(bookID, count) {\n  return getCart()\n    .then(cart => {\n      cart[bookID] = count;\n      saveCart(cart);\n      return cart;\n    });\n}\n\n// reset the cart to an empty object\nexport function resetCart() {\n  const cart = {};\n  saveCart(cart);\n}"),l.default.createElement(s.Note,null,"We are using ",l.default.createElement(u.InlineJS,null,"localStorage"),", which is synchronous, but our API functions return Promises to simulate having to make these requests to the server."),l.default.createElement("p",null,'We will need to access this API in two places. Our "Book" pages need to use ',l.default.createElement(u.InlineJS,null,"updateCart"),' in order to add books to the shopping cart. The "Checkout" page need to know which books (and how many of each) are currently in the shopping cart. The page should also clear the cart out after a user has "purchased" the book in their shopping cart.')),l.default.createElement(c.Section,{title:"Adding Books to the Shopping Cart",id:"add-books"},l.default.createElement("p",null,'On the "Book" page, users should be able to specify how many copies of a book they want to purchase and add those to their shopping cart. We will do this by adding a new component, ',l.default.createElement(u.InlineComponent,null,"AddToCart"),"."),l.default.createElement("p",null,"We can start by creating a component with renders a ",l.default.createElement(u.InlineComponent,null,"select"),". Users can buy 1-4 copies of a book (an arbitrary restriction), so we need an ",l.default.createElement(u.InlineComponent,null,"option")," for each possible value. We should also add an"," ",l.default.createElement(u.InlineJS,null,"onChange")," handler to update the ",l.default.createElement(u.InlineComponent,null,"select")," when the user changes the value."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/components/AddToCart.js\nimport React from 'react';\n\nclass AddToCart extends React.Component {\n  state = { count: 1 }\n\n  updateSelect = (event) => {\n    this.setState({ count: parseInt(event.target.value, 10) })\n  }\n\n  render() {\n    return (\n      <form>\n        <select value={this.state.count} onChange={this.updateSelect}>\n          <option value='1'>1</option>\n          <option value='2'>2</option>\n          <option value='3'>3</option>\n          <option value='4'>4</option>\n        </select>\n      </form>\n    );\n  }\n}\n\nexport default AddToCart;"),l.default.createElement("p",null,'Next, we need to add a button to add the book to the shopping cart. We\'re actually going to add two buttons. The first will just add the book/count to the shopping cart. The second will add the book/count to the shopping cart and then redirect to the "Checkout" page.'),l.default.createElement("p",null,"How will we redirect? So far, all navigation within the website has been performed using ",l.default.createElement(u.InlineComponent,null,"Link"),"s. However, sometimes you might want to navigate programmatically. To do this, we can take advantage of our Hickory history object. The history object has ",l.default.createElement(u.InlineJS,null,"push"),","," ",l.default.createElement(u.InlineJS,null,"replace"),", and ",l.default.createElement(u.InlineJS,null,"update")," methods that we can call to trigger navigation. You can read about each of these in the"," ",l.default.createElement("a",{href:"https://github.com/pshrmn/hickory/blob/master/docs/api/Browser.md#methods"},"Hickory documentation"),". For this tutorial, we will be using ",l.default.createElement(u.InlineJS,null,"push"),"."),l.default.createElement("p",null,"In order to access the router from within our component we will use the"," ",l.default.createElement(u.InlineComponent,null,"Curious")," component from ",l.default.createElement(u.InlineJS,null,"@curi/react"),"."," ",l.default.createElement(u.InlineComponent,null,"Curious")," helps you to inject the Curi props (",l.default.createElement(u.InlineJS,null,"router"),","," ",l.default.createElement(u.InlineJS,null,"response"),", and ",l.default.createElement(u.InlineJS,null,"navigation"),") into a component. That means that we can inject our ",l.default.createElement(u.InlineJS,null,"router")," and call"," ",l.default.createElement(u.InlineJS,null,"router.history.push")," (a bit of a mouthful) to automatically redirect to another page."),l.default.createElement("p",null,"We can also access all of our Curi ",l.default.createElement(u.InlineJS,null,"addons")," from our router, so we will use ",l.default.createElement(u.InlineJS,null,"curi.addons.pathname")," to generate the pathname for the location that we wan to redirect to."),l.default.createElement("p",null,"When the user clicks either of the buttons, we will want to use the"," ",l.default.createElement(u.InlineJS,null,"updateCart")," API method to add the book to the shopping cart. The ",l.default.createElement(u.InlineComponent,null,"AddToCart")," component doesn't inherently know which book it is for, so we will need to pass it the ",l.default.createElement(u.InlineJS,null,"id")," of the book as a prop when we render it."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/components/AddToCart.js\nimport React from 'react';\nimport { Curious } from '@curi/react';\n\nimport { updateCart } from '../api/shoppingCart';\n\nclass AddToCart extends React.Component {\n\n  state = { count: 1 }\n\n  updateSelect = (event) => {\n    this.setState({ count: parseInt(event.target.value, 10) })\n  }\n\n  addToCart = () => {\n    updateCart(this.props.bookID, this.state.count);\n  }\n\n  addAndCheckout = () => {\n    const { router, bookID } = this.props;\n    updateCart(bookID, this.state.count)\n      .then(() => {\n        // generate the pathname for the Checkout route and then\n        // navigate to there automatically\n        const pathname = router.addons.pathname('Checkout');\n        router.history.push({ pathname });\n      });\n  }\n\n  render() {\n    return (\n      <form>\n        <select value={this.state.count} onChange={this.updateSelect}>\n          <option value='1'>1</option>\n          <option value='2'>2</option>\n          <option value='3'>3</option>\n          <option value='4'>4</option>\n        </select>\n        <button type=\"button\" onClick={this.addToCart}>\n          Add To Cart\n        </button>\n        <button type=\"button\" onClick={this.addAndCheckout}>\n          Add To Cart and Checkout\n        </button>\n      </form>\n    );\n  }\n}\n\nexport default props => (\n  <Curious render={({ router }) => (\n    <AddToCart router={router} {...props} />\n  )} />\n);"),l.default.createElement("p",null,"Now, we can modify our ",l.default.createElement(u.InlineComponent,null,"Book")," component to render the"," ",l.default.createElement(u.InlineComponent,null,"AddToCart")," component. Remember that we need to pass it a"," ",l.default.createElement(u.InlineJS,null,"bookID")," prop so that we can know which book to add to the shopping cart."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/components/Book.js\nimport React from 'react';\n\nimport AddToCart from './AddToCart';\n\nconst Book = (props) => {\n  const { data } = props.response;\n  if (!data) {\n    return (\n      <div className='book'>\n        The requested book does not exist\n      </div>\n    );\n  }\n  const { book } = data;\n  return (\n    <div className='book'>\n      <h2>{book.title}</h2>\n      <p>By {book.author}</p>\n      <p>Published in {book.published}</p>\n      <p>This book is {book.pages} pages</p>\n      <AddToCart bookID={book.id} />\n    </div>\n  );\n};\n\nexport default Book;")),l.default.createElement(c.Section,{title:"The Checkout Page",id:"checkout"},l.default.createElement("p",null,'Now that we can add books to our shopping cart, we also should give the user the ability to buy them. Of course, this isn\'t a real store website that we are building, so instead of asking for payment and shipping information, we will just redirect the user once they "purchase" their books.'),l.default.createElement("p",null,"Let's start out in our ",l.default.createElement(u.InlineJS,null,"routes.js"),' file. We want our "Checkout" page to know which books are in the shopping cart. We can use the'," ",l.default.createElement(u.InlineJS,null,"match.every"),' function of the "Checkout" route to load all of the books and our shopping cart. We can merge the two together to create an array of items in the cart.'),l.default.createElement("p",null,'While we\'re at it, we should also add one more route to our website. This will be a "Checkout Complete" route that we redirect to after a user has "purchased" their books.'),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/routes.js\nimport CheckoutComplete from './components/CheckoutComplete';\n\nimport { getCart } from './api/shoppingCart';\n\nconst routes = [\n  // ...\n  {\n    name: 'Checkout',\n    path: 'checkout',\n    match: {\n      every: () => {\n        return Promise.all([\n          fetchAllBooks(),\n          getCart()\n        ]);\n      },\n      response: ({ resolved, set }) => {\n        set.body(Checkout)\n\n        /*\n         * We will iterate over all of the items in\n         * our shopping cart and find the matching\n         * book. Then, we combine the book and the\n         * number being purchased into one object.\n         *\n         * We then assign that array of objects as\n         * the \"items\" property of our response's\n         * data object.\n         */\n        const [ books, cart ] = resolved.every;\n        const items = Object.keys(cart).map(key => {\n          const id = parseInt(key, 10);\n          const count = cart[key];\n          const book = books.find(b => b.id === id);\n          return Object.assign({}, book, { count });\n        });\n        set.data({ items });\n      }\n    },\n    children: [\n      {\n        name: 'Checkout Complete',\n        path: 'complete',\n        match: {\n          response: ({ set }) => {\n            set.body(CheckoutComplete);\n          }\n        }\n      }\n    ]\n  }\n  // ...\n];"),l.default.createElement("p",null,"Before we update our ",l.default.createElement(u.InlineComponent,null,"Checkout")," component, let's write the"," ",l.default.createElement(u.InlineComponent,null,"CheckoutComplete")," component. This should just be a simple component thanking the user for their purchase."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/components/CheckoutComplete.js\nimport React from 'react';\n\nconst CheckoutComplete = () => (\n  <div className='checkout-complete'>\n    Thanks for your purchase!\n  </div>\n);\n\nexport default CheckoutComplete;"),l.default.createElement("p",null,"We aren't going to get too fancy with displaying the items in our shopping cart. We can just place them all in a ",l.default.createElement(u.InlineComponent,null,"table"),' so that they are neatly organized. Then, we will just need to add a button to "purchase" the books.'),l.default.createElement("p",null,"We will once again be taking advantage of the ",l.default.createElement(u.InlineJS,null,"Curious")," ","component to access our Curi router from within a component."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/components/Checkout.js\nimport React from 'react';\nimport { Curious } from '@curi/react';\n\nimport { resetCart } from '../api/shoppingCart';\n\nclass Checkout extends React.Component {\n\n  purchase = () => {\n    // when the user \"purchases\" their books, we just\n    // reset the cart and redirect to the \"Checkout Complete\" page\n    resetCart();\n    const { router } = this.props;\n    const pathname = router.addons.pathname('Checkout Complete');\n    router.history.push({ pathname });\n  }\n\n  render() {\n    const { response } = this.props;\n    return (\n      <div className='checkout'>\n        <h1>Checkout</h1>\n        <div>\n          <table>\n            <thead>\n              <tr>\n                <td>Book</td>\n                <td>Quantity</td>\n              </tr>\n            </thead>\n            <tbody>\n              {\n                response.data.items.map(book => (\n                  <tr key={book.id}>\n                    <td>{book.title}</td>\n                    <td>{book.count}</td>\n                  </tr>\n                ))\n              }\n            </tbody>\n          </table>\n          <button type='button' onClick={this.purchase}>\n            Purchase Books\n          </button>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default props => (\n  <Curious render={({ router }) => (\n    <Checkout router={router} {...props} />\n  )} />\n);"),l.default.createElement("p",null,"One last thing to consider about our ",l.default.createElement(u.InlineComponent,null,"Checkout")," component is what we should display when there are no items in the shopping cart. We can just check our ",l.default.createElement(u.InlineJS,null,"response.data.items")," array and display a message stating that the cart is empty when the list's length is zero."),l.default.createElement(u.PrismBlock,{lang:"jsx"},"// src/component/Checkout.js\nclass Checkout extends React.Component {\n  // ...\n  render() {\n    const { response } = this.props;\n    if (!response.data.items.length) {\n      return (\n        <div className='checkout'>\n          <h1>Checkout</h1>\n          <div>\n            You have not added any items to your shopping cart!\n          </div>\n        </div>\n      )\n    }\n    // ...\n  }\n}")),l.default.createElement(c.Section,{title:"Review",id:"review"},l.default.createElement("p",null,'We can now add books to our shopping cart and "buy" them from the checkout page.'),l.default.createElement(i.CompleteBranch,{name:"09-now-what-react"}),l.default.createElement(d.default,{id:"github/pshrmn/curi-tutorial/tree/09-now-what-react"}),l.default.createElement(s.Note,null,"The embedded sandbox will not work if your browser is blocking third-party data. If this is the case for you, you ",l.default.createElement("em",null,"could")," ",'disable this through your browser\'s settings, but a better solution is to click the "Edit on CodeSandbox" button to view the sandbox there.')),l.default.createElement(c.Section,{title:"Next",id:"next"},l.default.createElement("p",null,"With that, we have considered pretty much everything you need to know to get started building your website with Curi. We have one last part,"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"09-now-what"}},"Part 9: Now What?"),", that gives some suggestions on what you can do with your new knowledge.")))};t.default=m},76:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),o=n(1),r=a(n(60)),i=n(64),u=n(2),s=n(9),c=n(8),d=a(n(58)),m=function(){return l.default.createElement(r.default,null,l.default.createElement("h1",null,"Part 8: Forms & Programmatic Navigation"),l.default.createElement("p",null,"In this tutorial, we are going to be using another property of our Curi router: ",l.default.createElement(u.InlineJS,null,"history"),". This property is the Hickory history instance. We will use it to perform navigation between pages in our website."),l.default.createElement(i.Outline,null,l.default.createElement("ul",null,l.default.createElement("li",null,"Creating another fake API, this time for getting/setting items in our shopping cart."),l.default.createElement("li",null,'Adding the ability to add books to the shopping cart from the "Book" page.'),l.default.createElement("li",null,'Displaying books in the shopping cart from the "Checkout" page and allowing users to "purchase" their selected books.'),l.default.createElement("li",null,"Performing programmatic navigation to automatically navigate to another location."))),l.default.createElement(i.TutorialBranch,{name:"08-nav-vue"}),l.default.createElement(c.Section,{title:"The (Fake) API",id:"API"},l.default.createElement("p",null,"Since we do not have a backend to store the books that a user wants to purchase, we will simulate this using ",l.default.createElement(u.InlineJS,null,"localStorage"),". This will be done by maintaining an object whose keys are book ",l.default.createElement(u.InlineJS,null,"id"),"s and whose values is how many of that book should be purchased."),l.default.createElement("p",null,"Our API should export three methods: the first will get the current state of the shopping cart, the second will update the shopping cart, and the third will reset the shopping cart."),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/api/shoppingCart.js\nfunction saveCart(cart) {\n  localStorage.setItem('cart', JSON.stringify(cart));\n}\n\n// read from localStorage and parse the value\nexport function getCart() {\n  let cart = JSON.parse(localStorage.getItem('cart'));\n  // initialize cart if it doesn't already exist\n  if (cart == null) {\n    cart = {};\n    saveCart(cart);\n  }\n  return Promise.resolve(cart);\n}\n\n// add the book and count to the cart\nexport function updateCart(bookID, count) {\n  return getCart()\n    .then(cart => {\n      cart[bookID] = count;\n      saveCart(cart);\n      return cart;\n    });\n}\n\n// reset the cart to an empty object\nexport function resetCart() {\n  const cart = {};\n  saveCart(cart);\n}"),l.default.createElement(s.Note,null,"We are using ",l.default.createElement(u.InlineJS,null,"localStorage"),", which is synchronous, but our API functions return Promises to simulate having to make these requests to the server."),l.default.createElement("p",null,'We will need to access this API in two places. Our "Book" pages need to use ',l.default.createElement(u.InlineJS,null,"updateCart"),' in order to add books to the shopping cart. The "Checkout" page need to know which books (and how many of each) are currently in the shopping cart. The page should also clear the cart out after a user has "purchased" the book in their shopping cart.')),l.default.createElement(c.Section,{title:"Adding Books to the Shopping Cart",id:"add-books"},l.default.createElement("p",null,'On the "Book" page, users should be able to specify how many copies of a book they want to purchase and add those to their shopping cart. We will do this by adding a new component, ',l.default.createElement(u.InlineComponent,null,"AddToCart"),"."),l.default.createElement("p",null,"We can start by creating a component with renders a ",l.default.createElement(u.InlineComponent,null,"select"),". Users can buy 1-4 copies of a book (an arbitrary restriction), so we need an ",l.default.createElement(u.InlineComponent,null,"option")," for each possible value."),l.default.createElement(u.PrismBlock,{lang:"html"},'\x3c!-- src/components/AddToCart.vue --\x3e\n<template>\n  <form>\n    <select v-model="count">\n      <option value="1">1</option>\n      <option value="2">2</option>\n      <option value="3">3</option>\n      <option value="4">4</option>\n    </select>\n  </form>\n</template>\n\n<script>\n  export default {\n    data: function() {\n      return {\n        count: \'1\'\n      };\n    }\n  };\n<\/script>\n'),l.default.createElement("p",null,'Next, we need to add a button to add the book to the shopping cart. We\'re actually going to add two buttons. The first will just add the book/count to the shopping cart. The second will add the book/count to the shopping cart and then redirect to the "Checkout" page.'),l.default.createElement("p",null,"How will we redirect? So far, all navigation within the website has been performed using ",l.default.createElement(u.InlineComponent,null,"curi-link"),"s. However, sometimes you might want to navigate programmatically. To do this, we can take advantage of our Hickory history object. The history object has ",l.default.createElement(u.InlineJS,null,"push"),","," ",l.default.createElement(u.InlineJS,null,"replace"),", and ",l.default.createElement(u.InlineJS,null,"update")," methods that we can call to trigger navigation. You can read about each of these in the"," ",l.default.createElement("a",{href:"https://github.com/pshrmn/hickory/blob/master/docs/api/Browser.md#methods"},"Hickory documentation"),". For this tutorial, we will be using ",l.default.createElement(u.InlineJS,null,"push"),"."),l.default.createElement("p",null,"The ",l.default.createElement(u.InlineJS,null,"CuriPlugin")," makes our router available to all of our components as ",l.default.createElement(u.InlineJS,null,"this.$router"),". That means that we can call"," ",l.default.createElement(u.InlineJS,null,"this.$router.history.push")," (a bit of a mouthful) to automatically redirect to another page."),l.default.createElement("p",null,"We can also access all of our Curi ",l.default.createElement(u.InlineJS,null,"addons")," from our router, so we will use ",l.default.createElement(u.InlineJS,null,"curi.addons.pathname")," to generate the pathname for the location that we wan to redirect to."),l.default.createElement("p",null,"When the user clicks either of the buttons, we will want to use the"," ",l.default.createElement(u.InlineJS,null,"updateCart")," API method to add the book to the shopping cart. The ",l.default.createElement(u.InlineComponent,null,"AddToCart")," component doesn't inherently know which book it is for, so we will need to pass it the ",l.default.createElement(u.InlineJS,null,"id")," of the book as a prop when we render it."),l.default.createElement(u.PrismBlock,{lang:"html"},'\x3c!-- src/components/AddToCart.vue --\x3e\n<template>\n  <form>\n    <select v-model="count">\n      <option value="1">1</option>\n      <option value="2">2</option>\n      <option value="3">3</option>\n      <option value="4">4</option>\n    </select>\n    <button type="button" v-on:click="addToCart">Add To Cart</button>\n    <button type="button" v-on:click="addAndCheckout">Add To Cart and Checkout</button>\n  </form>\n</template>\n\n<script>\n  import { updateCart } from \'../api/shoppingCart\';\n\n  export default {\n    props: [\'bookID\'],\n    data: function() {\n      return {\n        count: \'1\'\n      };\n    },\n    methods: {\n      addToCart(event) {\n        updateCart(this.bookID, parseInt(this.count));\n      },\n      addAndCheckout(event) {\n        updateCart(this.bookID, parseInt(this.count))\n          .then(() => {\n            const pathname = this.$router.addons.pathname(\'Checkout\');\n            this.$router.history.push({ pathname });\n          });\n      }\n    }\n  };\n<\/script>\n'),l.default.createElement("p",null,"Now, we can modify our ",l.default.createElement(u.InlineComponent,null,"Book")," component to render the"," ",l.default.createElement(u.InlineComponent,null,"AddToCart")," component. Remember that we need to pass it a"," ",l.default.createElement(u.InlineJS,null,"bookID")," prop so that we can know which book to add to the shopping cart."),l.default.createElement(u.PrismBlock,{lang:"html"},"\x3c!-- src/components/Book.vue --\x3e\n<template>\n  <div v-if=\"$curi.response.error\" class='book'>\n    {{error}}\n  </div>\n  <div v-else class='book'>\n    <h2>{{book.title}}</h2>\n    <p>By {{book.author}}</p>\n    <p>Published in {{book.published}}</p>\n    <p>This book is {{book.pages}} pages</p>\n    <AddToCart :bookID=\"book.id\" />\n  </div>\n</template>\n\n<script>\n  import AddToCart from './AddToCart';\n\n  export default {\n    computed: {\n      book: function() {\n        const { response } = this.$curi;\n        return !response.error && response.data.book;\n      }\n    },\n    components: { AddToCart }\n  };\n<\/script>")),l.default.createElement(c.Section,{title:"The Checkout Page",id:"checkout"},l.default.createElement("p",null,'Now that we can add books to our shopping cart, we also should give the user the ability to buy them. Of course, this isn\'t a real store website that we are building, so instead of asking for payment and shipping information, we will just redirect the user once they "purchase" their books.'),l.default.createElement("p",null,"Let's start out in our ",l.default.createElement(u.InlineJS,null,"routes.js"),' file. We want our "Checkout" page to know which books are in the shopping cart. We can use the'," ",l.default.createElement(u.InlineJS,null,"match.every"),' function of the "Checkout" route to load all of the books and our shopping cart. We can merge the two together to create an array of items in the cart.'),l.default.createElement("p",null,'While we\'re at it, we should also add one more route to our website. This will be a "Checkout Complete" route that we redirect to after a user has "purchased" their books.'),l.default.createElement(u.PrismBlock,{lang:"javascript"},"// src/routes.js\nimport CheckoutComplete from './components/CheckoutComplete';\n\nimport { getCart } from './api/shoppingCart';\n\nconst routes = [\n  // ...\n  {\n    name: 'Checkout',\n    path: 'checkout',\n    match: {\n      every: () => {\n        return Promise.all([\n          fetchAllBooks(),\n          getCart()\n        ])\n      },\n      response: ({ resolved, set }) => {\n        set.body(Checkout);\n\n        /*\n         * We will iterate over all of the items in\n         * our shopping cart and find the matching\n         * book. Then, we combine the book and the\n         * number being purchased into one object.\n         *\n         * We then assign that array of objects as\n         * the \"items\" property of our response's\n         * data object.\n         */\n        const [ books, cart ] = resolved.every;\n        const items = Object.keys(cart).map(key => {\n          const id = parseInt(key, 10);\n          const count = cart[key];\n          const book = books.find(b => b.id === id);\n          return Object.assign({}, book, { count });\n        });\n        set.data({ items });\n      }\n    },\n    children: [\n      {\n        name: 'Checkout Complete',\n        path: 'complete',\n        match: {\n          response: ({ set }) => {\n            set.body(CheckoutComplete);\n          }\n        }\n      }\n    ]\n  }\n  // ...\n];"),l.default.createElement("p",null,"Before we update our ",l.default.createElement(u.InlineComponent,null,"Checkout")," component, let's write the"," ",l.default.createElement(u.InlineComponent,null,"CheckoutComplete")," component. This should just be a simple component thanking the user for their purchase."),l.default.createElement(u.PrismBlock,{lang:"html"},"\x3c!-- src/components/CheckoutComplete.vue --\x3e\n<template>\n  <div className='checkout-complete'>\n    Thanks for your purchase!\n  </div>\n</template>"),l.default.createElement("p",null,"We aren't going to get too fancy with displaying the items in our shopping cart. We can just place them all in a ",l.default.createElement(u.InlineComponent,null,"table"),' so that they are neatly organized. Then, we will just need to add a button to "purchase" the books.'),l.default.createElement("p",null,"We will once again be taking advantage of ",l.default.createElement(u.InlineJS,null,"this.$curi")," to access our Curi router from within a component."),l.default.createElement(u.PrismBlock,{lang:"html"},'\x3c!-- src/components/Checkout.vue --\x3e\n<template>\n  <div class=\'checkout\'>\n    <h1>Checkout</h1>\n    <div>\n      <table>\n        <thead>\n          <tr>\n            <td>Book</td>\n            <td>Quantity</td>\n          </tr>\n        </thead>\n        <tbody>\n          <tr v-for="book in $curi.response.data.items" :key="book.id">\n            <td>{{book.title}}</td>\n            <td>{{book.count}}</td>\n          </tr>\n        </tbody>\n      </table>\n      <button type=\'button\' v-on:click="purchase">\n        Purchase Books\n      </button>\n    </div>\n  </div>\n</template>\n\n<script>\n  import { resetCart } from \'../api/shoppingCart\';\n\n  export default {\n    methods: {\n      purchase: function(event) {\n        // when the user "purchases" their books, we just\n        // reset the cart and redirect to the "Checkout Complete" page\n        resetCart();\n        const pathname = this.$router.addons.pathname(\'Checkout Complete\');\n        this.$router.history.push({ pathname });\n      }\n    }\n  };\n<\/script>'),l.default.createElement("p",null,"One last thing to consider about our ",l.default.createElement(u.InlineComponent,null,"Checkout")," component is what we should display when there are no items in the shopping cart. We can just check our ",l.default.createElement(u.InlineJS,null,"response.data.items")," array and display a message stating that the cart is empty when the list's length is zero."),l.default.createElement(u.PrismBlock,{lang:"html"},'\x3c!-- src/component/Checkout.vue --\x3e\n<template>\n  <div class=\'checkout\'>\n    <h1>Checkout</h1>\n    <div v-if="$curi.response.data.items.length">\n      <table>\n        <thead>\n          <tr>\n            <td>Book</td>\n            <td>Quantity</td>\n          </tr>\n        </thead>\n        <tbody>\n          <tr v-for="book in response.data.items" :key="book.id">\n            <td>{{book.title}}</td>\n            <td>{{book.count}}</td>\n          </tr>\n        </tbody>\n      </table>\n      <button type=\'button\' v-on:click="purchase">\n        Purchase Books\n      </button>\n    </div>\n    <div v-else>\n      You have not added any items to your shopping cart!\n    </div>\n  </div>\n</template>')),l.default.createElement(c.Section,{title:"Review",id:"review"},l.default.createElement("p",null,'We can now add books to our shopping cart and "buy" them from the checkout page.'),l.default.createElement(i.CompleteBranch,{name:"09-now-what-vue"}),l.default.createElement(d.default,{id:"github/pshrmn/curi-tutorial/tree/09-now-what-vue"}),l.default.createElement(s.Note,null,"The embedded sandbox will not work if your browser is blocking third-party data. If this is the case for you, you ",l.default.createElement("em",null,"could")," ",'disable this through your browser\'s settings, but a better solution is to click the "Edit on CodeSandbox" button to view the sandbox there.')),l.default.createElement(c.Section,{title:"Next",id:"next"},l.default.createElement("p",null,"With that, we have considered pretty much everything you need to know to get started building your website with Curi. We have one last part,"," ",l.default.createElement(o.Link,{to:"Tutorial",params:{name:"09-now-what"}},"Part 9: Now What?"),", that gives some suggestions on what you can do with your new knowledge.")))};t.default=m},77:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),o=n(1),r=a(n(60)),i=n(2),u=(n(9),n(8),function(){return l.default.createElement(r.default,null,l.default.createElement("h1",null,"Part 10: Now What?"),l.default.createElement("p",null,"This is the end. You have completed all of the parts of the tutorial and have built a website powered by Curi. It isn't a complete site, but it works, and hopefully you learned a lot while we built it."),l.default.createElement("p",null,"Thanks for following along! If you have any questions or comments, you can reach out to me on Twitter"," ",l.default.createElement("a",{href:"https://twitter.com/pshrmn"},"@pshrmn"),". Any feedback is appreciated!"),l.default.createElement("p",null,"Now, you may be wondering what else to do. My first suggestion would be to build your own website! The tutorial went through everything you need to know to get started building a site with Curi, so why not build your own?"),l.default.createElement("p",null,"If you are looking to learn/build more, you can also try some of the suggestions listed below."),l.default.createElement("ol",null,l.default.createElement("li",null,'The current home page is quite boring. You could add a "featured" book to it using the "Home" route\'s ',l.default.createElement(i.InlineJS,null,"match.response")," function to attach a random book to the response."),l.default.createElement("li",null,"Similar to the previous suggestion, the contact page could use some work as well. Perhaps you could add some child routes for different methods of contact."),l.default.createElement("li",null,"You can try using a Curi"," ",l.default.createElement(o.Link,{to:"Guide",params:{slug:"side-effects"}},"side effect")," ","with the website. You could use"," ",l.default.createElement(o.Link,{to:"Package",params:{package:"side-effect-title"}},l.default.createElement(i.InlineJS,null,"@curi/side-effect-title"))," ","and the ",l.default.createElement(i.InlineJS,null,"route.title")," property to update the title whenever you navigate."),l.default.createElement("li",null,"If you're concerned about the bundle size, you could check out the"," ",l.default.createElement(o.Link,{to:"Guide",params:{slug:"code-splitting"}},"code splitting guide")," ","and break up the bundle using ",l.default.createElement(i.InlineJS,null,"route.match.initial"),"."),l.default.createElement("li",null,"While we used ",l.default.createElement(i.InlineJS,null,"response.data")," to pass data to our components, you might prefer a global store like Redux or Vuex. You could rewrite the application to use these, ",l.default.createElement(i.InlineJS,null,"response.data")," is a convenience, not a requirement. You can even continue to use"," ",l.default.createElement(i.InlineJS,null,"match.response")," with a global store. Instead of calling"," ",l.default.createElement(i.InlineJS,null,"set.data"),", you could just dispatch the data to your store. You can check out the"," ",l.default.createElement(o.Link,{to:"Example",params:{category:"react",slug:"redux"}},"Redux example")," ","to see how this might be implemented."),l.default.createElement("li",null,"You can explore the other response methods available in"," ",l.default.createElement(i.InlineJS,null,"match.response"),". For example, you could use the"," ",l.default.createElement(i.InlineJS,null,"redirect"),' function to automatically redirect when the user attempt to navigate to a "Book" page that doesn\'t exist (e.g. there is no book whose ',l.default.createElement(i.InlineJS,null,"id")," equals ",l.default.createElement(i.InlineJS,null,"params.id"),")."),l.default.createElement("li",null,'We only had ten books in our data, but what if there were hundreds? You could implement pagination on the "Book List" page. Query params could be included in the location to only display certain books. If you\'re feeling adventurous, you could pass a'," ",l.default.createElement("a",{href:"https://github.com/pshrmn/hickory/blob/master/docs/api/Browser.md#options"},l.default.createElement(i.InlineJS,null,"query")," object")," ","to your history object to use query objects instead of strings."),l.default.createElement("li",null,"You can read through the"," ",l.default.createElement(o.Link,{to:"Guide",params:{slug:"getting-started"}},"guides"),", browse the ",l.default.createElement(o.Link,{to:"Examples"},"examples"),", and check out the available Curi ",l.default.createElement(o.Link,{to:"Packages"},"packages"),". This tutorial covered what you need to know to get started, but there is plenty more you can dive into for advanced usage.")))});t.default=u}});