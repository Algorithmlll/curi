<!doctype html>
<html>
  <head>
    <link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Curi | Curi Documentation</title>
    <link href="https://fonts.googleapis.com/css?family=Zilla+Slab:300,400" rel="stylesheet">
    <link href="/static/css/index.css" rel="stylesheet">
  </head>
  <body>
    <div id="root"><div data-reactroot="" data-reactid="1" data-react-checksum="2138914680"><header data-reactid="2"><nav data-reactid="3"><ul data-reactid="4"><li data-reactid="5"><a class="home-link" href="/" data-reactid="6">Curi</a></li><li data-reactid="7"><a href="/packages/" data-reactid="8">Packages</a></li><li data-reactid="9"><a href="/guides/getting-started/" data-reactid="10">Guides</a></li><li data-reactid="11"><a href="/examples/" data-reactid="12">Examples</a></li><li data-reactid="13"><a href="https://github.com/pshrmn/curi" data-reactid="14">GitHub</a></li></ul></nav></header><main data-reactid="15"><div data-reactid="16"><div class="banner" data-reactid="17"><h1 data-reactid="18">Curi</h1><p data-reactid="19">A single page application router for any JavaScript rendering library.</p><pre class="language-javascript" data-reactid="20">import Browser from &#x27;@hickory/browser&#x27;;
import createConfig from &#x27;@curi/core&#x27;;

// create your history object
const history = Browser();

// define your routes
const routes = [
  { name: &#x27;Home&#x27;, path: &#x27;&#x27;, ... },
  { name: &#x27;User&#x27;, path: &#x27;u/:userID&#x27;, ... },
  ...
];

// create your Curi configuration object
const config = createConfig(history, routes);

// wait for the first response to be generated
config.ready().then(response =&gt; {
  // and now, you&#x27;re ready to render
});</pre><p data-reactid="21"><!-- react-text: 22 -->Ready to learn more? Check out the<!-- /react-text --><!-- react-text: 23 --> <!-- /react-text --><a href="/guides/getting-started/" data-reactid="24">getting started</a><!-- react-text: 25 --> guide.<!-- /react-text --></p></div><div class="features" data-reactid="26"><h2 data-reactid="27">Features</h2><div class="feature" data-reactid="28"><h3 data-reactid="29">Easy React Integration</h3><p data-reactid="30">Curi is not just a React router, but React is currently the best supported rendering library for Curi.</p><div class="code" data-reactid="31"><div class="description" data-reactid="32"><p data-reactid="33"><!-- react-text: 34 -->Use the <!-- /react-text --><code class="language-javascript" data-reactid="35">body</code><!-- react-text: 36 --> property of routes to specify each route&#x27;s component:<!-- /react-text --></p></div><pre class="language-jsx" data-reactid="37">const Home = () =&gt; &lt;div&gt;Home&lt;/div&gt;;
const User = props =&gt; &lt;div&gt;User {props.params.userID}&lt;/div&gt;;
const NotFound = () =&gt; &lt;div&gt;Page not found...&lt;/div&gt;;

const routes = [
  { name: &#x27;Home&#x27;, path: &#x27;&#x27;, body: () =&gt; Home },
  { name: &#x27;User&#x27;, path: &#x27;u/:userID&#x27;, body: () =&gt; User },
  { name: &#x27;Not Found&#x27;, path: &#x27;*&#x27;, body: () =&gt; NotFound }
];</pre></div><div class="code" data-reactid="38"><div class="description" data-reactid="39"><p data-reactid="40"><code class="language-jsx" data-reactid="41"><!-- react-text: 42 -->&lt;<!-- /react-text --><!-- react-text: 43 -->Link<!-- /react-text --><!-- react-text: 44 -->&gt;<!-- /react-text --></code><!-- react-text: 45 -->s are used for navigating between locations within an application. URI formatting is handled for you, all you have to do is know the name (and parameters) of the route that you want to link to.<!-- /react-text --></p></div><pre class="language-jsx" data-reactid="46">import Link from &#x27;@curi/react-link&#x27;;

const Nav = () =&gt; (
  &lt;div&gt;
    &lt;Link to=&#x27;Home&#x27;&gt;Home&lt;/Link&gt;
    &lt;Link to=&#x27;User&#x27; params={{ userID: 4 }}&gt;User Four&lt;/Link&gt;
  &lt;/div&gt;
);</pre></div><div class="code" data-reactid="47"><div class="description" data-reactid="48"><p data-reactid="49"><!-- react-text: 50 -->The <!-- /react-text --><code class="language-jsx" data-reactid="51"><!-- react-text: 52 -->&lt;<!-- /react-text --><!-- react-text: 53 -->Navigator<!-- /react-text --><!-- react-text: 54 -->&gt;<!-- /react-text --></code><!-- react-text: 55 --> is responsible for re-rendering the application every time the location changes, using the <!-- /react-text --><code class="language-javascript" data-reactid="56">render</code><!-- react-text: 57 --> function.<!-- /react-text --></p></div><pre class="language-jsx" data-reactid="58">import Navigator from &#x27;@curi/react-navigator&#x27;;

ReactDOM.render((
  &lt;Navigator config={config} render={(response) =&gt; {
    const { body:Body } = response;
    return (
      &lt;div&gt;
        &lt;Nav /&gt;
        &lt;Body /&gt;
      &lt;/div&gt;
    );
  }}
));</pre></div><p data-reactid="59"><!-- react-text: 60 -->There are a number of other Curi + React components, but <!-- /react-text --><code class="language-jsx" data-reactid="61"><!-- react-text: 62 -->&lt;<!-- /react-text --><!-- react-text: 63 -->Navigator<!-- /react-text --><!-- react-text: 64 -->&gt;<!-- /react-text --></code><!-- react-text: 65 --> and<!-- /react-text --><!-- react-text: 66 --> <!-- /react-text --><code class="language-jsx" data-reactid="67"><!-- react-text: 68 -->&lt;<!-- /react-text --><!-- react-text: 69 -->Link<!-- /react-text --><!-- react-text: 70 -->&gt;<!-- /react-text --></code><!-- react-text: 71 --> are the only ones that you&#x27;ll need to be familiar with while getting started.. You can see the others via the<!-- /react-text --><!-- react-text: 72 --> <!-- /react-text --><a href="/packages/@curi/react/" data-reactid="73"><code class="language-javascript" data-reactid="74">@curi/react</code></a><!-- react-text: 75 --> page.<!-- /react-text --></p></div><div class="feature" data-reactid="76"><h3 data-reactid="77">Response Objects</h3><p data-reactid="78">Whenever the location changes (and on initial load), Curi will generate a response object with data on the matching route. The properties of this object are what you use to render your application.</p><div class="code" data-reactid="79"><div class="description" data-reactid="80"><p data-reactid="81"><!-- react-text: 82 -->There isn&#x27;t one &quot;right&quot; way to render using the response object, but it is useful for <!-- /react-text --><code class="language-javascript" data-reactid="83">body</code><!-- react-text: 84 --> to be a function that will render the content for the route. (The body property of a response is the value returned by calling the body property of a route.)<!-- /react-text --></p></div><pre class="language-javascript" data-reactid="85">{
  key: &#x27;123&#x27;,
  location: { pathname: &#x27;/u/456&#x27;, ... },
  status: 200,
  name: &#x27;User&#x27;,
  body: function() { return ... },
  params: { userID: &#x27;456&#x27; },
  data: {...},
  ...
}</pre></div></div><div class="feature" data-reactid="86"><h3 data-reactid="87"><!-- react-text: 88 -->Powerful Route Matching with <!-- /react-text --><code class="language-javascript" data-reactid="89">path-to-regexp</code></h3><p data-reactid="90"><!-- react-text: 91 -->Curi uses <!-- /react-text --><a href="https://github.com/pillarjs/path-to-regexp" data-reactid="92">path-to-regexp</a><!-- react-text: 93 --> <!-- /react-text --><!-- react-text: 94 -->to define route paths. This allows you to define route parameters that will be parsed from the URI and added to the response object (when the route matches).<!-- /react-text --></p><div class="code" data-reactid="95"><div class="description" data-reactid="96"><p data-reactid="97"><!-- react-text: 98 -->In the accompanying example code, when the <!-- /react-text --><code class="language-javascript" data-reactid="99">User</code><!-- react-text: 100 --> route matches, the response object&#x27;s <!-- /react-text --><code class="language-javascript" data-reactid="101">params</code><!-- react-text: 102 --> object will have an <!-- /react-text --><code class="language-javascript" data-reactid="103">id</code><!-- react-text: 104 --> property whose value is parsed from the URI.<!-- /react-text --></p><p data-reactid="105"><code class="language-javascript" data-reactid="106">path-to-regexp</code><!-- react-text: 107 --> offers a number of matching options, which you can learn more about from its documentation.<!-- /react-text --></p></div><pre class="language-javascript" data-reactid="108">const routes = [
  {
    name: &#x27;User&#x27;,
    // when the User route matches, the &quot;id&quot;
    // value will be parsed from the pathname
    // and placed in the &quot;params&quot; property of
    // the response
    path: &#x27;u/:id&#x27;
  }
];</pre></div></div><div class="feature" data-reactid="109"><h3 data-reactid="110">No Hassle Nested Routes</h3><div class="code" data-reactid="111"><div class="description" data-reactid="112"><p data-reactid="113"><!-- react-text: 114 -->For nested routes, you only have to define the additional URI segments. Those will automatically be joined with any ancestor routes for you. If any ancestor routes have path parameters, those will be included in the response&#x27;s<!-- /react-text --><!-- react-text: 115 --> <!-- /react-text --><code class="language-javascript" data-reactid="116">params</code><!-- react-text: 117 --> object.<!-- /react-text --></p></div><pre class="language-javascript" data-reactid="118">const routes = [
  {
    name: &#x27;Album&#x27;,
    path: &#x27;a/:albumID&#x27;,
    body: () =&gt; Album,
    children: [
      {
        name: &#x27;Song&#x27;,
        path: &#x27;:songID&#x27;,
        body: () =&gt; Song
      }
    ]
  }
]</pre></div><div class="code" data-reactid="119"><div class="description" data-reactid="120"><p data-reactid="121"><!-- react-text: 122 -->Given the above example routes, when a user visits the URI<!-- /react-text --><!-- react-text: 123 --> <!-- /react-text --><code class="language-javascript" data-reactid="124">/a/4815/162342</code><!-- react-text: 125 -->, we will get the following response object. The<!-- /react-text --><!-- react-text: 126 --> <!-- /react-text --><code class="language-javascript" data-reactid="127">partials</code><!-- react-text: 128 --> array contains the ancestor route <!-- /react-text --><code class="language-javascript" data-reactid="129">&quot;Song&quot;</code><!-- react-text: 130 -->, which makes it easy to identify &quot;active&quot; ancestor routes.<!-- /react-text --></p></div><pre class="language-javascript" data-reactid="131">// pathname = &#x27;/a/4815/162342&#x27;
{
  body: Song,
  params: { albumID: &#x27;4815&#x27;, songID: &#x27;162342&#x27; },
  name: &#x27;Song&#x27;,
  partials: [&#x27;Album&#x27;],
  ...
}
</pre></div></div><div class="feature" data-reactid="132"><h3 data-reactid="133">Simple Code Splitting</h3><div class="code" data-reactid="134"><div class="description" data-reactid="135"><p data-reactid="136"><!-- react-text: 137 -->Use the <!-- /react-text --><code class="language-javascript" data-reactid="138">preload</code><!-- react-text: 139 --> and <!-- /react-text --><code class="language-javascript" data-reactid="140">body</code><!-- react-text: 141 --> properties to add code splitting at your routes.<!-- /react-text --></p><p data-reactid="142"><strong data-reactid="143">Note:</strong><!-- react-text: 144 --> This relies on a bundler like Webpack.<!-- /react-text --></p></div><pre class="language-javascript" data-reactid="145">const store = {};

const routes = [
  {
    name: &#x27;User&#x27;,
    path: &#x27;users/:userID&#x27;,
    preload: () =&gt; import(&#x27;./components/User&#x27;)
      .then(module =&gt; { store[&#x27;User&#x27;] = module.default; }),
    body: () =&gt; store[&#x27;User&#x27;]
  }
  ...,
]</pre></div></div><div class="feature" data-reactid="146"><h3 data-reactid="147">Straightforward Server Side Rendering</h3><div class="code" data-reactid="148"><div class="description" data-reactid="149"><p data-reactid="150">Server side rendering is pretty much the same as client side rendering. The main difference is that you will use an in-memory history instead of a browser history.</p><p data-reactid="151"><!-- react-text: 152 -->Use <!-- /react-text --><code class="language-javascript" data-reactid="153">config.ready</code><!-- react-text: 154 --> to wait for the response object to be created, then render using the response object that that resolves with.<!-- /react-text --></p></div><pre class="language-javascript" data-reactid="155">import InMemory from &#x27;@hickory/in-memory&#x27;;

function requestHandler(req, resp) {
  // create a history using the requested location
  const history = InMemory({ locations: [req.url] });
  const config = createConfig(history, routes);

  config.ready().then(response =&gt; {
    // render the markup. This will vary based on your
    // rendering library, but here we&#x27;ll use React
    const markup = renderToString(
      &lt;Navigator
        config={config}
        response={response}
        render={render}
      /&gt;
    );

    // insert the generated HTML into the full HTML of the
    // page and send the response
    res.send(fullPageHtml(markup));
  });
}</pre></div></div></div></div></main></div></div>
    <script src="https://unpkg.com/react@15.6.1/dist/react.min.js"></script>
    <script src="https://unpkg.com/react-dom@15.6.1/dist/react-dom.min.js"></script>
    <script src="/static/js/prism.js"></script>
    <script src="/static/js/bundle.js"></script>
  </body>
</html>
