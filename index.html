<!doctype html>
<html>
  <head>
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Curi | Curi Documentation</title>
    <link href="https://fonts.googleapis.com/css?family=Zilla+Slab:300,400" rel="stylesheet">
    <link href="/static/css/index.css" rel="stylesheet">
  </head>
  <body>
    <div id="root"><div data-reactroot=""><header><nav><ul><li><a class="home-link" href="/">Curi</a></li><li><a href="/packages">Packages</a></li><li><a href="/tutorial/01-introduction">Tutorial</a></li><li><a href="/guides/getting-started/">Guides</a></li><li><a href="/examples">Examples</a></li><li><a href="https://github.com/pshrmn/curi">GitHub</a></li></ul></nav></header><main><div><div class="banner"><h1>Curi</h1><p>A single page application router for any JavaScript rendering library.</p><pre class="language-javascript">import Browser from &#x27;@hickory/browser&#x27;;
import createConfig from &#x27;@curi/core&#x27;;

// create your history object
const history = Browser();

// define your routes
const routes = [
  { name: &#x27;Home&#x27;, path: &#x27;&#x27;, ... },
  { name: &#x27;User&#x27;, path: &#x27;u/:userID&#x27;, ... },
  ...
];

// create your Curi configuration object
const config = createConfig(history, routes);

// wait for the first response to be generated
config.ready().then(response =&gt; {
  // and now, you&#x27;re ready to render
});</pre><p>Ready to learn more? Check out the<!-- --> <a href="/guides/getting-started/">getting started</a> guide.</p></div><div class="features"><h2>Features</h2><div class="feature"><h3>Easy React Integration</h3><p>Curi is not just a React router, but React is currently the best supported rendering library for Curi.</p><div class="code"><div class="description"><p>Use the <code class="language-javascript">body</code> property of routes to specify each route&#x27;s component:</p></div><pre class="language-jsx">const Home = () =&gt; &lt;div&gt;Home&lt;/div&gt;;
const User = props =&gt; &lt;div&gt;User {props.params.userID}&lt;/div&gt;;
const NotFound = () =&gt; &lt;div&gt;Page not found...&lt;/div&gt;;

const routes = [
  { name: &#x27;Home&#x27;, path: &#x27;&#x27;, body: () =&gt; Home },
  { name: &#x27;User&#x27;, path: &#x27;u/:userID&#x27;, body: () =&gt; User },
  { name: &#x27;Not Found&#x27;, path: &#x27;*&#x27;, body: () =&gt; NotFound }
];</pre></div><div class="code"><div class="description"><p><code class="language-jsx">&lt;<!-- -->Link<!-- -->&gt;</code>s are used for navigating between locations within an application. URI formatting is handled for you, all you have to do is know the name (and parameters) of the route that you want to link to.</p></div><pre class="language-jsx">import Link from &#x27;@curi/react-link&#x27;;

const Nav = () =&gt; (
  &lt;div&gt;
    &lt;Link to=&#x27;Home&#x27;&gt;Home&lt;/Link&gt;
    &lt;Link to=&#x27;User&#x27; params={{ userID: 4 }}&gt;User Four&lt;/Link&gt;
  &lt;/div&gt;
);</pre></div><div class="code"><div class="description"><p>The <code class="language-jsx"><!-- -->&lt;<!-- -->Navigator<!-- -->&gt;</code> is responsible for re-rendering the application every time the location changes, using the <code class="language-javascript">render</code> function.</p></div><pre class="language-jsx">import Navigator from &#x27;@curi/react-navigator&#x27;;

ReactDOM.render((
  &lt;Navigator config={config} render={(response) =&gt; {
    const { body:Body } = response;
    return (
      &lt;div&gt;
        &lt;Nav /&gt;
        &lt;Body /&gt;
      &lt;/div&gt;
    );
  }}
));</pre></div><p>There are a number of other Curi + React components, but <code class="language-jsx"><!-- -->&lt;<!-- -->Navigator<!-- -->&gt;</code> and<!-- --> <code class="language-jsx"><!-- -->&lt;<!-- -->Link<!-- -->&gt;</code> are the only ones that you&#x27;ll need to be familiar with while getting started.. You can see the others via the<!-- --> <a href="/packages/@curi/react/"><code class="language-javascript">@curi/react</code></a> page.</p></div><div class="feature"><h3>Information Rich Response Objects</h3><p>Whenever the location changes (and on initial load), Curi will generate a response object with data on the matching route. The properties of this object are what you can use to render your application. You can learn more about these in the<!-- --> <a href="/guides/responses/">rendering with responses</a> guide.</p><div class="code"><div class="description"><p>There isn&#x27;t one &quot;right&quot; way to render using the response object, but it is useful for <code class="language-javascript">body</code> to be a function that will render the content for the route. (The body property of a response is the value returned by calling the body property of a route.)</p></div><pre class="language-javascript">{
  key: &#x27;123&#x27;,
  location: { pathname: &#x27;/u/456&#x27;, ... },
  status: 200,
  name: &#x27;User&#x27;,
  body: function() { return ... },
  params: { userID: &#x27;456&#x27; },
  ...
}</pre></div><div class="code"><div class="description"><p>The <code class="language-javascript">data</code> property of the response can contain data that you load using a route&#x27;s <code class="language-javascript">load</code> function. The response won&#x27;t be be generated until after the data has fully loaded, so if you use this property, you don&#x27;t have to render a bunch of loading spinners or empty content while waiting for the data to be loaded.</p></div><pre class="language-javascript">{
  ...,
  data: {
    username: &#x27;curi&#x27;,
    id: &#x27;234235&#x27;,
    color: &#x27;#222233&#x27;
  }
}</pre></div></div><div class="feature"><h3>Powerful Route Matching with <code class="language-javascript">path-to-regexp</code></h3><p>Curi uses <a href="https://github.com/pillarjs/path-to-regexp">path-to-regexp</a> <!-- -->to define route paths. This allows you to define route parameters that will be parsed from the URI and added to the response object (when the route matches).</p><div class="code"><div class="description"><p>In the accompanying example code, when the <code class="language-javascript">User</code> route matches, the response object&#x27;s <code class="language-javascript">params</code> object will have an <code class="language-javascript">id</code> property whose value is parsed from the URI.</p><p><code class="language-javascript">path-to-regexp</code> offers a number of matching options, which you can learn more about from its documentation.</p></div><pre class="language-javascript">const routes = [
  {
    name: &#x27;User&#x27;,
    // when the User route matches, the &quot;id&quot;
    // value will be parsed from the pathname
    // and placed in the &quot;params&quot; property of
    // the response
    path: &#x27;u/:id&#x27;
  }
];</pre></div></div><div class="feature"><h3>No Hassle Nested Routes</h3><div class="code"><div class="description"><p>For nested routes, you only have to define the additional URI segments. Those will automatically be joined with any ancestor routes for you. If any ancestor routes have path parameters, those will be included in the response&#x27;s<!-- --> <code class="language-javascript">params</code> object.</p></div><pre class="language-javascript">const routes = [
  {
    name: &#x27;Album&#x27;,
    path: &#x27;a/:albumID&#x27;,
    body: () =&gt; Album,
    children: [
      {
        name: &#x27;Song&#x27;,
        path: &#x27;:songID&#x27;,
        body: () =&gt; Song
      }
    ]
  }
]</pre></div><div class="code"><div class="description"><p>Given the above example routes, when a user visits the URI<!-- --> <code class="language-javascript">/a/4815/162342</code>, we will get the following response object. The<!-- --> <code class="language-javascript">partials</code> array contains the ancestor route <code class="language-javascript">&quot;Song&quot;</code>, which makes it easy to identify &quot;active&quot; ancestor routes.</p></div><pre class="language-javascript">// pathname = &#x27;/a/4815/162342&#x27;
{
  body: Song,
  params: { albumID: &#x27;4815&#x27;, songID: &#x27;162342&#x27; },
  name: &#x27;Song&#x27;,
  partials: [&#x27;Album&#x27;],
  ...
}
</pre></div></div><div class="feature"><h3>Navigation Powered by <code class="language-javascript">hickory</code></h3><p>Curi integrates with the<!-- --> <a href="https://github.com/pshrmn/hickory"><code class="language-javascript">hickory</code></a> package to make navigation within your application very easy.</p><div class="code"><div class="description"><p>Choose between the <code class="language-javascript">browser</code>, <code class="language-javascript">hash</code>, and <code class="language-javascript">in-memory</code> <!-- -->history types (depending on your environment).</p></div><pre class="language-javascript">import Browser from &#x27;@hickory/browser&#x27;;
import Hash from &#x27;@hickory/hash&#x27;;
import InMemory form &#x27;@hickory/in-memory&#x27;;</pre></div><div class="code"><div class="description"><p>Navigate to new locations using <code class="language-javascript">push</code>, <code class="language-javascript">replace</code>, and<!-- --> <code class="language-javascript">update</code> (a combination of push and replace that duplicates how anchors work).</p></div><pre class="language-javascript">const history = Browser();
history.push({ pathname: &#x27;/login&#x27; });
history.replace({ pathname: &#x27;/profile&#x27; });
history.update({ pathname: &#x27;/album/934&#x27; });</pre></div><div class="code"><div class="description"><p>Of course, you never have to actually generate pathnames yourself. Instead, you should use Curi&#x27;s built-in <code class="language-javascript">pathname</code> addon to create them for you.</p><p>The <code class="language-jsx"><!-- -->&lt;<!-- -->Link<!-- -->&gt;</code>s from <code class="language-javascript">@curi/react-link</code> and<!-- --> <code class="language-javascript">@curi/vue</code> use the <code class="language-javascript">pathname</code> addon internally to generate the <code class="language-javascript">href</code> attribute of the anchor elements that they render.</p></div><pre class="language-javascript">const routes = [
  { name: &#x27;Album&#x27;, path: &#x27;a/:albumID&#x27; }
];
const config = createConfig(history, routes);
const pathname = config.addons.pathname(
  &#x27;Album&#x27;,
  { albumID: &#x27;3490&#x27; }
);</pre></div></div><div class="feature"><h3>Simple Code Splitting</h3><div class="code"><div class="description"><p>Use the <code class="language-javascript">preload</code> and <code class="language-javascript">body</code> properties to add code splitting at your routes.</p><p><strong>Note:</strong> This relies on a bundler like Webpack.</p><p>You can learn more about this with the<!-- --> <a href="/guides/code-splitting/">code splitting</a> guide.</p></div><pre class="language-javascript">const store = {};

const routes = [
  {
    name: &#x27;User&#x27;,
    path: &#x27;users/:userID&#x27;,
    preload: () =&gt; import(&#x27;./components/User&#x27;)
      .then(module =&gt; { store[&#x27;User&#x27;] = module.default; }),
    body: () =&gt; store[&#x27;User&#x27;]
  }
  ...,
]</pre></div></div><div class="feature"><h3>Straightforward Server Side Rendering</h3><div class="code"><div class="description"><p>Server side rendering is pretty much the same as client side rendering. The main difference is that you will use an in-memory history instead of a browser history.</p><p>Use <code class="language-javascript">config.ready</code> to wait for the response object to be created, then render using the response object that that resolves with.</p></div><pre class="language-javascript">import InMemory from &#x27;@hickory/in-memory&#x27;;

function requestHandler(req, resp) {
  // create a history using the requested location
  const history = InMemory({ locations: [req.url] });
  const config = createConfig(history, routes);

  config.ready().then(response =&gt; {
    // render the markup. This will vary based on your
    // rendering library, but here we&#x27;ll use React
    const markup = renderToString(
      &lt;Navigator
        config={config}
        response={response}
        render={render}
      /&gt;
    );

    // insert the generated HTML into the full HTML of the
    // page and send the response
    res.send(fullPageHtml(markup));
  });
}</pre></div></div></div></div></main></div></div>
    <script src="https://unpkg.com/react@16.0.0/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16.0.0/umd/react-dom.production.min.js"></script>
    <script src="/static/js/prism.js"></script>
    <script src="/static/js/bundle.js"></script>
  </body>
</html>
