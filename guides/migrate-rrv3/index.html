<!doctype html>
<html>
  <head>
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Migrate from React Router v2/3 Guide | Curi Documentation</title>
    <link href="https://fonts.googleapis.com/css?family=Zilla+Slab:300,400" rel="stylesheet">
    <link href="/static/css/index.css" rel="stylesheet">
  </head>
  <body>
    <div id="root"><div data-reactroot="" data-reactid="1" data-react-checksum="-2093472143"><header data-reactid="2"><nav data-reactid="3"><ul data-reactid="4"><li data-reactid="5"><a class="home-link" href="/" data-reactid="6">Curi</a></li><li data-reactid="7"><a href="/packages" data-reactid="8">Packages</a></li><li data-reactid="9"><a href="/guides/getting-started/" data-reactid="10">Guides</a></li><li data-reactid="11"><a href="/examples" data-reactid="12">Examples</a></li><li data-reactid="13"><a href="https://github.com/pshrmn/curi" data-reactid="14">GitHub</a></li></ul></nav></header><main data-reactid="15"><div class="guide" data-reactid="16"><div class="content" data-reactid="17"><h1 data-reactid="18">Migrate from React Router v2/3</h1><p data-reactid="19">The Curi router is somewhat similar to React Router versions 2 and 3, so migration is fairly easy.</p><ol data-reactid="20"><li data-reactid="21">Both use a centralized route configuration.</li><li data-reactid="22"><!-- react-text: 23 -->Both configurations are made up of a route objects (sometimes disguised as JSX with <!-- /react-text --><code class="language-jsx" data-reactid="24"><!-- react-text: 25 -->&lt;<!-- /react-text --><!-- react-text: 26 -->Route<!-- /react-text --><!-- react-text: 27 -->&gt;<!-- /react-text --></code><!-- react-text: 28 --> objects in React Router)<!-- /react-text --></li><li data-reactid="29">Both allow you to nest routes.</li></ol><p data-reactid="30">Migration from React Router v2/3 to Curi should not require a complete reworking of your application, but there are some key differences.</p><ol data-reactid="31"><li data-reactid="32"><!-- react-text: 33 -->The routing is handled entirely outside of React. With Curi, there are no <!-- /react-text --><code class="language-jsx" data-reactid="34"><!-- react-text: 35 -->&lt;<!-- /react-text --><!-- react-text: 36 -->Route<!-- /react-text --><!-- react-text: 37 -->&gt;<!-- /react-text --></code><!-- react-text: 38 --> components.<!-- /react-text --></li><li data-reactid="39">When a nested route matches, only that route renders. Any ancestor routes that also (partially) match are not rendered with Curi.</li></ol><div class="section" data-reactid="40"><h2 id="routes" data-reactid="41"><!-- react-text: 42 -->Routes<!-- /react-text --><a class="header-link" href="/guides/migrate-rrv3/#routes" data-reactid="43">#</a></h2><p data-reactid="44">Let’s get started with setting up our routes.</p><div class="subsection" data-reactid="45"><h3 id="routes-with-react-router" data-reactid="46"><!-- react-text: 47 -->With React Router<!-- /react-text --><a class="header-link" href="/guides/migrate-rrv3/#routes-with-react-router" data-reactid="48">#</a></h3><p data-reactid="49"><!-- react-text: 50 -->In React Router v2/3, there are two ways to define routes. You can either use JavaScript objects or JSX <!-- /react-text --><code class="language-jsx" data-reactid="51"><!-- react-text: 52 -->&lt;<!-- /react-text --><!-- react-text: 53 -->Route<!-- /react-text --><!-- react-text: 54 -->&gt;<!-- /react-text --></code><!-- react-text: 55 -->s (which React Router converts to JavaScript objects).<!-- /react-text --></p><pre class="language-jsx" data-reactid="56">// JavaScript objects
{
  path: &#x27;/&#x27;,
  component: App,
  indexRoute: Home,
  childRoutes: [
    {
      path: &#x27;inbox&#x27;,
      component: Inbox,
      childRoutes: [
        {
          path: &#x27;:message&#x27;,
          component: Message,
          onEnter: (next) =&gt; {...},
          onChange: (prev, next) =&gt; {...},
          onLeave: (prev) =&gt; {...}
        }
      ]
    }
  ]
// JSX
&lt;Route path=&#x27;/&#x27; component={App}&gt;
  &lt;IndexRoute component={Home} /&gt;
  &lt;Route path=&#x27;inbox&#x27; component={Inbox}&gt;
    &lt;Route
      path=&#x27;:message&#x27;
      component={Message}
      onEnter={next =&gt; {...}}
      onChange={(prev, next) =&gt; {...}}
      onLeave={prev =&gt; {...}}
    /&gt;
  &lt;/Route&gt;
&lt;/Route&gt;</pre><p data-reactid="57"><!-- react-text: 58 -->Both styles described above define the same route structure for three routes: <!-- /react-text --><code class="language-javascript" data-reactid="59">/</code><!-- react-text: 60 -->, <!-- /react-text --><code class="language-javascript" data-reactid="61">/inbox</code><!-- react-text: 62 -->, and <!-- /react-text --><code class="language-javascript" data-reactid="63">/inbox/:message</code><!-- react-text: 64 -->. Each one of these has a component that will be rendered when it matches. The <!-- /react-text --><code class="language-javascript" data-reactid="65">/inbox/:message</code><!-- react-text: 66 --> route has some methods defined to describe its behavior when the route enters, updates, and leaves.<!-- /react-text --></p></div><div class="subsection" data-reactid="67"><h3 id="routes-with-curi" data-reactid="68"><!-- react-text: 69 -->With Curi<!-- /react-text --><a class="header-link" href="/guides/migrate-rrv3/#routes-with-curi" data-reactid="70">#</a></h3><p data-reactid="71"><!-- react-text: 72 -->Routes in Curi are always JavaScript objects. Like React Router, each route object has a path property that describes the path segments that the route matches. React Router v2/3 uses a custom path matcher, but Curi uses <!-- /react-text --><a href="https://github.com/pillarjs/path-to-regexp" data-reactid="73"><code class="language-javascript" data-reactid="74">path-to-regexp</code></a><!-- react-text: 75 -->. You can read learn how to format paths from the <!-- /react-text --><code class="language-javascript" data-reactid="76">path-to-regexp</code><!-- react-text: 77 --> repo. <!-- /react-text --></p><p data-reactid="78">First, we will just define our routes the paths.</p><pre class="language-javascript" data-reactid="79">const routes = [
  {
    path: &#x27;&#x27;
  },
  {
    path: &#x27;inbox&#x27;,
    children: [
      {
        path: &#x27;:message&#x27;
      }
    ]
  }
];</pre><p data-reactid="80"><!-- react-text: 81 -->The only real difference between the Curi paths and the React Router paths is that the root path for Curi is <!-- /react-text --><code class="language-javascript" data-reactid="82">&#x27;&#x27;</code><!-- react-text: 83 --> while the root path for React Router is <!-- /react-text --><code class="language-javascript" data-reactid="84">&#x27;/&#x27;</code><!-- react-text: 85 -->. With Curi, you never include the leading forward slash.<!-- /react-text --></p><p data-reactid="86"><!-- react-text: 87 -->Next, we should add our components to each route. We will ignore the <!-- /react-text --><code class="language-jsx" data-reactid="88"><!-- react-text: 89 -->&lt;<!-- /react-text --><!-- react-text: 90 -->App<!-- /react-text --><!-- react-text: 91 -->&gt;<!-- /react-text --></code><!-- react-text: 92 --> component that is used in the React Router routes. That is not route specific and will be rendered by our application (assuming we actually need it).<!-- /react-text --></p><p data-reactid="93"><!-- react-text: 94 -->With Curi routes, we have a <!-- /react-text --><code class="language-javascript" data-reactid="95">body</code><!-- react-text: 96 --> property. This is a function that will be called whenever the route matches. Its return value will be added to the response object that Curi creates (more on that later). For this React application, we want our <!-- /react-text --><code class="language-javascript" data-reactid="97">body</code><!-- react-text: 98 --> functions to return the React component associated with each route.<!-- /react-text --></p><pre class="language-javascript" data-reactid="99">const routes = [
  {
    path: &#x27;&#x27;,
    body: () =&gt; Home
  },
  {
    path: &#x27;inbox&#x27;,
    body: () =&gt; Inbox,
    children: [
      {
        path: &#x27;:message&#x27;,
        body: () =&gt; Message
      }
    ]
  }
];</pre><p data-reactid="100"><!-- react-text: 101 -->We are close to replicating our React Router routes, we just have to implement the <!-- /react-text --><code class="language-javascript" data-reactid="102">on___</code><!-- react-text: 103 --> methods for our <!-- /react-text --><code class="language-javascript" data-reactid="104">:message</code><!-- react-text: 105 --> route. With Curi, routes have two possible loading function properties: <!-- /react-text --><code class="language-javascript" data-reactid="106">preload</code><!-- react-text: 107 --> <!-- /react-text --><!-- react-text: 108 -->and <!-- /react-text --><code class="language-javascript" data-reactid="109">load</code><!-- react-text: 110 -->. <!-- /react-text --><code class="language-javascript" data-reactid="111">preload</code><!-- react-text: 112 --> is useful for tasks that only need to be run once per route, like code splitting. <!-- /react-text --><code class="language-javascript" data-reactid="113">load</code><!-- react-text: 114 -->, on the other hand, will be called every time that a route matches.<!-- /react-text --></p><p data-reactid="115"><!-- react-text: 116 -->With React Router, <!-- /react-text --><code class="language-javascript" data-reactid="117">onEnter</code><!-- react-text: 118 --> is called when the route first matches, while <!-- /react-text --><code class="language-javascript" data-reactid="119">onChange</code><!-- react-text: 120 --> is called when the same route matches a new location (e.g. with new path parameters). <!-- /react-text --><code class="language-javascript" data-reactid="121">onEnter</code><!-- react-text: 122 --> and <!-- /react-text --><code class="language-javascript" data-reactid="123">onChange</code><!-- react-text: 124 --> are nearly the same; the big difference between the two is that <!-- /react-text --><code class="language-javascript" data-reactid="125">onChange</code><!-- react-text: 126 --> will receive the previous props, which could be used to determine which props changed. When converting these to Curi, we will use <!-- /react-text --><code class="language-javascript" data-reactid="127">load</code><!-- react-text: 128 --> for both. This misses out on the ability to compare props in <!-- /react-text --><code class="language-javascript" data-reactid="129">onChange</code><!-- react-text: 130 -->, but (assuming you’re using the comparison to determine whether to load new data) a cache should serve the same purpose.<!-- /react-text --></p><p data-reactid="131"><!-- react-text: 132 -->There currently is no equivalent to <!-- /react-text --><code class="language-javascript" data-reactid="133">onLeave</code><!-- react-text: 134 --> with Curi. This is mostly because I haven’t seen a compelling need for it. It certainly could be implemented, but so far I have not found a reason to use that. If you have something you need this functionality for, please open up an issue in the GitHub repo.<!-- /react-text --></p><pre class="language-javascript" data-reactid="135">const routes = [
  {
    path: &#x27;&#x27;,
    body: () =&gt; Home
  },
  {
    path: &#x27;inbox&#x27;,
    body: () =&gt; Inbox,
    children: [
      {
        path: &#x27;:message&#x27;,
        body: () =&gt; Message,
        load: (params, location, mods) =&gt; {...}
      }
    ]
  }
];</pre><p data-reactid="136"><code class="language-javascript" data-reactid="137">params</code><!-- react-text: 138 --> is an object of parsed path parameters, <!-- /react-text --><code class="language-javascript" data-reactid="139">location</code><!-- react-text: 140 --> is the current location object, and <!-- /react-text --><code class="language-javascript" data-reactid="141">mods</code><!-- react-text: 142 --> <!-- /react-text --><!-- react-text: 143 -->is an object with functions to modify the response. For example, <!-- /react-text --><code class="language-javascript" data-reactid="144">mods.setData</code><!-- react-text: 145 --> allows you to attach loaded data to the response object.<!-- /react-text --></p><p data-reactid="146">We now have the equivalent routes implemented in Curi, but we have one last step. With Curi, each route has to have a unique name.</p><pre class="language-javascript" data-reactid="147">const routes = [
  {
    name: &#x27;Home&#x27;,
    path: &#x27;&#x27;,
    body: () =&gt; Home
  },
  {
    name: &#x27;Inbox&#x27;,
    path: &#x27;inbox&#x27;,
    body: () =&gt; Inbox,
    children: [
      {
        name: &#x27;Message&#x27;,
        path: &#x27;:message&#x27;,
        body: () =&gt; Message,
        load: (params, location, mods) =&gt; {...}
      }
    ]
  }
];</pre><p data-reactid="148">Curi uses route names to allow you to interact with routes. For example, you can navigate to the “Inbox” route just by knowing its name instead of its URI. With Curi, you never have to generate a URI yourself!</p></div><p data-reactid="149">Once your routes have been defined, you can move on to creating your Curi configuration object.</p></div><div class="section" data-reactid="150"><h2 id="creating-the-configuration" data-reactid="151"><!-- react-text: 152 -->Creating the Configuration<!-- /react-text --><a class="header-link" href="/guides/migrate-rrv3/#creating-the-configuration" data-reactid="153">#</a></h2><p data-reactid="154"><!-- react-text: 155 -->With React Router, you create your configuration by rendering a <!-- /react-text --><code class="language-jsx" data-reactid="156"><!-- react-text: 157 -->&lt;<!-- /react-text --><!-- react-text: 158 -->Router<!-- /react-text --><!-- react-text: 159 -->&gt;<!-- /react-text --></code><!-- react-text: 160 -->. That either takes the <!-- /react-text --><code class="language-jsx" data-reactid="161"><!-- react-text: 162 -->&lt;<!-- /react-text --><!-- react-text: 163 -->Route<!-- /react-text --><!-- react-text: 164 -->&gt;<!-- /react-text --></code><!-- react-text: 165 --> components as props or the route objects through its <!-- /react-text --><code class="language-javascript" data-reactid="166">routes</code><!-- react-text: 167 --> prop. The <!-- /react-text --><code class="language-jsx" data-reactid="168"><!-- react-text: 169 -->&lt;<!-- /react-text --><!-- react-text: 170 -->Router<!-- /react-text --><!-- react-text: 171 -->&gt;<!-- /react-text --></code><!-- react-text: 172 --> also takes a <!-- /react-text --><code class="language-javascript" data-reactid="173">history</code><!-- react-text: 174 --> prop, which is either one of the pre-configured objects (<!-- /react-text --><code class="language-javascript" data-reactid="175">browserHistory</code><!-- react-text: 176 --> or <!-- /react-text --><code class="language-javascript" data-reactid="177">hashHistory</code><!-- react-text: 178 -->) or one that you create yourself.<!-- /react-text --></p><pre class="language-jsx" data-reactid="179">import { Router, browserHistory } from &#x27;react-router&#x27;;
const routes = [...];
ReactDOM.render((
  &lt;Router history={browserHistory} routes={routes} /&gt;
), holder);</pre><p data-reactid="180">With Curi, the configuration object is created prior to rendering. It takes a Hickory history object, your routes array, and possibly an options object. </p><pre class="language-javascript" data-reactid="181">import createConfig from &#x27;@curi/core&#x27;;
import Browser from &#x27;@hickory/browser&#x27;;
const history = Browser();
const routes = [...];
const config = creatConfig(history, routes);</pre></div><div class="section" data-reactid="182"><h2 id="rendering" data-reactid="183"><!-- react-text: 184 -->Rendering<!-- /react-text --><a class="header-link" href="/guides/migrate-rrv3/#rendering" data-reactid="185">#</a></h2><p data-reactid="186">At this point, our Curi configuration object isn’t actually quite ready to render. Curi creates response objects asynchronously, so if we render right away, we might not have a response object to render with. We can work around this by rendering nothing at first, but instead we should just wait for our initial response to be ready.</p><pre class="language-javascript" data-reactid="187">config.ready().then(() =&gt; {
  // now we can render
});</pre><p data-reactid="188"><!-- react-text: 189 -->We will walk through the rendering differences between React Router and Curi by looking at what happens in each when we navigate to the URI <!-- /react-text --><code class="language-javascript" data-reactid="190">/inbox/test-message-please-ignore</code><!-- react-text: 191 -->.<!-- /react-text --></p><div class="subsection" data-reactid="192"><h3 id="rendering-react-router" data-reactid="193"><!-- react-text: 194 -->React Router v2/3<!-- /react-text --><a class="header-link" href="/guides/migrate-rrv3/#rendering-react-router" data-reactid="195">#</a></h3><p data-reactid="196"><!-- react-text: 197 -->React Router uses the <!-- /react-text --><code class="language-jsx" data-reactid="198"><!-- react-text: 199 -->&lt;<!-- /react-text --><!-- react-text: 200 -->Router<!-- /react-text --><!-- react-text: 201 -->&gt;<!-- /react-text --></code><!-- react-text: 202 --> component to subscribe to location changes. Each time that the location changes, it walks over its routes and determines which route(s!) match. React Router starts by rendering the root component. In the above configuration, that is the <!-- /react-text --><code class="language-jsx" data-reactid="203"><!-- react-text: 204 -->&lt;<!-- /react-text --><!-- react-text: 205 -->App<!-- /react-text --><!-- react-text: 206 -->&gt;<!-- /react-text --></code><!-- react-text: 207 -->. Next, our <!-- /react-text --><code class="language-javascript" data-reactid="208">inbox</code><!-- react-text: 209 --> route also matches, so React Router also renders our <!-- /react-text --><code class="language-jsx" data-reactid="210"><!-- react-text: 211 -->&lt;<!-- /react-text --><!-- react-text: 212 -->Inbox<!-- /react-text --><!-- react-text: 213 -->&gt;<!-- /react-text --></code><!-- react-text: 214 --> component. Finally, the URI <!-- /react-text --><code class="language-javascript" data-reactid="215">/inbox/test-message-please-ignore</code><!-- react-text: 216 --> also matches our <!-- /react-text --><code class="language-javascript" data-reactid="217">:message</code><!-- react-text: 218 --> route (which is concatenated with its parents to form the path <!-- /react-text --><code class="language-javascript" data-reactid="219">/inbox/:message</code><!-- react-text: 220 -->), so <!-- /react-text --><code class="language-jsx" data-reactid="221"><!-- react-text: 222 -->&lt;<!-- /react-text --><!-- react-text: 223 -->Message<!-- /react-text --><!-- react-text: 224 -->&gt;<!-- /react-text --></code><!-- react-text: 225 --> is rendered as well. Each child component is rendered by its parent, so we end up with a component tree that looks something like this:<!-- /react-text --></p><pre class="language-jsx" data-reactid="226">&lt;App&gt;
  &lt;Inbox&gt;
    &lt;Message&gt;
  &lt;/Inbox&gt;
&lt;/App&gt;</pre><p data-reactid="227"><!-- react-text: 228 -->With this structure, any routes with children will be rendered when one of the children matches. That means that those routes need to know how to render based on what type of match they have. For example, <!-- /react-text --><code class="language-jsx" data-reactid="229"><!-- react-text: 230 -->&lt;<!-- /react-text --><!-- react-text: 231 -->Inbox<!-- /react-text --><!-- react-text: 232 -->&gt;<!-- /react-text --></code><!-- react-text: 233 --> needs to know how to render for an exact match (the URI is <!-- /react-text --><code class="language-javascript" data-reactid="234">/inbox</code><!-- react-text: 235 -->) and for a partial match (<!-- /react-text --><code class="language-javascript" data-reactid="236">/inbox/test-message-please-ignore</code><!-- react-text: 237 -->). Also, if the <!-- /react-text --><code class="language-jsx" data-reactid="238"><!-- react-text: 239 -->&lt;<!-- /react-text --><!-- react-text: 240 -->Inbox<!-- /react-text --><!-- react-text: 241 -->&gt;<!-- /react-text --></code><!-- react-text: 242 --> needs to pass any props to <!-- /react-text --><code class="language-jsx" data-reactid="243"><!-- react-text: 244 -->&lt;<!-- /react-text --><!-- react-text: 245 -->Message<!-- /react-text --><!-- react-text: 246 -->&gt;<!-- /react-text --></code><!-- react-text: 247 -->, it has to use <!-- /react-text --><code class="language-javascript" data-reactid="248">React.cloneElement</code><!-- react-text: 249 -->, which works but is not the cleanest looking code.<!-- /react-text --></p></div><div class="subsection" data-reactid="250"><h3 id="rendering-with-curi" data-reactid="251"><!-- react-text: 252 -->Curi<!-- /react-text --><a class="header-link" href="/guides/migrate-rrv3/#rendering-with-curi" data-reactid="253">#</a></h3><p data-reactid="254"><!-- react-text: 255 -->With Curi, we need to have a way to re-render our application every time that the location changes. The easiest approach is to use the <!-- /react-text --><code class="language-jsx" data-reactid="256"><!-- react-text: 257 -->&lt;<!-- /react-text --><!-- react-text: 258 -->Navigator<!-- /react-text --><!-- react-text: 259 -->&gt;<!-- /react-text --></code><!-- react-text: 260 --> component, which comes from the <!-- /react-text --><code class="language-javascript" data-reactid="261">@curi/react</code><!-- react-text: 262 --> package. This expects two props: <!-- /react-text --><code class="language-javascript" data-reactid="263">config</code><!-- react-text: 264 -->, which is our Curi configuration object, and <!-- /react-text --><code class="language-javascript" data-reactid="265">render</code><!-- react-text: 266 -->, which is a render function it will call to render the application. The <!-- /react-text --><code class="language-jsx" data-reactid="267"><!-- react-text: 268 -->&lt;<!-- /react-text --><!-- react-text: 269 -->Navigator<!-- /react-text --><!-- react-text: 270 -->&gt;<!-- /react-text --></code><!-- react-text: 271 --> will subscribe to your configuration object and automatically re-render when the location changes (and a new response object is created).<!-- /react-text --></p><pre class="language-jsx" data-reactid="272">config.ready().then(() =&gt; {
  ReactDOM.render((
    &lt;Navigator
      config={config}
      render={response =&gt; { return ...; }}
    /&gt;
  ), holder);
});</pre><p data-reactid="273"><!-- react-text: 274 -->So what should your render function look like? The render function will receive two arguments: <!-- /react-text --><code class="language-javascript" data-reactid="275">response</code><!-- react-text: 276 -->, the new response object, and <!-- /react-text --><code class="language-javascript" data-reactid="277">config</code><!-- react-text: 278 -->, our Curi configuration object. We will ignore config here because the response is what we really want, the config is just there for convenience.<!-- /react-text --></p><p data-reactid="279"><!-- react-text: 280 -->If you remember from above, we added <!-- /react-text --><code class="language-javascript" data-reactid="281">body</code><!-- react-text: 282 --> properties to each of the routes and said that when a route matches, that function would be called and its return value would be attached to the response. That means, that inside of our render function, we can access the matched route’s component as <!-- /react-text --><code class="language-javascript" data-reactid="283">response.body</code><!-- react-text: 284 -->.<!-- /react-text --></p><pre class="language-jsx" data-reactid="285">function render(response) {
  const { body:Body } = response;
  return &lt;Body /&gt;;
}</pre><p data-reactid="286"><!-- react-text: 287 -->That isn’t perfect because it doesn’t consider what happens when there is no body (which happens if none of the routes match the location). Wildcard routes (<!-- /react-text --><code class="language-javascript" data-reactid="288">(.*)</code><!-- react-text: 289 -->) can be useful here or you can just return something else when there is no<!-- /react-text --><!-- react-text: 290 --> <!-- /react-text --><code class="language-javascript" data-reactid="291">response.body</code><!-- react-text: 292 --> property.<!-- /react-text --></p><p data-reactid="293"><!-- react-text: 294 -->Let’s get back to our response object. In the React Router section, we had three components that were rendered: <!-- /react-text --><code class="language-jsx" data-reactid="295"><!-- react-text: 296 -->&lt;<!-- /react-text --><!-- react-text: 297 -->App<!-- /react-text --><!-- react-text: 298 -->&gt;<!-- /react-text --></code><!-- react-text: 299 -->,<!-- /react-text --><code class="language-jsx" data-reactid="300"><!-- react-text: 301 -->&lt;<!-- /react-text --><!-- react-text: 302 -->Inbox<!-- /react-text --><!-- react-text: 303 -->&gt;<!-- /react-text --></code><!-- react-text: 304 -->, and <!-- /react-text --><code class="language-jsx" data-reactid="305"><!-- react-text: 306 -->&lt;<!-- /react-text --><!-- react-text: 307 -->Message<!-- /react-text --><!-- react-text: 308 -->&gt;<!-- /react-text --></code><!-- react-text: 309 -->. With Curi, only the best matched route matches. That means that for the URI<!-- /react-text --><!-- react-text: 310 --> <!-- /react-text --><code class="language-javascript" data-reactid="311">/inbox/test-message-please-ignore</code><!-- react-text: 312 -->,our <!-- /react-text --><code class="language-javascript" data-reactid="313">response.body</code><!-- react-text: 314 --> will be the <!-- /react-text --><code class="language-jsx" data-reactid="315"><!-- react-text: 316 -->&lt;<!-- /react-text --><!-- react-text: 317 -->Message<!-- /react-text --><!-- react-text: 318 -->&gt;<!-- /react-text --></code><!-- react-text: 319 --> component. We don’t render <!-- /react-text --><code class="language-jsx" data-reactid="320"><!-- react-text: 321 -->&lt;<!-- /react-text --><!-- react-text: 322 -->Inbox<!-- /react-text --><!-- react-text: 323 -->&gt;<!-- /react-text --></code><!-- react-text: 324 --> because we did not match the <!-- /react-text --><code class="language-javascript" data-reactid="325">inbox</code><!-- react-text: 326 --> route.<!-- /react-text --></p><p data-reactid="327"><!-- react-text: 328 -->We also said above that there was no need for the <!-- /react-text --><code class="language-jsx" data-reactid="329"><!-- react-text: 330 -->&lt;<!-- /react-text --><!-- react-text: 331 -->App<!-- /react-text --><!-- react-text: 332 -->&gt;<!-- /react-text --></code><!-- react-text: 333 --> component with Curi. If you want to have an <!-- /react-text --><code class="language-jsx" data-reactid="334"><!-- react-text: 335 -->&lt;<!-- /react-text --><!-- react-text: 336 -->App<!-- /react-text --><!-- react-text: 337 -->&gt;<!-- /react-text --></code><!-- react-text: 338 --> <!-- /react-text --><!-- react-text: 339 -->component, you can render it either inside of the render function or as a parent of your <!-- /react-text --><code class="language-jsx" data-reactid="340"><!-- react-text: 341 -->&lt;<!-- /react-text --><!-- react-text: 342 -->Navigator<!-- /react-text --><!-- react-text: 343 -->&gt;<!-- /react-text --></code><!-- react-text: 344 -->. This can be useful for rendering content that is unrelated to specific routes, like a page header or menu.<!-- /react-text --></p><p data-reactid="345"><!-- react-text: 346 -->Rendering the <!-- /react-text --><code class="language-jsx" data-reactid="347"><!-- react-text: 348 -->&lt;<!-- /react-text --><!-- react-text: 349 -->App<!-- /react-text --><!-- react-text: 350 -->&gt;<!-- /react-text --></code><!-- react-text: 351 --> inside of the render function is necessary if any of the components rendered by the <!-- /react-text --><code class="language-jsx" data-reactid="352"><!-- react-text: 353 -->&lt;<!-- /react-text --><!-- react-text: 354 -->App<!-- /react-text --><!-- react-text: 355 -->&gt;<!-- /react-text --></code><!-- react-text: 356 --> <!-- /react-text --><!-- react-text: 357 -->are location aware components, since they need to access the Curi configuration object (through React’s context, which the <!-- /react-text --><code class="language-jsx" data-reactid="358"><!-- react-text: 359 -->&lt;<!-- /react-text --><!-- react-text: 360 -->Navigator<!-- /react-text --><!-- react-text: 361 -->&gt;<!-- /react-text --></code><!-- react-text: 362 --> provides)<!-- /react-text --></p><pre class="language-jsx" data-reactid="363">function render(response) {
  const { body:Body } = response;
  return (
    &lt;App&gt;
      &lt;Body /&gt;
    &lt;/App&gt;
  );
}
// or
function render(response) {
  const { body:Body } = response;
  return (
    &lt;div&gt;
      &lt;Header /&gt;
      &lt;Body /&gt;
      &lt;Footer /&gt;
    &lt;/div&gt;
  );
}</pre><p data-reactid="364"><!-- react-text: 365 -->What about props that you want to send to your route components? Just pass them to the <!-- /react-text --><code class="language-jsx" data-reactid="366"><!-- react-text: 367 -->&lt;<!-- /react-text --><!-- react-text: 368 -->Body<!-- /react-text --><!-- react-text: 369 -->&gt;<!-- /react-text --></code><!-- react-text: 370 --> component that you render.<!-- /react-text --></p><pre class="language-jsx" data-reactid="371">function render(response) {
  const { body:Body, data, params } = response;
  return &lt;Body data={data} params={params} /&gt;;
}</pre><p data-reactid="372"><!-- react-text: 373 -->The one catch here is that you will be passing the same props to all of your route components. You could add fine-grained control by using <!-- /react-text --><code class="language-javascript" data-reactid="374">response.name</code><!-- react-text: 375 --> and a <!-- /react-text --><code class="language-javascript" data-reactid="376">switch</code><!-- react-text: 377 --> or <!-- /react-text --><code class="language-javascript" data-reactid="378">if</code><!-- react-text: 379 -->/<!-- /react-text --><code class="language-javascript" data-reactid="380">else</code><!-- react-text: 381 --> chain, but this is probably overkill. If you’re worried about polluting the route component’s props, just pass the whole response object.<!-- /react-text --></p></div></div><div class="section" data-reactid="382"><h2 id="links" data-reactid="383"><!-- react-text: 384 -->Links<!-- /react-text --><a class="header-link" href="/guides/migrate-rrv3/#links" data-reactid="385">#</a></h2><p data-reactid="386"><!-- react-text: 387 -->You obviously will want to be able to navigate between routes in your application. React Router provides a <!-- /react-text --><code class="language-jsx" data-reactid="388"><!-- react-text: 389 -->&lt;<!-- /react-text --><!-- react-text: 390 -->Link<!-- /react-text --><!-- react-text: 391 -->&gt;<!-- /react-text --></code><!-- react-text: 392 --> component to do this, and so does Curi (through the <!-- /react-text --><code class="language-javascript" data-reactid="393">@curi/react</code><!-- react-text: 394 --> package). There are a few differences to note between these two components:<!-- /react-text --></p><ul data-reactid="395"><li data-reactid="396"><p data-reactid="397"><!-- react-text: 398 -->React Router expects you to generate the pathname yourself, while Curi expects you to pass the name of the route that you want to navigate to. Any path parameters are passed to Curi’s <!-- /react-text --><code class="language-jsx" data-reactid="399"><!-- react-text: 400 -->&lt;<!-- /react-text --><!-- react-text: 401 -->Link<!-- /react-text --><!-- react-text: 402 -->&gt;<!-- /react-text --></code><!-- react-text: 403 --> using the <!-- /react-text --><code class="language-javascript" data-reactid="404">params</code><!-- react-text: 405 --> prop.<!-- /react-text --></p><pre class="language-jsx" data-reactid="406">// React Router
&lt;Link to=&#x27;/&#x27;&gt;Home&lt;/Link&gt;
&lt;Link to={`/inbox/${message}`}&gt;Hello&lt;/Link&gt;
// Curi
&lt;Link to=&#x27;Home&#x27;&gt;Home&lt;/Link&gt;
&lt;Link to=&#x27;Message&#x27; params={{ message }}&gt;Hello&lt;/Link&gt;</pre></li><li data-reactid="407"><p data-reactid="408"><!-- react-text: 409 -->With React Router, any additional location properties are passed to the <!-- /react-text --><code class="language-jsx" data-reactid="410"><!-- react-text: 411 -->&lt;<!-- /react-text --><!-- react-text: 412 -->Link<!-- /react-text --><!-- react-text: 413 -->&gt;<!-- /react-text --></code><!-- react-text: 414 --> using the <!-- /react-text --><code class="language-javascript" data-reactid="415">to</code><!-- react-text: 416 --> object. With Curi, these properties are passed using the <!-- /react-text --><code class="language-javascript" data-reactid="417">details</code><!-- react-text: 418 --> prop.<!-- /react-text --></p><pre class="language-jsx" data-reactid="419">// React Router
&lt;Link to={{ pathname: &#x27;/inbox&#x27;, hash: &#x27;#test&#x27; }}&gt;Inbox&lt;/Link&gt;
// Curi
&lt;Link to=&#x27;Inbox&#x27; details={{ hash: &#x27;test&#x27; }}&gt;Inbox&lt;/Link&gt;</pre></li><li data-reactid="420"><p data-reactid="421"><!-- react-text: 422 -->Active detection with Curi is a little more involved than with React Router, but also more powerful. With Curi, you provide a<!-- /react-text --><!-- react-text: 423 --> <!-- /react-text --><code class="language-javascript" data-reactid="424">merge</code><!-- react-text: 425 --> function that receives the props that will used to render the <!-- /react-text --><code class="language-jsx" data-reactid="426"><!-- react-text: 427 -->&lt;<!-- /react-text --><!-- react-text: 428 -->a<!-- /react-text --><!-- react-text: 429 -->&gt;<!-- /react-text --></code><!-- react-text: 430 --> and allows you to modify/add props. You can also pass <!-- /react-text --><code class="language-javascript" data-reactid="431">partial: true</code><!-- react-text: 432 --> to allow for partial matches to be considered active (the opposite of React Router&#x27;s<!-- /react-text --><!-- react-text: 433 --> <!-- /react-text --><code class="language-javascript" data-reactid="434">onlyActiveOnIndex</code><!-- react-text: 435 -->).<!-- /react-text --></p><pre class="language-jsx" data-reactid="436">// React Router
&lt;Link
  to=&#x27;/&#x27;
  onlyActiveOnIndex
  activeClassName=&#x27;active&#x27;
&gt;Home&lt;/Link&gt;
// Curi
// You need to add @curi/addon-active to your config object
import createActiveAddon from &#x27;@curi/addon-active&#x27;;
const config = createConfig(history, routes, {
  createActiveAddon
});
function merge(props) {
  props.className = &#x27;active&#x27;;
  return props;
}
&lt;Link
  to=&#x27;Home&#x27;
  active={{ merge }}
&gt;Home&lt;/Link&gt;</pre></li></ul></div><div class="section" data-reactid="437"><h2 id="router-props" data-reactid="438"><!-- react-text: 439 -->Accessing router props from nested components<!-- /react-text --><a class="header-link" href="/guides/migrate-rrv3/#router-props" data-reactid="440">#</a></h2><p data-reactid="441"><!-- react-text: 442 -->React Router provides a <!-- /react-text --><code class="language-javascript" data-reactid="443">withRouter</code><!-- react-text: 444 --> higher-order component that will inject router props into the wrapped component. Curi provides similar functionality with the <!-- /react-text --><code class="language-javascript" data-reactid="445">curious</code><!-- react-text: 446 --> higher-order component provided by the <!-- /react-text --><code class="language-javascript" data-reactid="447">@curi/react</code><!-- react-text: 448 --> package. <!-- /react-text --></p><pre class="language-javascript" data-reactid="449">export default withRouter(SomeComponent);
export default curious(SomeComponent);</pre><p data-reactid="450"><code class="language-javascript" data-reactid="451">curious</code><!-- react-text: 452 --> will inject the Curi configuration object and the current response object into the wrapped component.<!-- /react-text --></p></div></div><div class="sidebar" data-reactid="453"><h2 data-reactid="454">Guides</h2><ul data-reactid="455"><li class="link-group" data-reactid="456"><h3 data-reactid="457">basic</h3><ul class="link-list" data-reactid="458"><li class="solo" data-reactid="459"><a href="/guides/installation/" data-reactid="460">Installation</a></li><li class="solo" data-reactid="461"><a href="/guides/getting-started/" data-reactid="462">Getting Started</a></li><li class="solo" data-reactid="463"><a href="/guides/routes/" data-reactid="464">All About Routes</a></li><li class="solo" data-reactid="465"><a href="/guides/responses/" data-reactid="466">Rendering with Responses</a></li></ul></li><li class="link-group" data-reactid="467"><h3 data-reactid="468">advanced</h3><ul class="link-list" data-reactid="469"><li class="solo" data-reactid="470"><a href="/guides/addons/" data-reactid="471">Using Addons</a></li><li class="solo" data-reactid="472"><a href="/guides/side-effects/" data-reactid="473">Using Side Effects</a></li><li class="solo" data-reactid="474"><a href="/guides/response-caching/" data-reactid="475">Response Caching</a></li><li class="solo" data-reactid="476"><a href="/guides/code-splitting/" data-reactid="477">Code Splitting with the Preload Property</a></li><li class="solo" data-reactid="478"><a href="/guides/load/" data-reactid="479">The Load Property</a></li><li class="solo" data-reactid="480"><a href="/guides/react/" data-reactid="481">React Basics</a></li></ul></li><li class="link-group" data-reactid="482"><h3 data-reactid="483">migration</h3><ul class="link-list" data-reactid="484"><li class="solo" data-reactid="485"><a class="active" href="/guides/migrate-rrv3/" data-reactid="486">Migrate from React Router v2/3</a></li></ul></li></ul></div></div></main></div></div>
    <script src="https://unpkg.com/react@15.6.1/dist/react.min.js"></script>
    <script src="https://unpkg.com/react-dom@15.6.1/dist/react-dom.min.js"></script>
    <script src="/static/js/prism.js"></script>
    <script src="/static/js/bundle.js"></script>
  </body>
</html>
