<!doctype html>
<html>
  <head>
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Code Splitting with the Preload Property Guide | Curi Documentation</title>
    <link href="https://fonts.googleapis.com/css?family=Zilla+Slab:300,400" rel="stylesheet">
    <link href="/static/css/index.css" rel="stylesheet">
  </head>
  <body>
    <div id="root"><div data-reactroot=""><header><nav><ul><li><a class="home-link" href="/">Curi</a></li><li><a href="/packages">Packages</a></li><li><a href="/tutorial/01-introduction">Tutorial</a></li><li><a href="/guides/getting-started/">Guides</a></li><li><a href="/examples">Examples</a></li><li><a href="https://github.com/pshrmn/curi">GitHub</a></li></ul></nav></header><main><div class="guide"><div class="content"><h1>Code Splitting with the Preload Property</h1><p>If you are bundling an application with a lot of routes, users of your application may be downloading a lot of unnecessary content just to render the initial page. Using code splitting, you can reduce the initial download size for your application by splitting code that is conditionally loaded into a separate bundle that is only downloaded when it is needed.</p><div class="note"><strong>Note:</strong> <!-- -->This guide assumes that you are using Webpack 2+ to bundle your application.</div><div class="section"><h2 id="no-split">An app without code splitting<a class="header-link" href="/guides/code-splitting/#no-split">#</a></h2><p>Let&#x27;s start out by describing our application&#x27;s routes without code splitting. We will import each route&#x27;s component from the files where they are defined.</p><pre class="language-javascript">import Home from &#x27;./components/Home&#x27;;
import Contact from &#x27;./components/Contact&#x27;;
import ContactMethod from &#x27;./components/ContactMethod&#x27;;

const routes = [
  {
    name: &#x27;Home&#x27;,
    path: &#x27;&#x27;,
    body: () =&gt; Home
  },
  {
    name: &#x27;Contact&#x27;,
    path: &#x27;contact&#x27;,
    body: () =&gt; Contact,
    children: [
      {
        name: &#x27;Contact Method&#x27;,
        path: &#x27;:method&#x27;,
        body: () =&gt; ContactMethod
      }
    ]
  }
];</pre></div><div class="section"><h2 id="no-static-imports">Removing static imports<a class="header-link" href="/guides/code-splitting/#no-static-imports">#</a></h2><p>With code splitting, we don&#x27;t want to have access to the component values when creating our routes because that means we have to download all of them before our application can render. We should remove our import calls so that that doesn&#x27;t happen.</p><pre class="language-javascript">const routes = [
  {
    name: &#x27;Home&#x27;,
    path: &#x27;&#x27;,
    body: () =&gt; Home
  },
  {
    name: &#x27;Contact&#x27;,
    path: &#x27;contact&#x27;,
    body: () =&gt; Contact,
    children: [
      {
        name: &#x27;Contact Method&#x27;,
        path: &#x27;:method&#x27;,
        body: () =&gt; ContactMethod
      }
    ]
  }
];</pre></div><div class="section"><h2 id="preload">Importing in preload<a class="header-link" href="/guides/code-splitting/#preload">#</a></h2><p>Now, <code class="language-javascript">Home</code>, <code class="language-javascript">Contact</code>, and<!-- --> <code class="language-javascript">ContactMethod</code> are all undefined, so if we tried to render our application we would get errors. We need to actually import our components so that our body functions actually have something to return.</p><p>We will import our components using the preload property of routes. This function will only be called the first time that its route matches, so we don&#x27;t have to worry about making extra requests to our server.</p><p><code class="language-javascript">preload</code> should be a function that returns a Promise. Here, we will call<code class="language-javascript">import()</code>, which conveniently returns a Promise.</p><pre class="language-javascript">const routes = [
  {
    name: &#x27;Home&#x27;,
    path: &#x27;&#x27;,
    preload: () =&gt; import(&#x27;./components/Home&#x27;),
    body: () =&gt; Home
  },
  {
    name: &#x27;Contact&#x27;,
    path: &#x27;contact&#x27;,
    preload: () =&gt; import(&#x27;./components/Contact&#x27;),
    body: () =&gt; Contact,
    children: [
      {
        name: &#x27;Contact Method&#x27;,
        path: &#x27;:method&#x27;,
        preload: () =&gt; import(&#x27;./components/ContactMethod&#x27;),
        body: () =&gt; ContactMethod
      }
    ]
  }
];</pre></div><div class="section"><h2 id="saving">Saving our imports<a class="header-link" href="/guides/code-splitting/#saving">#</a></h2><p>That will load our components when their route matches, but we still don&#x27;t have access to the component functions that we need in order to render. We will need to use a<!-- --> <code class="language-javascript">then</code> call to our <code class="language-javascript">import()</code> Promises in order to access the component functions.</p><pre class="language-javascript">let Home;
let Contact;
let ContactMethod;

const routes = [
  {
    name: &#x27;Home&#x27;,
    path: &#x27;&#x27;,
    preload: () =&gt; (
      import(&#x27;./components/Home&#x27;).then(module =&gt; {
        Home = module.default;
      })
    ),
    body: () =&gt; Home
  },
  {
    name: &#x27;Contact&#x27;,
    path: &#x27;contact&#x27;,
    preload: () =&gt; (
      import(&#x27;./components/Contact&#x27;).then(module =&gt; {
        Contact = module.default;
      })
    ),
    body: () =&gt; Contact,
    children: [
      {
        name: &#x27;Contact Method&#x27;,
        path: &#x27;:method&#x27;,
        preload: () =&gt; (
          import(&#x27;./components/ContactMethod&#x27;).then(module =&gt; {
            ContactMethod = module.default;
          })
        ),
        body: () =&gt; ContactMethod
      }
    ]
  }
];</pre></div><div class="section"><h2 id="storing">Storing our imports<a class="header-link" href="/guides/code-splitting/#storing">#</a></h2><p>Our application will now only load components when they are needed and will correctly render. However, it is a bit ugly and error prone to define variables for all of our routes. Instead we can create a &quot;store&quot; where we can store references to each route&#x27;s component. The simplest store is an object, so we will start with that.</p><pre class="language-javascript">const store = {}

const routes = [
  {
    name: &#x27;Home&#x27;,
    path: &#x27;&#x27;,
    preload: () =&gt; (
      import(&#x27;./components/Home&#x27;).then(module =&gt; {
        store[&#x27;Home&#x27;] = module.default;
      })
    ),
    body: () =&gt; store[&#x27;Home&#x27;]
  },
  {
    name: &#x27;Contact&#x27;,
    path: &#x27;contact&#x27;,
    preload: () =&gt; (
      import(&#x27;./components/Contact&#x27;).then(module =&gt; {
        store[&#x27;Contact&#x27;] = module.default;
      })
    ),
    body: () =&gt; store[&#x27;Contact&#x27;],
    children: [
      {
        name: &#x27;Contact Method&#x27;,
        path: &#x27;:method&#x27;,
        preload: () =&gt; (
          import(&#x27;./components/ContactMethod&#x27;).then(module =&gt; {
            store[&#x27;ContactMethod&#x27;] = module.default;
          })
        ),
        body: () =&gt; store[&#x27;ContactMethod&#x27;]
      }
    ]
  }
];</pre><div class="subsection"><h3 id="better-store">A better store<a class="header-link" href="/guides/code-splitting/#better-store">#</a></h3><p>That should be sufficient, although it is not an error proof approach. Our preload functions currently do nothing when there are errors in importing the components. What you do when that happens is up to you, but you would most likely want to have a default component that you display when the error occurs.</p><pre class="language-jsx">const defaultComponent = () =&gt; &lt;div&gt;Uh oh, something must have gone wrong&lt;/div&gt;;
const store = {
  stored: {},
  set: function(name, value) {
    this.stored[name] = value;
  },
  get: function(name) {
    return this.stored[name] || defaultComponent;
  }
}

// usage
{
  ...,
  preload: () =&gt; (
    import(&#x27;./components/Something&#x27;)
      .then(module =&gt; {
        store.set(&#x27;Something&#x27;, module.default);
      })
      .catch(err =&gt; {
        console.error(err);
        store.set(&#x27;Something&#x27;, defaultComponent);
      })
  ),
  body: () =&gt; store.get(&#x27;Something&#x27;)
}</pre></div></div><div class="section"><h2 id="next">Next<a class="header-link" href="/guides/code-splitting/#next">#</a></h2><p>The approaches taken here are not the only way to do code splitting. You may choose to skip the preload method and do code splitting at other points in your application. You may also create a more full-fledged solution for storing loaded imports. Whatever path you decide to go, hopefully this has shown you that setting up code splitting with the preload property is fairly simple to do. If you are using Webpack and want to reduce your initial bundle size, preload is a great way to accomplish this.</p><p>Next, we will take a look at a related route property:<!-- --> <a href="/guides/load/">load</a>.</p></div></div><div class="sidebar"><h2>Guides</h2><ul><li class="link-group"><h3>basic</h3><ul class="link-list"><li class="solo"><a href="/guides/installation/">Installation</a></li><li class="solo"><a href="/guides/getting-started/">Getting Started</a></li><li class="solo"><a href="/guides/routes/">All About Routes</a></li><li class="solo"><a href="/guides/responses/">Rendering with Responses</a></li></ul></li><li class="link-group"><h3>advanced</h3><ul class="link-list"><li class="solo"><a href="/guides/addons/">Using Addons</a></li><li class="solo"><a href="/guides/side-effects/">Using Side Effects</a></li><li class="solo"><a href="/guides/response-caching/">Response Caching</a></li><li class="solo"><a class="active" href="/guides/code-splitting/">Code Splitting with the Preload Property</a></li><li class="solo"><a href="/guides/load/">The Load Property</a></li><li class="solo"><a href="/guides/react/">React Basics</a></li></ul></li><li class="link-group"><h3>migration</h3><ul class="link-list"><li class="solo"><a href="/guides/migrate-rrv3/">Migrate from React Router v2/3 to Curi</a></li></ul></li></ul></div></div></main></div></div>
    <script src="https://unpkg.com/react@16.0.0/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16.0.0/umd/react-dom.production.min.js"></script>
    <script src="/static/js/prism.js"></script>
    <script src="/static/js/bundle.js"></script>
  </body>
</html>
