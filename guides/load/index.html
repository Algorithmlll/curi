<!doctype html>
<html>
  <head>
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Load Property Guide | Curi Documentation</title>
    <link href="https://fonts.googleapis.com/css?family=Zilla+Slab:300,400" rel="stylesheet">
    <link href="/static/css/index.css" rel="stylesheet">
  </head>
  <body>
    <div id="root"><div data-reactroot=""><header><nav><ul><li><a class="home-link" href="/">Curi</a></li><li><a href="/packages">Packages</a></li><li><a href="/tutorial/01-introduction">Tutorial</a></li><li><a href="/guides/getting-started/">Guides</a></li><li><a href="/examples">Examples</a></li><li><a href="https://github.com/pshrmn/curi">GitHub</a></li></ul></nav></header><main><div class="guide"><div class="content"><h1>The Load Property</h1><p>In the code splitting guide, we used the preload property of routes. Routes also have a load property. The biggest difference between the two is that load is called every time a route matches, whereas preload is only called the first time a route matches.</p><p>load is where you should perform any data loading for the route. We&#x27;ll start a new application here, which is a basic recipe site. We want to have a route for a recipe list page as well as a route for specific recipes.</p><pre class="language-javascript">const routes = [
  {
    name: &#x27;Recipe List&#x27;,
    path: &#x27;recipes&#x27;,
    body: () =&gt; RecipeList
  },
  {
    name: &#x27;Recipe&#x27;,
    path: &#x27;recipe/:id&#x27;,
    body: () =&gt; Recipe
  }
];</pre><p>Whenever the Recipe List route matches, we want to fetch a list of recipes from the server. When the Recipe route matches, we just want one specific recipe (using the id param from the path).</p><p>The load function will be passed three arguments: a &quot;route&quot; object that contains <code class="language-javascript">params</code>, <code class="language-javascript">location</code> and <code class="language-javascript">name</code> properties, a modifiers object, and the object containing all of your Curi addons. The modifiers object has a few methods that you can call in order to modify the response object that will be generated. They are <code class="language-javascript">fail</code>, <code class="language-javascript">setStatus</code>,<!-- --> <code class="language-javascript">setData</code> and <code class="language-javascript">redirect</code>. Each is explained in more detail in the<!-- --> <a href="/guides/routes/#load">all about routes</a> <!-- -->guide. Here, we will use the last two: setData and redirect.</p><p>First we will add a load function to our Recipe route. This function will make a request to our (fake) API. Then, we will call response.setData to attach our loaded data to the response.</p><pre class="language-javascript">{
  name: &#x27;Recipe&#x27;,
  path: &#x27;recipe/:id&#x27;,
  body: () =&gt; Recipe,
  load: (route, modifiers) =&gt; {
    return fakeAPI.getRecipe(route.params.id)
      .then(data =&gt; {
        modifiers.setData(data);
      });
  }
}</pre><p>Now, when we navigate to /recipe/chocolate-chip-cookies, our load function will call the fake API function to load the recipe and set the loaded data for the response. That means that the data we load will be available on the generated response object as response.data.</p><p>One possible downside to the implementation of load above is that we will be making requests to our API every time the route loads. To prevent this, you might want to add a data cache to your application. Using this, you can store the results of previous requests and use that for subsequent requests instead of having to request the data from the server again.</p><pre class="language-javascript">{
  name: &#x27;Recipe List&#x27;,
  path: &#x27;recipes&#x27;,
  body: () =&gt; RecipeList,
  load: () =&gt; {
    if (cache.has(&#x27;recipes&#x27;)) {
      return Promise.resolve(cache.get(&#x27;recipes&#x27;));
    }

    return fakeAPI.getRecipes()
      .then(data =&gt; {
        cache.set(&#x27;recipes&#x27;, data);
        return data;
      });
  }
}</pre><p>If at some point in time we decide that we want to change our URI pathname structure, we can also use the load function to redirect.</p><p>By calling the modifier&#x27;s redirect method, you can specify the URI that we should redirect to. As always, with Curi you aren&#x27;t expected to have to manually generate pathnames. Instead, you can use <code class="language-javascript">addons.pathname</code>.</p><pre class="language-javascript">{
  name: &#x27;Old Recipe&#x27;,
  path: &#x27;r/:id&#x27;,
  load: ({ params, location }, modifiers, addons) =&gt; {
    const pathname = addons.pathname(&#x27;Recipe&#x27;, params);
    // destructure the current location to preserve
    // query/hash values
    modifiers.redirect({ ...location, pathname });
  }
}</pre><div class="note"><strong>Note:</strong> <!-- -->This does not actually perform a redirect. Instead, it will make it so that the emitted response is a &quot;redirect&quot; response, with a redirectTo property you can use to redirect manually. Below is an example of a render function (passed to a<!-- --> <code class="language-jsx"><!-- -->&lt;<!-- -->Navigator<!-- -->&gt;</code>) that renders a <code class="language-jsx"><!-- -->&lt;<!-- -->Redirect<!-- -->&gt;</code> <!-- -->when the response contains a redirectTo value.</div><pre class="language-javascript">function renderFunction(response) {
  if (response.redirectTo) {
    return &lt;Redirect to={response.redirectTo} /&gt;
  }
  // ...
}</pre><p>load is a great place to do any route setup prior to actually rendering the route. Please remember, however, that your application will not be re-rendering until after the load function has resolved. If you have a long running load function, you may wish to implement some sort of loading display. The prefetching data example shows one approach to how to do this.</p></div><div class="sidebar"><h2>Guides</h2><ul><li class="link-group"><h3>basic</h3><ul class="link-list"><li class="solo"><a href="/guides/installation/">Installation</a></li><li class="solo"><a href="/guides/getting-started/">Getting Started</a></li><li class="solo"><a href="/guides/routes/">All About Routes</a></li><li class="solo"><a href="/guides/responses/">Rendering with Responses</a></li></ul></li><li class="link-group"><h3>advanced</h3><ul class="link-list"><li class="solo"><a href="/guides/addons/">Using Addons</a></li><li class="solo"><a href="/guides/side-effects/">Using Side Effects</a></li><li class="solo"><a href="/guides/response-caching/">Response Caching</a></li><li class="solo"><a href="/guides/code-splitting/">Code Splitting with the Preload Property</a></li><li class="solo"><a class="active" href="/guides/load/">The Load Property</a></li><li class="solo"><a href="/guides/react/">React Basics</a></li></ul></li><li class="link-group"><h3>migration</h3><ul class="link-list"><li class="solo"><a href="/guides/migrate-rrv3/">Migrate from React Router v2/3 to Curi</a></li></ul></li></ul></div></div></main></div></div>
    <script src="https://unpkg.com/react@16.0.0/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16.0.0/umd/react-dom.production.min.js"></script>
    <script src="/static/js/prism.js"></script>
    <script src="/static/js/bundle.js"></script>
  </body>
</html>
