<!doctype html>
<html>
  <head>
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Getting Started Guide | Curi Documentation</title>
    <link href="https://fonts.googleapis.com/css?family=Zilla+Slab:300,400" rel="stylesheet">
    <link href="/static/css/index.css" rel="stylesheet">
  </head>
  <body>
    <div id="root"><div data-reactroot=""><header><nav><ul><li><a class="home-link" href="/">Curi</a></li><li><a href="/packages">Packages</a></li><li><a href="/tutorial/01-introduction">Tutorial</a></li><li><a href="/guides/getting-started/">Guides</a></li><li><a href="/examples">Examples</a></li><li><a href="https://github.com/pshrmn/curi">GitHub</a></li></ul></nav></header><main><div class="guide"><div class="content"><h1>Getting Started</h1><p>Curi aims to be easy to setup. To get started, you just need to create a Hickory history object and an array of route objects. Pass those as arguments to the<!-- --> <code class="language-javascript">createConfig</code> function to create your configuration object. Then, subscribe to the configuration object using <code class="language-javascript">config.subscribe()</code>. The function you pass to <code class="language-javascript">config.subscribe</code> will be called every time the location changes. You can use this to (re-)render your application based on the response.</p><div class="section"><h2 id="history-object">The History Object<a class="header-link" href="/guides/getting-started/#history-object">#</a></h2><p>Curi&#x27;s navigation is powered by the <a href="https://github.com/pshrmn/hickory">Hickory</a> <!-- -->package. You just need to pick which type of Hickory history object is right for your application.</p><pre class="language-javascript">// Use Browser when your website has a dynamic server
import Browser from &#x27;@hickory/browser&#x27;;
const browserHistory = Browser();

// Use Hash when your website uses a static file server
import Hash from &#x27;@hickory/hash&#x27;;
const hashHistory = Hash();

// Use InMemory when your application doesn&#x27;t run in a browser
import InMemory from &#x27;@hickory/in-memory&#x27;;
const memoryHistory = InMemory();</pre><p>Each history object has essentially the same API (InMemory has a few extra properties). The most important properties to know are the location object as well as the navigate, push, and replace methods.</p><p></p><pre class="language-javascript">// the location property is the current location object
browserHistory.location === {
  pathname: &#x27;/guides/getting-started&#x27;,
  ...
};

// the push method will navigate to a new location
browserHistory.push({ pathname: &#x27;/guides/installation&#x27; });

// the replace method will replace the current location
// with the provided one
browserHistory.push({ pathname: &#x27;/guides/confirming-navigation&#x27; });

// the navigate method will choose whether to push or replace for you
browserHistory.navigate({ pathname: &#x27;/guides/getting-started&#x27; });
</pre></div><div class="section"><h2 id="routes-array">The Routes Array<a class="header-link" href="/guides/getting-started/#routes-array">#</a></h2><p>Routes are objects with two required properties: name and path.</p><p>Paths can be any valid <a href="https://github.com/pillarjs/path-to-regexp">path-to-regexp</a> <!-- -->string. It is just important that you do not begin the string with a forward slash (/). Forward slashes are fine anywhere else in the path. (<code class="language-javascript">this/is/fine</code>, but <!-- --> <code class="language-javascript">/this/is/not</code>).</p><p>The names are used to generate URIs for you. With Curi, you never have to write a URI&#x27;s pathname string yourself. It is required that all of your routes have unique names. This is because Curi generates location pathnames using route names (and params for non-static paths).</p><pre class="language-javascript">const routes = [
  {
    name: &#x27;Home&#x27;,
    path: &#x27;&#x27;, // matches the pathname /
    ...
  },
  ...
]</pre><p>How route matching works and the other route properties are explained more in-depth in the <a href="/guides/routes/">All About Routes</a> guide.</p></div><div class="section"><h2 id="configuration-object">The Configuration Object<a class="header-link" href="/guides/getting-started/#configuration-object">#</a></h2><p>Once you have your Hickory history object and your routes array, you just need to pass them to the default export from the Curi package (which we will name<!-- --> <code class="language-javascript">createConfig</code> here).</p><pre class="language-javascript">import createConfig from &#x27;curi&#x27;;
import Browser from &#x27;@hickory/browser&#x27;;
import routes from &#x27;./routes&#x27;;

const history = Browser();
const config = createConfig(history, routes);
</pre><div class="subsection"><h3 id="other-configuration-options">Other configuration options<a class="header-link" href="/guides/getting-started/#other-configuration-options">#</a></h3><p>The <code class="language-javascript">createConfig</code> function can also take an optional third argument, which is an options object. You can use this to pass <a href="/guides/addons/">addons</a>,<!-- --> <a href="/guides/side-effects/">side effects</a>, a<!-- --> <a href="/guides/response-caching/">cache</a>, and a<!-- --> <a href="https://github.com/pillarjs/path-to-regexp#compile-reverse-path-to-regexp"><code class="language-javascript">pathnameOptions</code></a> object to your configuration object.</p><pre class="language-javascript">const config = createConfig(history, routes, {
  addons: [...],
  sideEffects: [...],
  cache: cacheObject,
  pathnameOptions: { encode: x =&gt; x }
});</pre></div></div><div class="section"><h2>Responses<a class="header-link" href="/guides/getting-started/">#</a></h2><p>Whenever navigation happens, a new location object is created by Hickory. Curi uses that location object&#x27;s pathname property to match against all of your routes. When it finds one that matches, it uses that route object to create a response object. You can subscribe to a Curi configuration object, and when a new response is created, your subscriber function will be called with the response.</p><pre class="language-javascript">const config = createConfig(history, routes);
config.subscribe(response =&gt; {
  // whenever the location changes, this function is called
  // you can use this function to re-render your application
  // using the new response object
});
</pre><p>Responses are generated asynchronously. A Curi configuration object has a<!-- --> <code class="language-javascript">subscribe</code> function that you can use to register a function to be called whenever a new response is generated.</p><pre class="language-javascript">const config = createConfig(history, routes);
// wait to render until a response is generated
config.subscribe((response, action) =&gt; {
  // now we can render using the response
});</pre><p>Your location-based rendering will be centered around these response objects, so you should be familiar with the different properties that will be available to you. We will get into more details about responses in the<!-- --> <a href="/guides/responses/">Rendering with Responses</a> guide, but for now we will just go over how a route maps to a response.</p><pre class="language-javascript">// if you have the following routes
const routes = [
  ...,
  {
    name: &#x27;Album&#x27;,
    path: &#x27;photos/:albumID&#x27;,
    ...,
    children: [
      {
        name: &#x27;Photo&#x27;,
        path: &#x27;:photoID&#x27;,
        body: () =&gt; Photo
      }
    ]
  }
];
// when the user visits the URI /photos/6789/12345
// the following response object would be created:

{
  // The location key
  key: &#x27;1.0&#x27;,

  // The location object used to generate the response.
  location: { pathname: &#x27;/photos/6789/12345&#x27;, ... },

  // The value returned by the route&#x27;s body function
  body: Photo,

  // The name of the best matching route
  name: &#x27;Photo&#x27;,

  // The name of ancestor routes that matched
  // part of the location&#x27;s pathname
  partials: [&#x27;Album&#x27;],

  // An object containing the values parsed
  // from the pathname by path-to-regexp.
  params: { photoID: 12345, albumID: 6789 },

  // There are a few more properties as well. Please read
  // the Rendering with Responses guide to see those
}</pre></div><h2>Next</h2><p>Now that you know the core of how Curi works, let&#x27;s take a closer look at routes with the <a href="/guides/routes/">All About Routes</a> guide.</p></div><div class="sidebar"><h2>Guides</h2><ul><li class="link-group"><h3>basic</h3><ul class="link-list"><li class="solo"><a href="/guides/installation/">Installation</a></li><li class="solo"><a class="active" href="/guides/getting-started/">Getting Started</a></li><li class="solo"><a href="/guides/routes/">All About Routes</a></li><li class="solo"><a href="/guides/responses/">Rendering with Responses</a></li></ul></li><li class="link-group"><h3>advanced</h3><ul class="link-list"><li class="solo"><a href="/guides/addons/">Using Addons</a></li><li class="solo"><a href="/guides/side-effects/">Using Side Effects</a></li><li class="solo"><a href="/guides/response-caching/">Response Caching</a></li><li class="solo"><a href="/guides/code-splitting/">Code Splitting with the Preload Property</a></li><li class="solo"><a href="/guides/load/">The Load Property</a></li><li class="solo"><a href="/guides/react/">React Basics</a></li></ul></li><li class="link-group"><h3>migration</h3><ul class="link-list"><li class="solo"><a href="/guides/migrate-rrv3/">Migrate from React Router v2/3 to Curi</a></li></ul></li></ul></div></div></main></div></div>
    <script src="https://unpkg.com/react@16.0.0/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16.0.0/umd/react-dom.production.min.js"></script>
    <script src="/static/js/prism.js"></script>
    <script src="/static/js/bundle.js"></script>
  </body>
</html>
