<!doctype html>
<html lang="en">
  <head>
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Apollo Integration Guide | Curi Documentation</title>
    <link href="https://fonts.googleapis.com/css?family=Zilla+Slab:300,400" rel="stylesheet">
    <link href="/static/css/prism.css" rel="stylesheet">
    <link href="/static/css/index.css" rel="stylesheet">
  </head>
  <body>
    <div id="root"><header><nav><ul><li><a class="home-link " href="/">Curi</a></li><li><a class=" " href="/packages">Packages</a></li><li><a class=" " href="/guides/creating-a-router/">Guides</a></li><li><a class=" " href="/tutorial">Tutorials</a></li><li><a class=" " href="/examples">Examples</a></li><li><a href="https://github.com/pshrmn/curi">GitHub</a></li></ul></nav></header><main tabindex="-1" style="outline:none"><div class="page guide"><div class="content" style="outline:none"><h1>Apollo Integration</h1><div class="side-by-side"><div class="explanation"><p><a href="https://apollographql.com">Apollo</a> is a great solution for managing an application&#x27;s data using<!-- --> <a href="http://graphql.org">GraphQL</a>.</p><p>There are a few different implementation strategies for integrating Apollo and Curi based on how tightly you want them to be paired.</p><div class="note"><strong>Note:</strong> <p>This guide only covers integration between Curi and Apollo. If you are not already familiar with how to use Apollo, you will want to learn that first.</p><p>Also, this guide will only be referencing Apollo&#x27;s React implementation, but the principles are the same no matter how you render your application.</p></div></div></div><div class="section" id="setup"><h2>Setup<a class="header-link" href="/guides/apollo/#setup">#</a></h2><div class="side-by-side"><div class="explanation"><p>Your application&#x27;s Apollo client instance should be defined in its own module so that it can be imported throughout the application.</p></div><div class="code-block"><pre><code class="language-javascript">// apollo.js
import ApolloClient from &quot;apollo-boost&quot;;

export default ApolloClient({
  uri: &quot;https://example.com/graphql&quot;
});</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>Apollo&#x27;s React package provides an <code class="inline-code language-jsx">&lt;<!-- -->ApolloProvider<!-- -->&gt;</code> <!-- -->component for accessing your Apollo client throughout the application. The <code class="inline-code language-jsx">&lt;<!-- -->CuriProvider<!-- -->&gt;</code> should be a descendant of the <code class="inline-code language-jsx">&lt;<!-- -->ApolloProvider<!-- -->&gt;</code> because we don&#x27;t need to re-render the<!-- --> <code class="inline-code language-jsx">&lt;<!-- -->ApolloProvider<!-- -->&gt;</code> for every new response.</p></div><div class="code-block"><pre><code class="language-jsx">import { ApolloProvider } from &quot;react-apollo&quot;;
import { CuriProvider } from &quot;@curi/react&quot;;

ReactDOM.render((
  &lt;ApolloProvider client={client}&gt;
    &lt;CuriProvider router={router}&gt;
      {() =&gt; {...}}
    &lt;/CuriProvider&gt;
  &lt;/ApolloProvider&gt;
), holder);</code></pre></div></div></div><div class="section" id="loose-pairing"><h2>Loose Pairing<a class="header-link" href="/guides/apollo/#loose-pairing">#</a></h2><div class="side-by-side"><div class="explanation"><p>Apollo and Curi don&#x27;t actually have to know about each other. Curi can create a response without doing any data fetching and let Apollo handle that with its <code class="inline-code language-jsx">&lt;<!-- -->Query<!-- -->&gt;</code> component.</p></div><div class="code-block"><pre><code class="language-javascript">// routes.js
import Noun from &quot;./pages/Noun&quot;;

// nothing Apollo related in here
const routes = [
  {
    name: &#x27;Noun&#x27;,
    path: &#x27;noun/:word&#x27;,
    response: () =&gt; {
      return {
        body: Noun
      };
    }
  }
];</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>Any location data that a query needs can be taken from the response object. The best way to access this from your components would be to pass the <code class="inline-code language-javascript">response</code> to the components rendered in the<!-- --> <code class="inline-code language-jsx">&lt;<!-- -->CuriProvider<!-- -->&gt;</code>&#x27;s <code class="inline-code language-javascript">children</code> prop, which is a render-invoked function.</p></div><div class="code-block"><pre><code class="language-jsx">// index.js
ReactDOM.render((
  &lt;ApolloProvider client={client}&gt;
    &lt;CuriProvider router={router}&gt;
      {({ response }) =&gt; {
        const { body:Body } = response;
        return &lt;Body response={response} /&gt;;
      }}
    &lt;/CuriProvider&gt;
  &lt;/ApolloProvider&gt;
), holder);</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>Because we pass the <code class="inline-code language-javascript">response</code> to the route&#x27;s<!-- --> <code class="inline-code language-javascript">body</code> component, we can pass a <code class="inline-code language-jsx">&lt;<!-- -->Query<!-- -->&gt;</code> the response&#x27;s location params using <code class="inline-code language-javascript">props.response.params</code>.</p></div><div class="code-block"><pre><code class="language-jsx">// pages/Nouns.js
import { Query } from &quot;react-apollo&quot;;

const GET_NOUN = gql`
  query noun($word: String!) {
    noun(word: $word) {
      word,
      type,
      definition
    }
  }
`;

// use the &quot;word&quot; param from the response props
// to query the correct data
const Noun = ({ response }) =&gt; (
  &lt;Query
    query={GET_NOUN}
    variables={{ word: response.params.word }}
  &gt;
    {({ loading, error, data }) =&gt; {
      if (loading) {
        return &lt;Loading /&gt;;
      }
      // ...

      return (
        &lt;div&gt;
          &lt;h1&gt;{data.noun.word}&lt;/h1&gt;
          &lt;p&gt;{data.noun.definition}&lt;/p&gt;
        &lt;/div&gt;
      )
    }}
  &lt;/Query&gt;
);</code></pre></div></div></div><div class="section" id="tight-pairing"><h2>Tight Pairing<a class="header-link" href="/guides/apollo/#tight-pairing">#</a></h2><div class="side-by-side"><div class="explanation"><p>You can use your Apollo client instance to call queries in a route&#x27;s<!-- --> <code class="inline-code language-javascript">match</code> functions. <code class="inline-code language-javascript">match</code> functions are expected to return a Promise, which is exactly what <code class="inline-code language-javascript">client.query()</code> <!-- -->returns, so tightly pairing Curi and Apollo is mostly center around using a <code class="inline-code language-javascript">match</code> functoin to return a<!-- --> <code class="inline-code language-javascript">client.query()</code> call. This will delay navigation until after a route&#x27;s GraphQL data has been loaded by Apollo.</p></div><div class="code-block"><pre><code class="language-javascript">import client from &quot;./apollo&quot;;
import { EXAMPLE_QUERY } from &quot;./queries&quot;;

const routes = [
  {
    name: &quot;Example&quot;,
    path: &quot;example/:id&quot;,
    match: {
      data({ params }) {
        return client.query({
          query: EXAMPLE_QUERY,
          variables: { id: params.id }
        });
      }
    }
  }
];</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>There are two strategies for doing this. Both approaches require you to be able to import your Apollo client in the module where you define your routes, which is why we created client in its own module in the <a href="/guides/apollo/#setup">setup</a> section.</p></div><div class="code-block"><pre><code class="language-javascript">// index.js
import client from &quot;./apollo&quot;;

ReactDOM.render((
  &lt;ApolloProvider client={client}&gt;
    /*...*/
  &lt;/ApolloProvider&gt;
), holder);

// routes.js
import client from &quot;./apollo&quot;;

// ...</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>The first approach is to avoid the <code class="inline-code language-jsx">&lt;<!-- -->Query<!-- -->&gt;</code> altogether. Instead, you can use a route&#x27;s <code class="inline-code language-javascript">response()</code> property to attach the data fetched by Apollo directly to a response through its<!-- --> <code class="inline-code language-javascript">data</code> property.</p><p>While we know at this point that the query has executed, we should also check <code class="inline-code language-javascript">resolved.error</code> in the <code class="inline-code language-javascript">response()</code> <!-- -->function to ensure that the query was executed successfully.</p></div><div class="code-block"><pre><code class="language-javascript">// routes.js
import client from &quot;./apollo&quot;;
import GET_VERB from &quot;./queries&quot;;

import Verb from &quot;./pages/Verb&quot;;

export default [
  {
    name: &quot;Verb&quot;,
    path: &quot;verb/:word&quot;,
    match: {
      verb({ params }) {
        return client.query({
          query: GET_VERB,
          variables: { word: params.word }
        })
      }
    },
    response({ error, resolved }) {
      if (error) {
        // handle failed queries
      }
      return {
        body: Verb,
        data: resolved.verb.data
      }
    }
  }
];</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>In the response&#x27;s <code class="inline-code language-javascript">body</code> component, you would access the query data through the <code class="inline-code language-javascript">response</code>&#x27;s <code class="inline-code language-javascript">data</code> <!-- -->property.</p></div><div class="code-block"><pre><code class="language-jsx">// pages/Verb.js
const Verb = ({ response }) =&gt; (
  &lt;div&gt;
    &lt;h1&gt;{response.data.verb.word}&lt;/h1&gt;
    &lt;p&gt;
      {response.data.verb.definition}
    &lt;/p&gt;
  &lt;/div&gt;
)</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>The second approach is to use a <code class="inline-code language-javascript">match</code> function as a way to cache the data, but also use <code class="inline-code language-jsx">&lt;<!-- -->Query<!-- -->&gt;</code>. With this approach, we do not have to attach the query data to the response; we are just relying on the fact that Apollo will execute and cache the results prior to navigation.</p></div><div class="code-block"><pre><code class="language-javascript">// routes.js
import client from &quot;./apollo&quot;;
import { GET_VERB } from &quot;./queries&quot;;

export default [
  {
    name: &quot;Verb&quot;,
    path: &quot;verb/:word&quot;,
    match: {
      data({ params }) {
        // load the data so it is cached by
        // your Apollo client
        return client.query({
          query: GET_VERB,
          variables: { word: params.word }
        })
      }
    }
  }
];</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>The route&#x27;s component will render a <code class="inline-code language-jsx">&lt;<!-- -->Query<!-- -->&gt;</code> to also call the query. Because the query has already been executed, Apollo will grab the data from its cache instead of re-sending a request to your server.</p></div><div class="code-block"><pre><code class="language-jsx">// pages/Verb.js
import { GET_VERB } from &quot;../queries&quot;;

const Verb = ({ response }) =&gt; (
  &lt;Query
    query={GET_VERB}
    variables={{ word: response.params.word }}
  &gt;
    {({ loading, error, data }) =&gt; {
      // ...
      return (
        &lt;div&gt;
          &lt;h1&gt;{data.verb.word}&lt;/h1&gt;
          &lt;p&gt;
            {data.verb.definition}
          &lt;/p&gt;
        &lt;/div&gt;
      );
    }}
  &lt;/Query&gt;
)</code></pre></div></div><div class="subsection" id="prefetch"><h3>Prefetching<a class="header-link" href="/guides/apollo/#prefetch">#</a></h3><div class="side-by-side"><div class="explanation"><p>One additional benefit of adding queries to routes using<!-- --> <code class="inline-code language-javascript">match</code> functions is that you can prefetch data for a route.</p><p>The<!-- --> <a href="/packages/@curi/route-prefetch/"><code class="inline-code language-javascript">@curi/route-prefetch</code></a> <!-- -->interaction lets you programmatically fetch the data for a route prior to navigating to a location.</p></div><div class="code-block"><pre><code class="language-javascript">// index.js
import prefetch from &quot;@curi/route-prefetch&quot;;

const routes = [
  {
    name: &quot;Example&quot;,
    path: &quot;example/:id&quot;,
    match {
      examples({ params }) {
        client.query({
          query: GET_EXAMPLES,
          variables: { id: params.id }
        })
      }
    }
  }
]

const router = curi(history, routes, {
  route: [prefetch()]
});

// this will call the GET_EXAMPLES query
// and Apollo will cache the results
router.route.prefetch(
  &quot;Example&quot;,
  { params: { id: 2 }}
);</code></pre></div></div><div class="side-by-side"><div class="explanation"><p><a href="/packages/@curi/react%20/"><code class="inline-code language-javascript">@curi/react</code></a> <!-- -->provides a <code class="inline-code language-jsx">&lt;<!-- -->Prefetch<!-- -->&gt;</code> component that will automatically prefetch the data for a route once an element becomes visible in the page.</p><p><code class="inline-code language-jsx">&lt;<!-- -->Prefetch<!-- -->&gt;</code> relies on you attaching a <code class="inline-code language-javascript">ref</code> to the element that should trigger prefetching. This uses the<!-- --> <a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver"><code class="inline-code language-javascript">IntersectionObserver</code></a> <!-- -->API to observe the element you attach the ref to.</p><p>Prefetching behavior can also be attached to other events, such as hovering over an element, but <code class="inline-code language-jsx">&lt;<!-- -->Prefetch<!-- -->&gt;</code> is specifically meant for prefetching when an element becomes visible.</p></div><div class="code-block"><pre><code class="language-jsx">import { Prefetch, Link } from &quot;@curi/react&quot;;
            
// don&#x27;t forget to attach the ref to a component!
const PrefetchLink = ({ to, params, ...rest }) =&gt; (
  &lt;Prefetch match={{ name: to, params }}&gt;
    {ref =&gt; (
      &lt;Link to={to} params={params} ref={ref} {...rest} /&gt;
    )}
  &lt;/Prefetch&gt;
);

// usage
&lt;PrefetchLink to=&quot;Example&quot; params={{ id: 3 }}&gt;
  Example 3
&lt;/Prefetch&gt;</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>If you want to get really fancy, <code class="inline-code language-jsx">&lt;<!-- -->Prefetch<!-- -->&gt;</code> also lets you access the prefetched data with the second argument to its render-invoked <code class="inline-code language-javascript">children</code> function. You can use this to update your UI to indicate that the data has loaded or even use the loaded data with some filler content.</p></div><div class="code-block"><pre><code class="language-jsx">const PrefetchLink = ({ to, params, children, ...rest }) =&gt; (
  &lt;Prefetch match={{ name: to, params }}&gt;
    {(ref, resolved) =&gt; (
      &lt;Link to={to} params={params} ref={ref} {...rest}&gt;
        {children}
        {resolved ? &lt;Loading /&gt; : &lt;Loaded /&gt;}
      &lt;/Link&gt;
    )}
  &lt;/Prefetch&gt;
);</code></pre></div></div></div></div></div><div class="page-links"><button type="button" class="toggler">Menu</button><div class="children"><h2>Guides</h2><ul><li class="link-group"><h3>basic</h3><ul class="link-list"><li class="solo"><a class=" " href="/guides/installation/">Installation</a></li><li class="solo"><a class=" " href="/guides/creating-a-router/">Creating a Router</a></li><li class="solo"><a class=" " href="/guides/routes-and-responses/">Routes &amp; Responses</a></li><li class="solo"><a class=" " href="/guides/sync-or-async/">Sync or Async</a></li><li class="solo"><a class=" " href="/guides/navigating-and-observing/">Navigating &amp; Observing</a></li></ul></li><li class="link-group"><h3>rendering</h3><ul class="link-list"><li class="solo"><a class=" " href="/guides/react/">React</a></li><li class="solo"><a class=" " href="/guides/react-native/">React Native</a></li><li class="solo"><a class=" " href="/guides/vue/">Vue</a></li><li class="solo"><a class=" " href="/guides/svelte/">Svelte</a></li></ul></li><li class="link-group"><h3>advanced</h3><ul class="link-list"><li class="solo"><a class=" " href="/guides/route-interactions/">Route Interactions</a></li><li class="solo"><a class=" " href="/guides/side-effects/">Side Effects</a></li><li class="solo"><a class=" " href="/guides/code-splitting/">Code Splitting</a></li><li class="solo"><a class=" " href="/guides/loading/">Loading Route Data</a></li><li class="solo"><a class=" " href="/guides/accessibility/">Accessibility</a></li><li class="solo"><a class=" active" href="/guides/apollo/">Apollo Integration</a></li></ul></li><li class="link-group"><h3>migration</h3><ul class="link-list"><li class="solo"><a class=" " href="/guides/migrate-rrv3/">React Router v2/3</a></li><li class="solo"><a class=" " href="/guides/migrate-rrv4/">React Router v4</a></li></ul></li></ul></div></div></div></main></div>
    <script src="https://cdn.polyfill.io/v2/polyfill.js?features=Object.assign,IntersectionObserver,IntersectionObserverEntry"></script>
    <script src="https://unpkg.com/react@16.3.1/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16.3.1/umd/react-dom.production.min.js"></script>
    <script src="/static/js/prism.js"></script>
    <script src="/static/js/bundle.js"></script>
  </body>
</html>
