<!doctype html>
<html>
  <head>
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>All About Routes Guide | Curi Documentation</title>
    <link href="https://fonts.googleapis.com/css?family=Zilla+Slab:300,400" rel="stylesheet">
    <link href="/static/css/index.css" rel="stylesheet">
  </head>
  <body>
    <div id="root"><div data-reactroot=""><header><nav><ul><li><a class="home-link" href="/">Curi</a></li><li><a href="/packages">Packages</a></li><li><a href="/tutorial/01-introduction">Tutorial</a></li><li><a href="/guides/getting-started/">Guides</a></li><li><a href="/examples">Examples</a></li><li><a href="https://github.com/pshrmn/curi">GitHub</a></li></ul></nav></header><main><div class="guide"><div class="content"><h1>All About Routes</h1><p>Routes are simply JavaScript objects with two required props: name and path. There are also a number of other props that you can use to enhance the routes. We will cover these below.</p><pre class="language-javascript">{
  name: &#x27;Home&#x27;,
  path: &#x27;&#x27;
};</pre><div class="section"><h2 id="matching-routes">Matching Routes<a class="header-link" href="/guides/routes/#matching-routes">#</a></h2><p>First, we should cover how route matching works. Curi takes an array of route objects. Whenever Curi receives a new location, it will walk over the route objects in the order that they are defined in the array.</p><p>Sometimes a route&#x27;s path with only partially match the location&#x27;s pathname. When this happens, the matching behavior will vary based on the route&#x27;s props. By default, routes perform exact matching. This means that when the route only matches part of the pathname, it does not count as a match.</p><pre class="language-javascript">// when the pathname is &#x27;/a/Run+The+Jewels+3/Hey+Kids&#x27;,
// the Album route will partially match the pathname. However,
// Curi looks for complete matches, so it will move on to the
// next route
{
  name: &#x27;Album&#x27;,
  path: &#x27;a/:album&#x27;
}</pre><p>However, if the route has children, then Curi will check if any of those routes form a complete match before moving on to the next route in the routes array.</p><pre class="language-javascript">// when the pathname is &#x27;/a/Coloring+Book/All+Night&#x27;,
// the Album route will partially match the pathname. Then,
// its child route Song will be tested and fully match the pathname.
{
  name: &#x27;Album&#x27;,
  path: &#x27;a/:album&#x27;,
  children: [
    {
      name: &#x27;Song&#x27;,
      path: &#x27;:title&#x27;
    }
  ]
}</pre><p>Another possibility happens when you use the <code class="language-javascript">pathOptions</code> object to set<!-- --> <code class="language-javascript">end: false</code>. When you do that, then a route the partially matches will consider itself matched.</p><pre class="language-javascript">// when the pathname is &#x27;/a/Good+Kid,+M.A.A.D+City/Poetic+Justice&#x27;,
// the Album route will partially match. However, because it sets
// end to false, the partial match will be used.
{
  name: &#x27;Album&#x27;,
  path: &#x27;a/:albumID&#x27;,
  pathOptions: {
    end: false
  }
}</pre><p>If none of your routes match a pathname, then Curi will set a &quot;404&quot; status on the response object. The body property of the response will also be <code class="language-javascript">undefined</code>, so it is important that your application checks the response&#x27;s status when it goes to render a response. You can also add a wildcard route (<code class="language-javascript">path: &#x27;*&#x27;</code>) to the end of your routes array, and that route will always match. You may want to still manually set the status to &quot;404&quot; for the wildcard route, but it is not required.</p></div><div class="section"><h2 id="route-properties">Route properties<a class="header-link" href="/guides/routes/#route-properties">#</a></h2><div class="subsection"><h3 id="name">name<a class="header-link" href="/guides/routes/#name">#</a></h3><p>A unique identifier. This should be a string or a symbol.</p></div><div class="subsection"><h3 id="path">path<a class="header-link" href="/guides/routes/#path">#</a></h3><p>A path-to-regexp style string. This should <strong>not</strong> have a leading slash. The string will be passed to path-to-regexp to generate a regular expression. Any<!-- --> <a href="https://github.com/pillarjs/path-to-regexp#parameters">parameters</a> will be identified so that they can be parsed out when matching against a location&#x27;s pathname.</p><div class="note"><strong>Note:</strong> <!-- -->While path-to-regexp supports arrays and RegExps, only string paths are supported here. This is because the path must also be reversible to create a pathname given params.</div></div><div class="subsection"><h3 id="pathOptions">pathOptions<a class="header-link" href="/guides/routes/#pathOptions">#</a></h3><p>If you need to provide different path options than<!-- --> <a href="https://github.com/pillarjs/path-to-regexp#usage">the defaults</a> used by path-to-regexp, you should specify them with a <code class="language-javascript">pathOptions</code> object.</p><div class="note"><strong>Note:</strong> <!-- -->If a route has a children array property, it will <strong>always</strong> have the <code class="language-javascript">end</code> <!-- --> path option set to false.</div></div><div class="subsection"><h3 id="body">body<a class="header-link" href="/guides/routes/#body">#</a></h3><p>The body property gives you the opportunity to set the body property of a response for a given route. This must be a function and its return value will be what is set as the response object&#x27;s body property.</p><pre class="language-javascript">// when the user visits /contact, the response object&#x27;s body
// property will be the Contact value
const contact = {
  name: &#x27;Contact&#x27;,
  path: &#x27;contact&#x27;,
  body: () =&gt; Contact
};</pre><p>While the above example returns a single value, you might have multiple page values that you want to associate with a route. In that case, you can return an object with a property for each one. Then, when you render the application, you would access the values using <code class="language-javascript">response.body.&lt;property-name&gt;</code>.<!-- --> <!-- -->If you take this approach, each route&#x27;s <code class="language-javascript">body</code> function should return an object with the same properties.</p><pre class="language-javascript">const routes = [
  {
    name: &#x27;Home&#x27;,
    path: &#x27;&#x27;,
    body: () =&gt; ({ main: Home, nav: HomeNav })
  },
  {
    name: &#x27;Contact&#x27;,
    path: &#x27;contact&#x27;,
    body: () =&gt; ({ main: Contact, nav: ContactNav })
  }
];

function render(response) {
  const { main, nav } = response.body
  ...
}</pre></div><div class="subsection"><h3 id="title">title<a class="header-link" href="/guides/routes/#title">#</a></h3><p>You can use the title property of a route to specify a title string that should be set on the response when that route matches. This can either be a string or a function. If it is a string, then<code class="language-javascript">response.title</code> will be set to the value of <code class="language-javascript">route.title</code>. If it is a function, it will be called (and passed the <code class="language-javascript">response.params</code> and<!-- --> <code class="language-javascript">response.data</code> values) to generate the title string.</p><p>If a route does not have a title property, when it matches, the response&#x27;s title property will be an empty string.</p><pre class="language-javascript">// as a string
{
  name: &#x27;Contact&#x27;,
  path: &#x27;contact&#x27;,
  title: &#x27;How to contact us&#x27;
}

// as a function
{
  name: &#x27;Contact Method&#x27;,
  path: &#x27;:method&#x27;,
  title: (params, data) =&gt; `Contact via ${params.method}`
}</pre></div><div class="subsection"><h3 id="children">children<a class="header-link" href="/guides/routes/#children">#</a></h3><p>An optional array of route objects. Any child routes will be matched relative to their parent route&#x27;s path. This means that if a parent route&#x27;s path string is &#x27;one&#x27; and a child route&#x27;s path string is &#x27;two&#x27;, the child will match when the pathname is &#x27;one/two&#x27;.</p></div><div class="subsection"><h3 id="preload">preload<a class="header-link" href="/guides/routes/#preload">#</a></h3><p>A function that will only be called the first time that a route matches. This should only be used for loading resources that are required for the route to display properly. For example, if you are doing code splitting with Webpack using <code class="language-javascript">import()</code>, you would load the modules in preload.</p><p>The preload function must return a Promise.</p><pre class="language-javascript">const about = {
  name: &#x27;About&#x27;,
  path: &#x27;about&#x27;,
  preload: () =&gt; {
    return import(&#x27;./components/About&#x27;)
      .then(module =&gt; AsyncStore.register(module.default));
  }
};</pre></div><div class="subsection"><h3 id="load">load<a class="header-link" href="/guides/routes/#load">#</a></h3><p>A function that can be used for data fetching as well as for triggering redirects. The load function will be passed the a &quot;route&quot; object containing the params object that is parsed from the location&#x27;s pathname (using the route and its ancestor&#x27;s paths), the current location, and then name of the matched route. Additionally, it will be passed a modifiers object that can be used to modify the response object that will be created and an object containing all of the registered Curi addons (the <code class="language-javascript">pathname</code> addon being particularly useful).</p><p>Like preload, load must return a Promise.</p><pre class="language-javascript">// set response data
const user = {
  name: &#x27;User&#x27;,
  path: &#x27;:id&#x27;,
  load: ({ params, location }, mod, addons) =&gt; {
    return fetch(`/api/users/${params.id}`)
      .then(resp =&gt; JSON.parse(resp))
      .then(data =&gt; mod.setData(data);)
      .catch(err =&gt; {
        mod.fail(err);
        mod.setStatus(404);
      });
  }
}

// set a permanent redirect
const routes = [
  {
    name: &#x27;Photo&#x27;,
    path: &#x27;p/:id&#x27;
  },
  {
    name: &#x27;Old Photo&#x27;,
    path: &#x27;photo/:id&#x27;,
    load: ({ params, location }, mod, addons) =&gt; {
      const pathname = addons.pathname(&#x27;Photo&#x27;, params);
      mod.redirect({ ...location, pathname }, 301);
    }
  }
]
// navigating to /photo/123 will automatically redirect to /p/123</pre><p>What is that modifiers object that gets passed to the load function? It contains a number of functions that you can use to modify the response. These functions are <code class="language-javascript">redirect</code>, <code class="language-javascript">fail</code>,<!-- --> <code class="language-javascript">setStatus</code>, and <code class="language-javascript">setData</code>.</p><ul><li><code class="language-javascript">redirect(to, code)</code> - This allows you to turn the response into a redirect response. When you application receives a redirect response, it should redirect to the new location (using your history object) instead of re-rendering. If you do not provide a code, then 301 will be used. Setting the status code is mostly important for rendering on the server. The <code class="language-javascript">to</code> argument should be a string or a location object. Once the response has been created, Curi will automatically redirect to the <code class="language-javascript">to</code> location.</li><li><code class="language-javascript">fail(error)</code> - A method to call when something goes wrong. This will add an error property to the response.</li><li><code class="language-javascript">setStatus(code)</code> - This method will set a new status for the response (the default status is 200 when a route matches and 404 when no routes match).</li><li><code class="language-javascript">setData(data)</code> - The value passed to this method will be set as the response&#x27;s data property.</li></ul></div><div class="subsection"><h3 id="params">params<a class="header-link" href="/guides/routes/#params">#</a></h3><p>When <code class="language-javascript">path-to-regexp</code> matches your paths, all parameters are extracted as strings. However, you might have some route params to be other types. You can provide functions to transform params using the <code class="language-javascript">route.params</code> <!-- -->object. To transform a param, its name should be the string value from the path. The paired value should be a function that takes a string (the value from the pathname) and returns a new value (transformed however you want).</p><pre class="language-javascript">const routes = [
  {
    name: &#x27;Number&#x27;,
    path: &#x27;number/:num&#x27;,
    params: {
      num: n =&gt; parseInt(n, 10)
    }
  }
]
// when the user visits /number/1,
// response.params will be { num: 1 } instead of { num: &quot;1&quot; }</pre></div><div class="subsection"><h3 id="extra">extra<a class="header-link" href="/guides/routes/#extra">#</a></h3><p>If you have any additional properties that you want attached to a route, use the <code class="language-javascript">extra</code> property. You will be able to use <code class="language-javascript">route.extra</code> in any custom addons or when a route matches via <code class="language-javascript">response.route.extra</code>.</p><p>You can attach anything you want to <code class="language-javascript">extra</code> or you may never find yourself needing to use this. One possible use case for <code class="language-javascript">extra</code> is that you could specify entrance/exit animation types. One route might want to fade in, while another might slide in.</p><pre class="language-javascript">const routes = [
  {
    name: &#x27;A Route&#x27;,
    path: &#x27;a-route&#x27;,
    extra: {
      transition: &#x27;fade&#x27;
    }
  },
  {
    name: &#x27;B Route&#x27;,
    path: &#x27;b-route&#x27;,
    extra: {
      enter: &#x27;slide-right&#x27;
    }
  }
];</pre></div></div><div><h2>Next</h2><p>Now that you know how to setup your routes, we can get to the good part: actually rendering your application using response objects. Check out the<!-- --> <a href="/guides/responses/">Rendering with Responses</a> guide to learn how.</p></div></div><div class="sidebar"><h2>Guides</h2><ul><li class="link-group"><h3>basic</h3><ul class="link-list"><li class="solo"><a href="/guides/installation/">Installation</a></li><li class="solo"><a href="/guides/getting-started/">Getting Started</a></li><li class="solo"><a class="active" href="/guides/routes/">All About Routes</a></li><li class="solo"><a href="/guides/responses/">Rendering with Responses</a></li></ul></li><li class="link-group"><h3>advanced</h3><ul class="link-list"><li class="solo"><a href="/guides/addons/">Using Addons</a></li><li class="solo"><a href="/guides/side-effects/">Using Side Effects</a></li><li class="solo"><a href="/guides/response-caching/">Response Caching</a></li><li class="solo"><a href="/guides/code-splitting/">Code Splitting with the Preload Property</a></li><li class="solo"><a href="/guides/load/">The Load Property</a></li><li class="solo"><a href="/guides/react/">React Basics</a></li></ul></li><li class="link-group"><h3>migration</h3><ul class="link-list"><li class="solo"><a href="/guides/migrate-rrv3/">Migrate from React Router v2/3 to Curi</a></li></ul></li></ul></div></div></main></div></div>
    <script src="https://unpkg.com/react@16.0.0/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16.0.0/umd/react-dom.production.min.js"></script>
    <script src="/static/js/prism.js"></script>
    <script src="/static/js/bundle.js"></script>
  </body>
</html>
