# curi-react-curious

[![npm][badge]][npm-link]

[badge]: https://img.shields.io/npm/v/curi-react-curious.svg
[npm-link]: https://npmjs.com/package/curi-react-curious

## Installation

```
npm install --save curi-react-curious
```

### Script

If you wish to use `curi-react-curious` through a `<script>` tag, there is a version available through unpkg.com.

```html
<script src="https://unpkg.com/curi-react-curious@0.2.0/dist/curi-react-curious.js"></script>
<script type="text/javascript">
  const curious = window.CuriReactCurious;
</script>
```

The version number above may not always be accurate. To ensure that you are using the most up to date version of the `curi-react-curious` script build, open https://unpkg.com/curi-react-curious/dist in your browser and copy the link address for the `curi-react-curious.js` file. That will provide you with the URI of the most recent release.

**Note:** If you are using the above script, you will have to include `react` and `prop-types` scripts yourself.

## `curious()`

The `curious` higher-order component creates a component that has a `curi` prop and a `response` prop. The `curi` prop is your application's configuration object. The `response` prop is the current response object generated by your Curi configuration object.

The primary use case for wanting to access the `curi` configuration object would be if you want to access your `history` instance to manually navigate or to call one of your Curi configuration object's addon functions.

One reason for accessing the current response object is to determine if a route is "active".

```js
const MyButton = curious((props) => {
  const { curi, to, text } = props;
  return (
    <button
     type='button'
      onClick={(e) => {
        e.preventDefault();
        const pathname = curi.addons.pathname(to);
        curi.history.push(pathname);
      }}
    >
      {text}
    </button>
  )
});
```

In order for `curious` to work, it needs to have an ancestor component that places your application's configuration object on React's `context`. If you use the `<Navigator>` component, this will be done for you.

```js
// assuming you have setup your application like this:
const config = createConfig(history, routes);
ReactDOM.render((
  <Navigator config={config}>
    {(response, config) => {
      return <App />;
    }}
  </Navigator>
), holder);

// The <MyButton> (from above) rendered by <App> will have a "curi" prop
// because it is wrapped by the "curious" HOC.
const App = () => (
  <div>
    ...
    <MyButton to='Some Page' text='Go to some other page' />
  </div>
);
```

### wrapper component props

#### `internalRef`

A ref function that you can use to access the wrapped component.

```js
const WrappedComponent = curious(MyComponent);

<WrappedComponent internalRef={node => ref = node} />
```

#### others

Any other props that you pass to the wrapper component (the one created by calling `curious`) will be passed to the wrapped component.

```js
const WrappedComponent = curious(MyComponent);

<WrappedComponent one='two' red='blue' />
// MyComponent's props: { curi: {...}, response: {...}, one: 'two', red: 'blue' }
```
