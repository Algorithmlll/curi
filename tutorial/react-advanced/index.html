<!doctype html>
<html lang="en">
  <head>
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tutorial React Advanced | Curi Documentation</title>
    <link href="https://fonts.googleapis.com/css?family=Zilla+Slab:300,400" rel="stylesheet">
    <link href="/static/css/prism.css" rel="stylesheet">
    <link href="/static/css/index.css" rel="stylesheet">
  </head>
  <body>
    <div id="root"><header><nav><ul><li><a class="home-link " href="/">Curi</a></li><li><a class=" " href="/packages">Packages</a></li><li><a class=" " href="/guides/getting-started/">Guides</a></li><li><a class=" active" href="/tutorial">Tutorials</a></li><li><a class=" " href="/examples">Examples</a></li><li><a href="https://github.com/pshrmn/curi">GitHub</a></li></ul></nav></header><main tabindex="-1" style="outline:none"><div class="page tutorial"><div class="content" style="outline:none"><h1>React Advanced Tutorial</h1><p>In this tutorial, we will be expanding on the website built in the<!-- --> <a href="/tutorial/react-basics">React basics tutorial</a>. We will take advantage of Curi&#x27;s async features to add code splitting and data preloading to the application.</p><div class="tutorial-outline"><p>In this tutorial, we will be doing the following:</p><ul><li>Learn how to code split routes.</li><li>Learn how to preload data for routes.</li></ul></div><div class="section" id="demo"><h2>Demo<a class="header-link" href="/tutorial/react-advanced#demo">#</a></h2><p>You can run a demo of the site we are building with CodeSandbox.</p><div class="demo"><iframe src="https://codesandbox.io/embed/github/curijs/react-advanced-tutorial/tree/master/" width="100%" height="600px" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p>Use the three buttons at the top of the Sandbox to toggle view modes. Clicking the menu button in the top left corner opens a menu to switch between files.</p></div></div><div class="section" id="setup"><h2>Setup<a class="header-link" href="/tutorial/react-advanced#setup">#</a></h2><div class="side-by-side"><div class="explanation"><p>If you did not complete the React basics tutorial, you should either clone its<!-- --> <a href="https://github.com/curijs/react-basic-tutorial/">repo</a> <!-- -->or fork its<!-- --> <a href="https://codesandbox.io/s/github/curijs/react-basic-tutorial/tree/master/">sandbox</a>.</p><p>If you are cloning the repo, you should also install its dependencies and then start the development server. The repo was made using <code class="inline-code language-javascript">yarn</code>, but if you only have NPM installed, you can use the analagous commands.</p></div><div class="code-block"><pre><code class="language-bash">git clone https://github.com/curijs/react-basic-tutorial react-advanced-tutorial
cd react-advanced-tutorial

yarn
yarn start
# or
npm install
npm run start</code></pre></div></div></div><div class="section" id="async"><h2>Async Routes<a class="header-link" href="/tutorial/react-advanced#async">#</a></h2><div class="side-by-side"><div class="explanation"><p>Curi lets you attach async code to a route, and when that route matches, a response will not be emitted until the async code has completed. There are two types of async code.</p><p>The first is a function that is only called the first time a route matches. This is useful for functions that only need to be run once, like importing a module.</p><p>The second is a function that is called every time a route matches. This is useful for routes with params that will load different data based on the params.</p><p>The async functions for a route are grouped under the route&#x27;s<!-- --> <code class="inline-code language-javascript">on</code> property. <code class="inline-code language-javascript">on.initial()</code> is only called the first time a route is matched (its result is cached and re-used on subsequent matches). <code class="inline-code language-javascript">on.every()</code> is called every time a route matches.</p></div><div class="code-block"><pre><code class="language-javascript">const routes = [
  {
    name: &quot;A Route&quot;,
    on: {
      initial: () =&gt; {
        // called the first time a route matches
      },
      every: () =&gt; {
        // called every time a route matches
      }
    }
  }
];</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>Both functions will be passed an object of the matched route properties, which you may use to specify what data to load.</p><p>Curi uses Promises to manage async code, so both functions should return Promises. If you want to return a value, you can use<!-- --> <code class="inline-code language-javascript">Promise.resolve()</code> to return it using a Promise.</p><p>You can access the values returned by these functions in the route&#x27;s<!-- --> <code class="inline-code language-javascript">response()</code> function. The object passed to<!-- --> <code class="inline-code language-javascript">response()</code> has a <code class="inline-code language-javascript">resolved</code> property that will contain these values (<code class="inline-code language-javascript">resolved.initial</code> is the value returned by <code class="inline-code language-javascript">on.initial()</code> and <code class="inline-code language-javascript">resolved.every</code> <!-- -->comes from <code class="inline-code language-javascript">on.every()</code>).</p></div><div class="code-block"><pre><code class="language-javascript">const routes = [
  {
    name: &quot;A Route&quot;,
    path: &quot;route/:id&quot;,
    on: {
      initial: () =&gt; {
        // called the first time a route matches
        return Promise.resolve(&quot;Initial&quot;);
      },
      every: ({ params }) =&gt; {
        // called every time a route matches
        return FakeAPI.get(params.id);
      }
    },
    response({ resolved }) {
      // resolved.initial === &quot;Initial&quot;
      // resolved.every === {...}; (result of API call)
    }
  }
];</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>There is one caveat to async routes: we cannot safely render a response right away. When a user loads your application and the first route that matches is asynchronous, then there is no response to render until the async code finishes. This means that if you attempt to render immediately creating a router, the<!-- --> <code class="inline-code language-javascript">response</code> that will be passed to the<!-- --> <code class="inline-code language-jsx">&lt;<!-- -->CuriProvider<!-- -->&gt;</code>&#x27;s <code class="inline-code language-javascript">children()</code> will be<!-- --> <code class="inline-code language-javascript">null</code>.</p><p>There are a few possible ways to handle this situation. The first is to delay rendering by placing your <code class="inline-code language-javascript">ReactDOM.render()</code> call inside of a <code class="inline-code language-javascript">router.respond()</code> callback. This will guarantee that the render isn&#x27;t called until the first response is ready. Alternatively, you can update the render-invoked<!-- --> <code class="inline-code language-javascript">children()</code> function to know what to do when<!-- --> <code class="inline-code language-javascript">response</code> is <code class="inline-code language-javascript">null</code>.</p><p>Which approach is best will depend on the specifics of an application. If there are routes that will take a long time for the initial load, you will probably want to render something while they load. For async code with short loading times, a blank screen might be more acceptable.</p></div><div class="code-block"><pre><code class="language-javascript">// delay rendering
const router = curi(...);
router.respond(() =&gt; {
  ReactDOM.render((
    &lt;CuriProvider&gt;
      {...}
    &lt;/CuriProvider&gt;
  ), holder);
});

// render using null response
ReactDOM.render((
  &lt;CuriProvider&gt;
    {({ response }) =&gt; {
      if (response == null) {
        return &lt;div&gt;Loading...&lt;/div&gt;;
      }
      const { body:Body } = response;
      return &lt;Body response={response} /&gt;;
    }}
  &lt;/CuriProvider&gt;
), holder);</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>For more information on async route properties, please refer to the<!-- --> <a href="/guides/routes/">routes guide</a>.</p></div></div></div><div class="section" id="code-splitting"><h2>Code Splitting<a class="header-link" href="/tutorial/react-advanced#code-splitting">#</a></h2><div class="side-by-side"><div class="explanation"><p>Code splitting works by &quot;dynamically&quot; importing modules using the<!-- --> <code class="inline-code language-javascript">import()</code> function. When bundlers like Webpack see<!-- --> <code class="inline-code language-javascript">import()</code> functions, they know to create a separate bundle for that module (and that module&#x27;s imports, etc.).</p><p>You can add a <code class="inline-code language-javascript">/* webpackChunkName: &quot;chunkName&quot; */</code> comment to an <code class="inline-code language-javascript">import()</code> call to let Webpack know what to name a code split bundle.</p><p>Create React App&#x27;s default configuration is already setup to support code splitting, but if you were creating your own Webpack configuration, you would need to use<!-- --> <a href="https://webpack.js.org/configuration/output/#output-chunkfilename"><code class="inline-code language-javascript">output.chunkFilename</code></a> <!-- -->to support code splitting.</p></div><div class="code-block"><pre><code class="language-javascript">// this creates a &quot;Test&quot; bundle
import(/* webpackChunkName: &quot;Test&quot; */ &quot;./components/Test.js&quot;)</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>Currently, the <code class="inline-code language-javascript">routes.js</code> module imports all of the route modules at the top of the file. In order to add code splitting, we need to switch to using <code class="inline-code language-javascript">import()</code>.</p><p>In the previous section, we outlined the differences between<!-- --> <code class="inline-code language-javascript">on.initial()</code> and <code class="inline-code language-javascript">on.every()</code>. Module loading is something that we only need to do once per route, so<!-- --> <code class="inline-code language-javascript">on.initial()</code> is ideal for code splitting.</p><p>Currently <code class="inline-code language-javascript">response()</code> returns an object whose<!-- --> <code class="inline-code language-javascript">body</code> property is a module imported at the top of the file. Now we want to change this to have <code class="inline-code language-javascript">body</code> be the imported module.</p></div><div class="code-block"><pre><code class="language-javascript">const routes = [
  {
    name: &quot;Test&quot;,
    path: &quot;test&quot;,
    on: {
      initial: () =&gt; import(/* webpackChunkName: &quot;Test&quot; */ &quot;./components/Test.js&quot;)
    }
  }
];</code></pre></div></div><div class="note"><strong>Note:</strong> <div class="side-by-side"><div class="explanation"><p><code class="inline-code language-javascript">import()</code> resolves a module object, not our component. Our components are exported using default exports, so they will be available as the module object&#x27;s <code class="inline-code language-javascript">default</code> property.</p><p>There are a couple different approaches that you can take to accessing the component from the module object.</p><p>The first is to use <code class="inline-code language-javascript">import().then()</code> to resolve the module object&#x27;s <code class="inline-code language-javascript">default</code> property.</p><p>The second is to reference <code class="inline-code language-javascript">resolved.initial.default</code> in our <code class="inline-code language-javascript">response()</code> functions.</p><p>Which you choose is mostly a matter of personal preference.</p></div><div class="code-block"><pre><code class="language-javascript">const routes = [
  {
    name: &quot;One&quot;,
    path: &quot;one&quot;,
    on: {
      initial: () =&gt; import(&quot;./components/One.js&quot;)
        .then(module =&gt; module.default)
    },
    response({ resolved }) {
      return {
        body: resolved.initial
      };
    }
  },
  {
    name: &quot;Two&quot;,
    path: &quot;two&quot;,
    on: {
      initial: () =&gt; import(&quot;./components/Two.js&quot;)
    },
    response({ resolved }) {
      return {
        body: resolved.initial.default
      };
    }
  }
];</code></pre></div></div></div><div class="side-by-side"><div class="explanation"><p>When a module fails to load, the error will be set as<!-- --> <code class="inline-code language-javascript">resolved.error</code>, but you would probably be better off setting a default error module to display. This tutorial is breezing over this, but it is something to consider (especially if you expect your application to work offline with service workers).</p></div><div class="code-block"><pre><code class="language-javascript">import displayLoadError from &quot;./components/LoadError&quot;;
        
const routes = [
  {
    name: &quot;One&quot;,
    path: &quot;one&quot;,
    on: {
      initial: () =&gt; import(&quot;./components/One.js&quot;)
        .then(module =&gt; module.default)
        .catch(err =&gt; displayLoadError(err))
    },
    response({ resolved }) {
      return {
        body: resolved.initial
      };
    }
  }
];</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>We can go ahead and update the <code class="inline-code language-javascript">routes.js</code> module to remove the imports at the top of the file and use <code class="inline-code language-javascript">import()</code> to import the route components. We will use <code class="inline-code language-javascript">then()</code> to only resolve the component instead of the entire module object.</p><p>The <code class="inline-code language-javascript">response()</code> functions should also be updated to set the return object&#x27;s <code class="inline-code language-javascript">body</code> property to<!-- --> <code class="inline-code language-javascript">resolved.initial</code></p></div><div class="code-block"><pre data-line="6-14,19-27,32-40,45-53"><code class="language-javascript">// src/routes.js
export default [
  {
    name: &quot;Home&quot;,
    path: &quot;&quot;,
    on: {
      initial: () =&gt; import(&quot;./components/Home&quot;)
        .then(module =&gt; module.default)
    },
    response({ resolved }) {
      return {
        body: resolved.initial
      };
    }
  },
  {
    name: &quot;Book&quot;,
    path: &quot;book/:id&quot;,
    on: {
      initial: () =&gt; import(&quot;./components/Book&quot;)
        .then(module =&gt; module.default)
    },
    response({ resolved }) {
      return {
        body: resolved.initial
      };
    }
  },
  {
    name: &quot;Checkout&quot;,
    path: &quot;checkout&quot;,
    on: {
      initial: () =&gt; import(&quot;./components/Checkout&quot;)
      .then(module =&gt; module.default)
    },
    response({ resolved }) {
      return {
        body: resolved.initial
      };
    }
  },
  {
    name: &quot;Catch All&quot;,
    path: &quot;(.*)&quot;,
    on: {
      initial: () =&gt; import(&quot;./components/NotFound&quot;)
      .then(module =&gt; module.default)
    },
    response({ resolved }) {
      return {
        body: resolved.initial
      };
    }
  }
];</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>We will also update the <code class="inline-code language-javascript">index.js</code> module to use<!-- --> <code class="inline-code language-javascript">router.respond()</code> to delay the initial render.</p></div><div class="code-block"><pre data-line="16-34"><code class="language-javascript">// src/index.js
import React from &#x27;react&#x27;;
import ReactDOM from &#x27;react-dom&#x27;;
import curi from &#x27;@curi/router&#x27;;
import Browser from &#x27;@hickory/browser&#x27;;
import { CuriProvider } from &#x27;@curi/react&#x27;;

import &#x27;./index.css&#x27;;
import routes from &#x27;./routes&#x27;;
import NavMenu from &#x27;./components/NavMenu&#x27;;
import registerServiceWorker from &#x27;./registerServiceWorker&#x27;;

const history = Browser();
const router = curi(history, routes);

router.respond(() =&gt; {
  ReactDOM.render((
    &lt;CuriProvider router={router}&gt;
      {({ response, router }) =&gt; {
        const { body:Body } = response;
        return (
          &lt;div&gt;
            &lt;header&gt;
              &lt;NavMenu /&gt;
            &lt;/header&gt;
            &lt;main&gt;
              &lt;Body response={response} router={router} /&gt;
            &lt;/main&gt;
          &lt;/div&gt;
        );
      }}
    &lt;/CuriProvider&gt;
  ), document.getElementById(&#x27;root&#x27;));
});
registerServiceWorker();</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>With those changes, Webpack will now split the application into multiple bundles. The initial render will be delayed until after the code split bundle for the first route has been loaded.</p></div></div></div><div class="section" id="preloading-data"><h2>Preloading Data<a class="header-link" href="/tutorial/react-advanced#preloading-data">#</a></h2><div class="side-by-side"><div class="explanation"><p>Preloading data lets you delay navigation until after the data for a route has loaded. This can save you from having to render a partial page with spinners if the data takes a while to load.</p><p>While the data is loading, the user will be able to continue interacting with the current page. This means that the user can also start a new navigation while the current navigation is running. When this happens, Curi knows to to cancel the previous navigation and perform the new navigation instead.</p><p>We have two routes that need to load data: <code class="inline-code language-javascript">Home</code> and<!-- --> <code class="inline-code language-javascript">Book</code>. The <code class="inline-code language-javascript">Home</code> route will load the known books, while the <code class="inline-code language-javascript">Book</code> route will load data about a specific book.</p><p>Currently the data for both of these routes is imported in their components. In a real site you would most likely make API calls to a REST or GraphQL endpoint, but here we will simulate this with a fake API.</p></div></div><div class="subsection" id="fake-api"><h3>The Fake API<a class="header-link" href="/tutorial/react-advanced#fake-api">#</a></h3><div class="side-by-side"><div class="explanation"><p>The fake API will simulate asynchronous calls to the server by returning Promises, similarly to the<!-- --> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>.</p></div></div><div class="side-by-side"><div class="explanation"><p>First, we will create a <code class="inline-code language-javascript">api.js</code> module that exports the fake API functions.</p></div><div class="code-block"><pre><code class="language-bash">touch src/api.js</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>In the API module, we will import the <code class="inline-code language-javascript">books.js</code> data.</p><p>We need to write two functions. The first returns a list of all books and the second returns the data for a specific book. For both, we can use <code class="inline-code language-javascript">Promise.resolve()</code> to return a Promise, even though we don&#x27;t really have any asynchronous code being run.</p></div><div class="code-block"><pre><code class="language-javascript">// src/api.js
import books from &quot;./books&quot;;

export const BOOKS = () =&gt; Promise.resolve(books);

export const BOOK = id =&gt; Promise.resolve(
  books.find(b =&gt; b.id === id)
);</code></pre></div></div></div><div class="side-by-side"><div class="explanation"><p>The fake API functions should be imported in the<!-- --> <code class="inline-code language-javascript">routes.js</code> module so that we can call the functions from the routes&#x27; async methods.</p><p>What do we want to do with the data loaded from the API calls? We can attach it to a response through its <code class="inline-code language-javascript">data</code> property. When we render, we will be able to access that data as<!-- --> <code class="inline-code language-javascript">response.data</code>. <code class="inline-code language-javascript">data</code> can be anything you want it to be. We will set <code class="inline-code language-javascript">data</code> to be an object with appropriately named properties.</p><p>The <code class="inline-code language-javascript">Book</code> API call definitely needs to be performed in<!-- --> <code class="inline-code language-javascript">on.every()</code> because the data it fetches depends on params from the current location. The <code class="inline-code language-javascript">Home</code> API call could be made from either <code class="inline-code language-javascript">on.every()</code> or <code class="inline-code language-javascript">on.initial()</code>. We will use <code class="inline-code language-javascript">on.initial()</code> here because the data will not change, but if the API call returned a random list, you would probably want to use <code class="inline-code language-javascript">on.every()</code> to generate new data every time.</p><p>Because the <code class="inline-code language-javascript">Home</code> route already has an <code class="inline-code language-javascript">import()</code>, we need to use<!-- --> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code class="inline-code language-javascript">Promise.all()</code></a> <!-- -->to add another Promise to wait for.</p><p>The <code class="inline-code language-javascript">Book</code> route&#x27;s <code class="inline-code language-javascript">response()</code> also needs to be updated. Its <code class="inline-code language-javascript">resolved.initial</code> is now an array whose first value is what the <code class="inline-code language-javascript">import()</code> resolved and whose second value is what the <code class="inline-code language-javascript">books()</code>call resolved.</p><p>The <code class="inline-code language-javascript">book()</code> API call expects to be given the <code class="inline-code language-javascript">id</code> <!-- -->number of the book it should return data for. The<!-- --> <code class="inline-code language-javascript">on.every()</code> function is passed an object of matched route properties, so we can grab the correct param (<code class="inline-code language-javascript">id</code>) from the <code class="inline-code language-javascript">params</code> property. However, when params are parsed, they are stored as strings. To convert it to a number, we can use the route&#x27;s<code class="inline-code language-javascript">params</code> property to tell Curi how to parse the<!-- --> <code class="inline-code language-javascript">id</code>. By giving it a function that calls<!-- --> <code class="inline-code language-javascript">parseInt()</code> on the provided value, <code class="inline-code language-javascript">params.id</code> <!-- -->will be a number instead of a string.</p></div><div class="code-block"><pre data-line="2,9-13,16-20,26-28,30-32,35-38"><code class="language-javascript">// src/routes.js
import { BOOKS, BOOK } from &quot;./api&quot;;

export default [
  {
    name: &quot;Home&quot;,
    path: &quot;&quot;,
    on: {
      initial: () =&gt; Promise.all([
        import(&quot;./components/Home&quot;)
          .then(module =&gt; module.default),
        BOOKS()
      ])
    },
    response({ resolved }) {
      const [body, books] = resolved.initial;
      return {
        body,
        data: { books }
      };
    }
  },
  {
    name: &quot;Book&quot;,
    path: &quot;book/:id&quot;,
    params: {
      id: id =&gt; parseInt(id, 10)
    },
    on: {
      initial: () =&gt; import(&quot;./components/Book&quot;)
        .then(module =&gt; module.default),
      every: ({ params }) =&gt; BOOK(params.id)
    },
    response({ resolved }) {
      return {
        body: resolved.initial,
        data: { book: resolved.every }
      };
    }
  },
  {
    name: &quot;Checkout&quot;,
    path: &quot;checkout&quot;,
    on: {
      initial: () =&gt; import(&quot;./components/Checkout&quot;)
      .then(module =&gt; module.default)
    },
    response({ resolved }) {
      return {
        body: resolved.initial
      };
    }
  },
  {
    name: &quot;Catch All&quot;,
    path: &quot;(.*)&quot;,
    on: {
      initial: () =&gt; import(&quot;./components/NotFound&quot;)
      .then(module =&gt; module.default)
    },
    response({ resolved }) {
      return {
        body: resolved.initial
      };
    }
  }
];</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>With the data attached to our responses, we can remove the data imports from the components and just read from the response.</p></div></div><div class="side-by-side"><div class="explanation"><p>In the <code class="inline-code language-jsx">&lt;<!-- -->Home<!-- -->&gt;</code> component&#x27;s module, we can remove the<!-- --> <code class="inline-code language-javascript">books.js</code> import and grab the response from the component&#x27;s props. The books data can be access as<!-- --> <code class="inline-code language-javascript">response.data.books</code>.</p></div><div class="code-block"><pre data-line="5,8"><code class="language-jsx">// src/components/Home.js
import React from &#x27;react&#x27;;
import { Link } from &#x27;@curi/react&#x27;;

export default ({ response }) =&gt; (
  &lt;div&gt;
    &lt;ul&gt;
      {response.data.books.map(book =&gt; (
        &lt;li key={book.id}&gt;
          &lt;Link to=&quot;Book&quot; params={{ id: book.id }} &gt;
            {book.title} by {book.author}
          &lt;/Link&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  &lt;/div&gt;
);</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>Likewise, we can remove the <code class="inline-code language-javascript">books.js</code> import from the<!-- --> <code class="inline-code language-jsx">&lt;<!-- -->Book<!-- -->&gt;</code> component&#x27;s module and grab the book data from<!-- --> <code class="inline-code language-javascript">response.data</code> instead of searching for it in the books array.</p></div><div class="code-block"><pre data-line="7"><code class="language-jsx">// src/components/Book.js
import React from &#x27;react&#x27;;

import cart from &#x27;../cart&#x27;;

export default ({ response, router }) =&gt; {
  const { book } = response.data;
  if (!book) {
    return &lt;div&gt;The requested book could not be found&lt;/div&gt;;
  }
  return (
    &lt;div&gt;
      &lt;h1&gt;{book.title}&lt;/h1&gt;
      &lt;h2&gt;by {book.author}&lt;/h2&gt;
      &lt;p&gt;Published in {book.published}&lt;/p&gt;
      &lt;p&gt;{book.pages} pages&lt;/p&gt;
      &lt;button
        type=&quot;button&quot;
        onClick={() =&gt; {
          cart.add(book, 1);
          router.navigate({ to: &quot;Checkout&quot; });
        }}
      &gt;
        Add to Cart
      &lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre></div></div></div><div class="section" id="loading"><h2>Visualizing Loading<a class="header-link" href="/tutorial/react-advanced#loading">#</a></h2><div class="side-by-side"><div class="explanation"><p>At this point, we have the same functionality as the basic tutorial, but we have added async data loading. The bundle importing has real loading times, but the fake API calls resolve immediately, which doesn&#x27;t necessarily reflect real world performance.</p><p>We can update the fake API to delay resolving so that we can take a look at some of the <code class="inline-code language-javascript">@curi/react</code> components that are navigation-aware. The implementation here isn&#x27;t important, so you can just copy+paste the code. The only thing to know is that the<!-- --> <code class="inline-code language-javascript">BOOKS()</code> function has a one second delay and the<!-- --> <code class="inline-code language-javascript">BOOK()</code> function has a 2.5 second delay the first time a book is requested (and responds instantly on subsequent calls).</p></div><div class="code-block"><pre><code class="language-javascript">// src/api.js
import books from &quot;./books&quot;;

export const BOOKS = () =&gt; new Promise(resolve =&gt; {
  // artificial delay
  setTimeout(() =&gt; {
    resolve(books);
  }, 1000);
});

const BOOK_CACHE = {};
export const BOOK = id =&gt; new Promise(resolve =&gt; {
  if (BOOK_CACHE[id]) {
    resolve(BOOK_CACHE[id]);
    return;
  }
  // artificial delay on first call
  setTimeout(() =&gt; {
    const book = books.find(b =&gt; b.id === id);
    BOOK_CACHE[id] = book;
    resolve(book);
  }, 2500);
});</code></pre></div></div><div class="subsection" id="link-navigating"><h3><span><code class="inline-code language-jsx">&lt;<!-- -->Link<!-- -->&gt;</code> Navigating</span><a class="header-link" href="/tutorial/react-advanced#link-navigating">#</a></h3><div class="side-by-side"><div class="explanation"><p>The <code class="inline-code language-jsx">&lt;<!-- -->Link<!-- -->&gt;</code> component can be called with a render-invoked<!-- --> <code class="inline-code language-javascript">children()</code> function. If you do this, the function will be called with a <code class="inline-code language-javascript">navigating</code> boolean that indicates whether the router is currently navigating to that link. This is useful for when you know that there is a long (multiple seconds) delay between when the user clicks the link and when the navigation will occur.</p><p>We can update the <code class="inline-code language-jsx">&lt;<!-- -->Link<!-- -->&gt;</code>s in the <code class="inline-code language-jsx">&lt;<!-- -->Home<!-- -->&gt;</code> <!-- -->component to using render-invoked functions and display a loading spinner while we wait for the book data to load.</p></div><div class="code-block"><pre><code class="language-jsx">import { Link } from &quot;@curi/react&quot;;
            
&lt;Link to=&quot;Book&quot; params={{ id: 1 }}&gt;
  {navigating =&gt; (
    &lt;React.Fragment&gt;
      Book 1
      {navigating ? &lt;Spinner /&gt; : null}
    &lt;/React.Fragment&gt;
  )}
&lt;/Link&gt;</code></pre></div></div><div class="side-by-side"><div class="explanation"><p><a href="https://github.com/KyleAMathews/react-spinkit"><code class="inline-code language-javascript">react-spinkit</code></a> <!-- -->provides some pretty loading spinners, so we will use that.</p></div><div class="code-block"><pre><code class="language-bash">yarn add react-spinkit</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>In the <code class="inline-code language-jsx">&lt;<!-- -->Home<!-- -->&gt;</code> component&#x27;s module, we need to import the<!-- --> <code class="inline-code language-jsx">&lt;<!-- -->Spinner<!-- -->&gt;</code> component. The <code class="inline-code language-jsx">&lt;<!-- -->Link<!-- -->&gt;</code> needs to be swapped from a React element to a render-invoked function. We wrap the contents in a <code class="inline-code language-jsx">&lt;<!-- -->React.Fragment<!-- -->&gt;</code> to avoid unnecessary DOM elements. In the function, we render a <code class="inline-code language-jsx">&lt;<!-- -->Spinner<!-- -->&gt;</code> when the <code class="inline-code language-jsx">&lt;<!-- -->Link<!-- -->&gt;</code> is navigating and <code class="inline-code language-javascript">null</code> when it is not.</p><div class="note"><strong>Note:</strong> <code class="inline-code language-javascript">react-spinkit</code> is highly customizable, but we are sticking with the defaults here. <code class="inline-code language-javascript">react-spinkit</code> has a default one second render delay, which is why the spinner does not display immediately.</div></div><div class="code-block"><pre data-line="4,12-17"><code class="language-jsx">// src/components/Home.js
import React from &#x27;react&#x27;;
import { Link } from &#x27;@curi/react&#x27;;
import Spinner from &quot;react-spinkit&quot;;

export default ({ response }) =&gt; (
  &lt;div&gt;
    &lt;ul&gt;
      {response.data.books.map(book =&gt; (
        &lt;li key={book.id}&gt;
          &lt;Link to=&quot;Book&quot; params={{ id: book.id }} &gt;
            {navigating =&gt; (
              &lt;React.Fragment&gt;
                {book.title} by {book.author}
                {navigating ? &lt;Spinner /&gt; : null}
              &lt;/React.Fragment&gt;
            )}
          &lt;/Link&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  &lt;/div&gt;
);</code></pre></div></div></div><div class="subsection" id="prefetching"><h3>Data Prefetching<a class="header-link" href="/tutorial/react-advanced#prefetching">#</a></h3><div class="side-by-side"><div class="explanation"><p>Displaying a loading spinner while data loads provides a good visual indication that data is loading, but the user still has to wait.</p><p>Curi has a<!-- --> <a href="/packages/@curi/route-prefetch/">data prefetching route interaction</a> <!-- -->that lets you call the async functions for a route before the user has navigated there. Combined with a cache, this allows you to prefetch data and &quot;instantly&quot; navigate when the user does navigate to a route.</p></div><div class="code-block"><pre><code class="language-bash">yarn add @curi/route-prefetch</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>The prefetch route interaction has to be added to the router when it is created, so we need to update the <code class="inline-code language-javascript">index.js</code> <!-- -->module.</p><p>A route is prefetched by calling<!-- --> <code class="inline-code language-javascript">router.route.prefetch(&quot;Route Name&quot;)</code>. Params and other options can be passed through the function&#x27;s second argument, which you can read more about in the<!-- --> <a href="/packages/@curi/route-prefetch/"><code class="inline-code language-javascript">@curi/route-prefetch</code> documentation</a>.</p></div><div class="code-block"><pre data-line="6,15-17"><code class="language-javascript">// src/index.js
import React from &#x27;react&#x27;;
import ReactDOM from &#x27;react-dom&#x27;;
import curi from &#x27;@curi/router&#x27;;
import Browser from &#x27;@hickory/browser&#x27;;
import prefetch from &#x27;@curi/route-prefetch&#x27;;
import { CuriProvider } from &#x27;@curi/react&#x27;;

import &#x27;./index.css&#x27;;
import routes from &#x27;./routes&#x27;;
import NavMenu from &#x27;./components/NavMenu&#x27;;
import registerServiceWorker from &#x27;./registerServiceWorker&#x27;;

const history = Browser();
const router = curi(history, routes, {
  route: [prefetch()]
});

router.respond(() =&gt; {
  ReactDOM.render((
    &lt;CuriProvider router={router}&gt;
      {({ response, router }) =&gt; {
        const { body:Body } = response;
        return (
          &lt;div&gt;
            &lt;header&gt;
              &lt;NavMenu /&gt;
            &lt;/header&gt;
            &lt;main&gt;
              &lt;Body response={response} router={router} /&gt;
            &lt;/main&gt;
          &lt;/div&gt;
        );
      }}
    &lt;/CuriProvider&gt;
  ), document.getElementById(&#x27;root&#x27;));
});

registerServiceWorker();</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>We are already handling book loads with spinners, so we will prefetch the list of books for the homepage.</p><div class="note"><strong>Note:</strong> <!-- -->Prefetching only works once the app has loaded, so prefetching data for the home page is only really necessary when the user initially navigates to a page that isn&#x27;t the home page.</div><p><code class="inline-code language-javascript">@curi/react</code> provides a <code class="inline-code language-jsx">&lt;<!-- -->Prefetch<!-- -->&gt;</code> component that will automatically prefetch data for a route when the DOM element it renders becomes visible in the page (using the<a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver"><code class="inline-code language-javascript">IntersectionObserver</code>API</a>). If we render a <code class="inline-code language-jsx">&lt;<!-- -->Link<!-- -->&gt;</code> in a <code class="inline-code language-jsx">&lt;<!-- -->Prefetch<!-- -->&gt;</code>, we can prefetch the data for a route when the link to it is visible.</p><p><code class="inline-code language-jsx">&lt;<!-- -->Prefetch<!-- -->&gt;</code> works by passing a <code class="inline-code language-javascript">ref</code> to its render-invoked <code class="inline-code language-javascript">children()</code> function. You need to pass this to the DOM element that should trigger the loading. You should only attach this to host components (e.g. <code class="inline-code language-jsx">&lt;<!-- -->div<!-- -->&gt;</code>,<!-- --> <code class="inline-code language-jsx">&lt;<!-- -->img<!-- -->&gt;</code>, etc.) or components that forward the<!-- --> <code class="inline-code language-javascript">ref</code> to a host component (<code class="inline-code language-javascript">@curi/react</code>&#x27;s<!-- --> <code class="inline-code language-jsx">&lt;<!-- -->Link<!-- -->&gt;</code> does that).</p></div><div class="code-block"><pre><code class="language-jsx">import { Prefetch, Link } from &quot;@curi/react&quot;;
            
&lt;Prefetch
  match={{ name: &quot;Route Name&quot;, params: { id: 2} }}
&gt;
  {ref =&gt; (
    &lt;Link to=&quot;Route Name&quot; params={{ id: 2 }} ref={ref}&gt;
      Route 2
    &lt;/Link&gt;
  )}
&lt;/Prefetch&gt;</code></pre></div></div><div class="side-by-side"><div class="explanation"><p>Before making the data prefetching change, you should load one of the book routes, refresh the page (so the home page data isn&#x27;t cached), and click the link to the home page. As you will see, after clicking the link there is a one second delay before the home page is rendered.</p><p>We link to the home page from the header menu component (<code class="inline-code language-jsx">&lt;<!-- -->NavMenu<!-- -->&gt;</code>), so that is where we want to prefetch the data for the home page. To prefetch the home page data, we wrap the<!-- --> <code class="inline-code language-jsx">&lt;<!-- -->Link<!-- -->&gt;</code> in a <code class="inline-code language-jsx">&lt;<!-- -->Prefetch<!-- -->&gt;</code>, tell the<!-- --> <code class="inline-code language-jsx">&lt;<!-- -->Prefetch<!-- -->&gt;</code> which route to prefetch data for, and pass its<!-- --> <code class="inline-code language-javascript">ref</code> to the element whose visibility should trigger prefetching.</p><p>Once you have made these changes to the code, you should try replicating the steps from above (navigate to a book page, refresh, and click the home page button). Now, instead of waiting for a second, the home page should load essentially instantly!</p></div><div class="code-block"><pre data-line="3,9-11"><code class="language-jsx">// src/components/NavMenu.js
import React from &#x27;react&#x27;;
import { Prefetch, Link } from &#x27;@curi/react&#x27;;

export default () =&gt; (
  &lt;nav&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;Prefetch match={{ name: &quot;Home&quot; }}&gt;
          {ref =&gt; &lt;Link to=&quot;Home&quot; ref={ref}&gt;Home&lt;/Link&gt;}
        &lt;/Prefetch&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;Link to=&quot;Checkout&quot;&gt;Checkout&lt;/Link&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/nav&gt;
);</code></pre></div></div></div></div><div class="section" id="caveats"><h2>Async Caveats<a class="header-link" href="/tutorial/react-advanced#caveats">#</a></h2><div class="side-by-side"><div class="explanation"><p>Adding asynchronous loading to an application can help reduce initial load size and speed up user interactions, however it also has some issues that you will need to consider.</p><p>The biggest consideration is that there is nothing the frontend can do to get the data for the initial render faster. Your application&#x27;s frontend can only fetch data as it discovers it needs it. If you are performing server-side rendering, you may want to load the initial data on the server and inject it into the page&#x27;s HTML output. The implementation details for this vary greatly and are more related to how you store data (e.g.<!-- --> <a href="https://redux.js.org/recipes/server-rendering#the-server-side">with redux</a>).</p><p>Another consideration is whether or not you want to &quot;hoist&quot; data requirements. Curi&#x27;s async functionality relies on you knowing all of the data requirements for a route, but you might prefer to keep the data associated with individual components. React Suspense will help with this (and Curi will support it once it releases), but this is still a ways out. At the very least, I would recommend using Curi for code splitting routes. Whether your should hoist other data requirements is something that should be determined on a case-by-case basis.</p></div></div></div></div><div class="page-links"><button type="button" class="toggler">Menu</button><div class="children"><h2>Tutorials</h2><ul><li class="link-group"><h3>Basic</h3><ul class="link-list"><li class="solo"><a class=" " href="/tutorial/react-basics">React Basics</a></li><li class="solo"><a class=" " href="/tutorial/vue-basics">Vue Basics</a></li></ul></li><li class="link-group"><h3>Advanced</h3><ul class="link-list"><li class="solo"><a class=" active" href="/tutorial/react-advanced">React Advanced</a></li></ul></li></ul></div></div></div></main></div>
    <script src="https://unpkg.com/react@16.3.1/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16.3.1/umd/react-dom.production.min.js"></script>
    <script src="/static/js/prism.js"></script>
    <script src="/static/js/bundle.js"></script>
  </body>
</html>
